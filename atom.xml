<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Eugene's Blog]]></title>
  <subtitle><![CDATA[成长之旅]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ernestyj.github.io/"/>
  <updated>2015-12-16T10:35:21.421Z</updated>
  <id>http://ernestyj.github.io/</id>
  
  <author>
    <name><![CDATA[Jian Yang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Unique Paths II - 唯一路径II]]></title>
    <link href="http://ernestyj.github.io/2015/12/16/Unique%20Paths%20II%20-%20%E5%94%AF%E4%B8%80%E8%B7%AF%E5%BE%84II/"/>
    <id>http://ernestyj.github.io/2015/12/16/Unique Paths II - 唯一路径II/</id>
    <published>2015-12-16T12:44:47.000Z</published>
    <updated>2015-12-16T10:35:21.421Z</updated>
    <content type="html"><![CDATA[<h3 id="Unique_Paths_II_-_唯一路径II">Unique Paths II - 唯一路径II</h3><p><strong>Description</strong>: Follow up for “Unique Paths”:<br> Now consider if some obstacles are added to the grids. How many unique paths would there be?<br> An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>
<p> Note: m and n will be at most 100.</p>
<p>思路：动态规划：res[i][j]=res[i-1][j]+res[i][j-1]。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniquePathsII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[][] obstacleGrid = &#123;&#123;0,0,0&#125;,</span></span><br><span class="line"><span class="comment">//                                &#123;0,1,0&#125;,</span></span><br><span class="line"><span class="comment">//                                &#123;0,0,0&#125;&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[][] obstacleGrid = &#123;&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> UniquePathsII().uniquePathsWithObstacles(obstacleGrid));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 动态规划：res[i][j]=res[i-1][j]+res[i][j-1]</span><br><span class="line">     * <span class="doctag">@param</span> obstacleGrid</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid[m-<span class="number">1</span>][n-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            res[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            res[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] != <span class="number">1</span>)&#123;</span><br><span class="line">                    res[i][j] = res[i-<span class="number">1</span>][j] + res[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Unique_Paths_II_-_唯一路径II">Unique Paths II - 唯一路径II</h3><p><strong>Description</strong>: Follow up for “Unique Paths”:<br> Now consid]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Unique Paths - 唯一路径]]></title>
    <link href="http://ernestyj.github.io/2015/12/15/Unique%20Paths%20-%20%E5%94%AF%E4%B8%80%E8%B7%AF%E5%BE%84/"/>
    <id>http://ernestyj.github.io/2015/12/15/Unique Paths - 唯一路径/</id>
    <published>2015-12-15T12:44:47.000Z</published>
    <updated>2015-12-15T05:19:08.236Z</updated>
    <content type="html"><![CDATA[<h3 id="Unique_Paths_-_唯一路径">Unique Paths - 唯一路径</h3><p><strong>Description</strong>: A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).<br> The robot can only move either down or right at any point in time.<br> The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).<br> How many possible unique paths are there?</p>
<p> Note: m and n will be at most 100.</p>
<p>方法：</p>
<ol>
<li>转化为组合数求解：<br>从m+n-2个位置中挑选n-1个位置；C(n, k)=n(n-1)(n-2)…(n-k+1)/k!<br>  注意：要计算阶乘的部分用double，否则很容易越界；<br>  时间复杂度：O(min(m,n))，因为只需做一次行或者列的扫描；<br>  空间复杂度：O(1)。<ol>
<li>递归：到达某一格的路径数量等于它的上面和左边的路径数之和，结束条件是走到行或者列的边缘；<br>时间复杂度：结果数量的量级。测试用例会超时。</li>
</ol>
</li>
<li>动态规划：res[i][j]=res[i-1][j]+res[i][j-1]，在递归基础上用一个数组来保存历史结果，降低时间复杂度；<br>为简化存储，只需要用一个一维数组存上一行的信息即可。<br>时间复杂度：O(m*n)；空间复杂度：O(n)。<br>参考：<a href="http://blog.csdn.net/linhuanmars/article/details/22126357" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/22126357</a></li>
</ol>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniquePaths</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 转化为组合数求解：从m+n-2个位置中挑选n-1个位置；C(n, k)=n(n-1)(n-2)...(n-k+1)/k!</span><br><span class="line">     * 注意：要计算阶乘的部分用double，否则很容易越界；</span><br><span class="line">     * 时间复杂度：O(min(m,n))，因为只需做一次行或者列的扫描；</span><br><span class="line">     * 空间复杂度：O(1)。</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> numerator = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> denominator = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> small = m&lt;n ? m-<span class="number">1</span> : n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=small; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            denominator *= i;</span><br><span class="line">            numerator *= (m+n-<span class="number">2</span>)+<span class="number">1</span>-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(numerator/denominator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 递归：到达某一格的路径数量等于它的上面和左边的路径数之和，结束条件是走到行或者列的边缘；</span><br><span class="line">     * 时间复杂度：结果数量的量级。测试用例会超时。</span><br><span class="line">     * 动态规划：res[i][j]=res[i-1][j]+res[i][j-1]，在递归基础上用一个数组来保存历史结果，降低时间复杂度；</span><br><span class="line">     * 为简化存储，只需要用一个一维数组存上一行的信息即可。</span><br><span class="line">     * 时间复杂度：O(m*n)；空间复杂度：O(n)。</span><br><span class="line">     * 参考：http://blog.csdn.net/linhuanmars/article/details/22126357</span><br><span class="line">     * <span class="doctag">@param</span> m</span><br><span class="line">     * <span class="doctag">@param</span> n</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths1</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">//存上一行的信息</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)  <span class="comment">//m-1+1，多出一行存初始值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++)  <span class="comment">//n-1</span></span><br><span class="line">                res[j] += res[j-<span class="number">1</span>];  <span class="comment">//更新新一行的信息</span></span><br><span class="line">        <span class="keyword">return</span> res[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Unique_Paths_-_唯一路径">Unique Paths - 唯一路径</h3><p><strong>Description</strong>: A robot is located at the top-left corner of a m x n g]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rotate List - 翻转链表]]></title>
    <link href="http://ernestyj.github.io/2015/12/14/Rotate%20List%20-%20%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://ernestyj.github.io/2015/12/14/Rotate List - 翻转链表/</id>
    <published>2015-12-14T12:44:47.000Z</published>
    <updated>2015-12-14T08:49:06.967Z</updated>
    <content type="html"><![CDATA[<h3 id="Rotate_List_-_翻转链表">Rotate List - 翻转链表</h3><p><strong>Description</strong>: Given a list, rotate the list to the right by k places, where k is non-negative.<br> 把后k个rotate到list前面去，k可以超过list本身长度。</p>
<p> For example:<br> Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,<br> return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p>
<p>思路：因为k可以超过list本身长度，可以先首尾连起来，然后找到该断开的地方断开。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为k可以超过list本身长度，可以先首尾连起来，然后找到该断开的地方断开。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;    <span class="comment">//since p is already point to head</span></span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = head;  <span class="comment">//form a loop</span></span><br><span class="line">        k = k % len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - k; i++) p = p.next;</span><br><span class="line">        <span class="comment">//now p points to the prev of the new head</span></span><br><span class="line">        head = p.next;</span><br><span class="line">        p.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Rotate_List_-_翻转链表">Rotate List - 翻转链表</h3><p><strong>Description</strong>: Given a list, rotate the list to the right by k places, ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Permutation Sequence - 全排列有序序列]]></title>
    <link href="http://ernestyj.github.io/2015/12/13/Permutation%20Sequence%20-%20%E5%85%A8%E6%8E%92%E5%88%97%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97/"/>
    <id>http://ernestyj.github.io/2015/12/13/Permutation Sequence - 全排列有序序列/</id>
    <published>2015-12-13T12:44:47.000Z</published>
    <updated>2015-12-13T14:28:32.943Z</updated>
    <content type="html"><![CDATA[<h3 id="Permutation_Sequence_-_全排列有序序列">Permutation Sequence - 全排列有序序列</h3><p><strong>Description</strong>: The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p> By listing and labeling all of the permutations in order, We get the following sequence (ie, for n = 3):<br> 1.”123” 2.”132” 3.”213” 4.”231” 5.”312” 6.”321”</p>
<p> Given n and k, return the kth permutation sequence.</p>
<p> Note: Given n will be between 1 and 9 inclusive.</p>
<p>方法：</p>
<ol>
<li>使用Next Permutation的思路，但会大数据超时；</li>
<li>题目要求全排列有序，而Permutations这题中用回溯法得到的全排列并非有序。使用另一种递归法思路，但是也会大数据超时，超时用例n=9, k=54494。<br>参考：<a href="http://www.ericleschinski.com/c/java_permutations_recursion/" target="_blank" rel="external">http://www.ericleschinski.com/c/java_permutations_recursion/</a></li>
<li>发现数学规律进行解题：<br>  a. 以某一数字开头的排列有(n-1)!个，先计算(n-1)!；k=k-1将k转换为从0开始（原来k从1开始）；<br>  b. 第一位数字是“原字符串”位置k/(n-1)!处的字符；更新k=k%(n-1)!；<br>  c. 第二位数字是“原字符串”位置k/(n-2)!处的字符；更新k=k%(n-2)!；<br>  d. 不断重复b、c，直至第n位数字。（注意：每确定一位数字，“原字符串”应移除该数字）<br>  时间复杂度：O(n^2)；空间复杂度：O(n)；<br>  参考：<a href="http://blog.csdn.net/linhuanmars/article/details/22028697" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/22028697</a></li>
</ol>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermutationSequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String result = <span class="keyword">new</span> PermutationSequence().getPermutation(<span class="number">9</span>, <span class="number">362880</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 发现数学规律进行解题：</span><br><span class="line">     * 1. 以某一数字开头的排列有(n-1)!个，先计算(n-1)!；k=k-1将k转换为从0开始（原来k从1开始）；</span><br><span class="line">     2. 第一位数字是“原字符串”位置k/(n-1)!处的字符；更新k=k%(n-1)!；</span><br><span class="line">     3. 第二位数字是“原字符串”位置k/(n-2)!处的字符；更新k=k%(n-2)!；</span><br><span class="line">     4. 不断重复2、3，直至第n位数字。（注意：每确定一位数字，“原字符串”应移除该数字）</span><br><span class="line">     时间复杂度：O(n^2)；空间复杂度：O(n)；</span><br><span class="line">     参考：http://blog.csdn.net/linhuanmars/article/details/22028697</span><br><span class="line">     * <span class="doctag">@param</span> n</span><br><span class="line">     * <span class="doctag">@param</span> k</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//生成原字符串</span></span><br><span class="line">        List&lt;Integer&gt; origin = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) origin.add(i);</span><br><span class="line">        <span class="comment">//计算(n-1)!</span></span><br><span class="line">        <span class="keyword">int</span> factorial = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) factorial *= i;</span><br><span class="line">        <span class="comment">//k转换为从0开始</span></span><br><span class="line">        k = k - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算Kth全排列串中第i位(0&lt;i&lt;n)数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = k / factorial;  <span class="comment">//得到第i位数字字符</span></span><br><span class="line">            k = k % factorial;  <span class="comment">//更新k</span></span><br><span class="line">            sb.append(origin.get(index));</span><br><span class="line">            origin.remove(index); <span class="comment">//每确定一位数字，“原字符串”应移除该数字</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) &#123;    <span class="comment">//更新factorial</span></span><br><span class="line">                factorial = factorial / (n - <span class="number">1</span> - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 使用Next Permutation会大数据超时</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**TODO 此解法大数据超时，超时用例n=9, k=54494</span><br><span class="line">     * 题目要求全排列有序，而Permutations这题中用回溯法得到的全排列并非有序。</span><br><span class="line">     * 另一种思路：递归法。</span><br><span class="line">     * 参考：http://www.ericleschinski.com/c/java_permutations_recursion/</span><br><span class="line">     * <span class="doctag">@param</span> n</span><br><span class="line">     * <span class="doctag">@param</span> k</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) builder.append(i);</span><br><span class="line">        String s = builder.toString();</span><br><span class="line">        permutation(<span class="string">""</span>, s);</span><br><span class="line">        <span class="keyword">return</span> strings.get(k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(String prefix, String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) strings.add(prefix);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                permutation(prefix + str.charAt(i), str.substring(<span class="number">0</span>, i) + str.substring(i+<span class="number">1</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Permutation_Sequence_-_全排列有序序列">Permutation Sequence - 全排列有序序列</h3><p><strong>Description</strong>: The set [1,2,3,…,n] contains a t]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spiral Matrix II- 螺旋矩阵2]]></title>
    <link href="http://ernestyj.github.io/2015/12/12/Spiral%20Matrix%20II-%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B52/"/>
    <id>http://ernestyj.github.io/2015/12/12/Spiral Matrix II- 螺旋矩阵2/</id>
    <published>2015-12-12T12:44:47.000Z</published>
    <updated>2015-12-12T11:57:48.273Z</updated>
    <content type="html"><![CDATA[<h3 id="Spiral_Matrix_II-_螺旋矩阵2">Spiral Matrix II- 螺旋矩阵2</h3><p><strong>Description</strong>: Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>
<p> For example,<br> Given n = 3,<br> You should return the following matrix:<br> [<br> [ 1, 2, 3 ],<br> [ 8, 9, 4 ],<br> [ 7, 6, 5 ]<br> ]</p>
<p>思路：与Spiral Matrix的思路基本一致。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiralMatrixII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> SpiralMatrixII().generateMatrix(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] i : matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : i)&#123;</span><br><span class="line">                System.out.print(j + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//若只剩下一行/列，则只处理此行/列，其余按circle方式处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> matrix;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> matrix;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, k = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//if one row/column left, no circle can be formed</span></span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">                matrix[x++][y] = k++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//below, process a circle</span></span><br><span class="line">            <span class="comment">//top - move right</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++) matrix[x][y++] = k++;</span><br><span class="line">            <span class="comment">//right - move down</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++) matrix[x++][y] = k++;</span><br><span class="line">            <span class="comment">//bottom - move left</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++) matrix[x][y--] = k++;</span><br><span class="line">            <span class="comment">//left - move up</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++) matrix[x--][y] = k++;</span><br><span class="line">            x++;</span><br><span class="line">            y++;</span><br><span class="line">            n=n-<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Spiral_Matrix_II-_螺旋矩阵2">Spiral Matrix II- 螺旋矩阵2</h3><p><strong>Description</strong>: Given an integer n, generate a square matrix f]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Insert Interval - 区间插入]]></title>
    <link href="http://ernestyj.github.io/2015/12/10/Insert%20Interval%20-%20%E5%8C%BA%E9%97%B4%E6%8F%92%E5%85%A5/"/>
    <id>http://ernestyj.github.io/2015/12/10/Insert Interval - 区间插入/</id>
    <published>2015-12-10T12:44:47.000Z</published>
    <updated>2015-12-10T15:35:49.935Z</updated>
    <content type="html"><![CDATA[<h3 id="Insert_Interval_-_区间插入">Insert Interval - 区间插入</h3><p><strong>Description</strong>: Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times.</p>
<p> Example 1:<br> Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].</p>
<p> Example 2:<br> Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].<br> This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].</p>
<p>思路：与Merge Intervals相似，只是这道题中给定输入已排好序，且需要插入一个新的值。方法就是先将newInterval插入到intervals，再合并。</p>
<p>注意：将新值插入有序序列中边界条件易出错。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertInterval</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Interval&gt; intervals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        intervals.add(<span class="keyword">new</span> Interval(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">        intervals.add(<span class="keyword">new</span> Interval(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line">        intervals.add(<span class="keyword">new</span> Interval(<span class="number">6</span>, <span class="number">8</span>));</span><br><span class="line">        Interval newInterval = <span class="keyword">new</span> Interval(<span class="number">4</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        List&lt;Interval&gt; result = <span class="keyword">new</span> InsertInterval().insert(intervals, newInterval);</span><br><span class="line">        <span class="keyword">for</span> (Interval interval : result)&#123;</span><br><span class="line">            System.out.print(<span class="string">"["</span> + interval.start + <span class="string">","</span> + interval.end + <span class="string">"] "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line">        Interval() &#123; start = <span class="number">0</span>; end = <span class="number">0</span>; &#125;</span><br><span class="line">        Interval(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123; start = s; end = e; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">insert</span><span class="params">(List&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">        List&lt;Interval&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(newInterval);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将newInterval插入到intervals TODO 边界条件极易出错</span></span><br><span class="line">        <span class="keyword">boolean</span> isEnd = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (newInterval.start &lt;= intervals.get(i).start)&#123;</span><br><span class="line">                intervals.add(i, newInterval);</span><br><span class="line">                isEnd = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isEnd) intervals.add(newInterval);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = intervals.get(<span class="number">0</span>).start;</span><br><span class="line">        <span class="keyword">int</span> end = intervals.get(<span class="number">0</span>).end;</span><br><span class="line">        <span class="keyword">for</span> (Interval interval : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span> (interval.start &gt; end)&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">                start = interval.start;</span><br><span class="line">                end = interval.end;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (interval.end &gt; end)&#123;</span><br><span class="line">                    end = interval.end;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Insert_Interval_-_区间插入">Insert Interval - 区间插入</h3><p><strong>Description</strong>: Given a set of non-overlapping intervals, insert]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Merge Intervals - 区间合并]]></title>
    <link href="http://ernestyj.github.io/2015/12/09/Merge%20Intervals%20-%20%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <id>http://ernestyj.github.io/2015/12/09/Merge Intervals - 区间合并/</id>
    <published>2015-12-09T12:44:47.000Z</published>
    <updated>2015-12-09T11:19:53.099Z</updated>
    <content type="html"><![CDATA[<h3 id="Merge_Intervals_-_区间合并">Merge Intervals - 区间合并</h3><p><strong>Description</strong>: Given a collection of intervals, merge all overlapping intervals.</p>
<p> For example,<br> Given [1,3],[2,6],[8,10],[15,18],<br> return [1,6],[8,10],[15,18].</p>
<p>注意：输入集合不一定是按区间首部排序的。</p>
<p>思路：先按区间首部排序，再合并区间。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeIntervals</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Interval&gt; intervals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//        intervals.add(new Interval(1, 3));</span></span><br><span class="line"><span class="comment">//        intervals.add(new Interval(2, 6));</span></span><br><span class="line"><span class="comment">//        intervals.add(new Interval(8, 10));</span></span><br><span class="line"><span class="comment">//        intervals.add(new Interval(15, 18));</span></span><br><span class="line">        intervals.add(<span class="keyword">new</span> Interval(<span class="number">1</span>,<span class="number">4</span>));</span><br><span class="line">        intervals.add(<span class="keyword">new</span> Interval(<span class="number">0</span>,<span class="number">4</span>));</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        List&lt;Interval&gt; result = <span class="keyword">new</span> MergeIntervals().merge(intervals);</span><br><span class="line">        <span class="keyword">for</span> (Interval interval : result)&#123;</span><br><span class="line">            System.out.print(<span class="string">"["</span> + interval.start + <span class="string">","</span> + interval.end + <span class="string">"] "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line">        Interval() &#123; start = <span class="number">0</span>; end = <span class="number">0</span>; &#125;</span><br><span class="line">        Interval(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123; start = s; end = e; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">        List&lt;Interval&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.size() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        HashMap&lt;Integer, Interval&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Interval interval : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(interval.start)) map.put(interval.start, interval);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Interval oldInterval = map.get(interval.start);</span><br><span class="line">                <span class="keyword">if</span> (oldInterval.end &lt; interval.end)&#123;</span><br><span class="line">                    map.replace(oldInterval.start, interval);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; sortedIntegers = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(map.keySet());</span><br><span class="line">        Collections.sort(sortedIntegers);</span><br><span class="line"></span><br><span class="line">        Interval firstInterval = map.get(sortedIntegers.get(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> start = firstInterval.start;</span><br><span class="line">        <span class="keyword">int</span> end = firstInterval.end;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : sortedIntegers)&#123;</span><br><span class="line">            Interval interval = map.get(i);</span><br><span class="line">            <span class="keyword">if</span> (interval.start &gt; end)&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">                start = interval.start;</span><br><span class="line">                end = interval.end;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (interval.end &gt; end)&#123;</span><br><span class="line">                    end = interval.end;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(<span class="keyword">new</span> Interval(start, end));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Merge_Intervals_-_区间合并">Merge Intervals - 区间合并</h3><p><strong>Description</strong>: Given a collection of intervals, merge all overl]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Jump Game - 跳数游戏]]></title>
    <link href="http://ernestyj.github.io/2015/12/08/Jump%20Game%20-%20%E8%B7%B3%E6%95%B0%E6%B8%B8%E6%88%8F/"/>
    <id>http://ernestyj.github.io/2015/12/08/Jump Game - 跳数游戏/</id>
    <published>2015-12-08T12:44:47.000Z</published>
    <updated>2015-12-08T04:52:00.961Z</updated>
    <content type="html"><![CDATA[<h3 id="Jump_Game_-_跳数游戏">Jump Game - 跳数游戏</h3><p><strong>Description</strong>: Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.</p>
<p> For example:<br> A = [2,3,1,1,4], return true.<br> A = [3,2,1,0,4], return false.</p>
<p>注意与Jump Game II的区别。<br>如果采用DP（复杂度为O(n^2)），大数据测试用例将无法通过。</p>
<p>贪心思路：（复杂度O(n)）<br>用maxLen维护一个从开始位置能到达的最远距离，然后判断<br>     ①在当前位置是否能够到达最后一个位置：(i + nums[i]) &gt;= nums.length - 1<br>     ②当前位置是否可达：maxLen &gt;= i<br>     如果两个条件都满足则返回true；<br>     如果当前位置是0，并且最远距离不能超过当前位置，那么只能返回false；<br>     此外，注意更新最远距离maxLen。</p>
<p>参考：<a href="http://blog.csdn.net/xiaozhuaixifu/article/details/13628465" target="_blank" rel="external">http://blog.csdn.net/xiaozhuaixifu/article/details/13628465</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpGame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> JumpGame().canJump(nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://blog.csdn.net/xiaozhuaixifu/article/details/13628465</span><br><span class="line">     * 注意与Jump Game II的区别。</span><br><span class="line">     * 如果采用DP（复杂度为O(n^2)），大数据测试用例将无法通过。</span><br><span class="line">     * 贪心思路：（复杂度O(n)）</span><br><span class="line">     * 用maxLen维护一个从开始位置能到达的最远距离，然后判断</span><br><span class="line">     ①在当前位置是否能够到达最后一个位置：(i + nums[i]) &gt;= nums.length - 1</span><br><span class="line">     ②当前位置是否可达：maxLen &gt;= i</span><br><span class="line">     如果两个条件都满足则返回true；</span><br><span class="line">     如果当前位置是0，并且最远距离不能超过当前位置，那么只能返回false；</span><br><span class="line">     此外，注意更新最远距离maxLen。</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxLen &gt;= i &amp;&amp; (i + nums[i]) &gt;= nums.length - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(maxLen &lt;= i &amp;&amp; nums[i] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            maxLen = Math.max(i + nums[i], maxLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Jump_Game_-_跳数游戏">Jump Game - 跳数游戏</h3><p><strong>Description</strong>: Given an array of non-negative integers, you are initially p]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spiral Matrix - 螺旋矩阵]]></title>
    <link href="http://ernestyj.github.io/2015/12/07/Spiral%20Matrix%20-%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <id>http://ernestyj.github.io/2015/12/07/Spiral Matrix - 螺旋矩阵/</id>
    <published>2015-12-07T12:44:47.000Z</published>
    <updated>2015-12-08T04:48:55.435Z</updated>
    <content type="html"><![CDATA[<h3 id="Spiral_Matrix_-_螺旋矩阵">Spiral Matrix - 螺旋矩阵</h3><p><strong>Description</strong>: Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p> For example,<br> Given the following matrix:<br> [<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br> ]<br> You should return [1,2,3,6,9,8,7,4,5].</p>
<p>注意：若只剩下一行/列，则只处理此行/列，其余按circle方式处理。<br>参考：<a href="http://www.programcreek.com/2013/01/leetcode-spiral-matrix-java/" target="_blank" rel="external">http://www.programcreek.com/2013/01/leetcode-spiral-matrix-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiralMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125; &#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> SpiralMatrix().spiralOrder(matrix);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : result) System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 若只剩下一行/列，则只处理此行/列，其余按circle方式处理</span><br><span class="line">     * http://www.programcreek.com/2013/01/leetcode-spiral-matrix-java/</span><br><span class="line">     * <span class="doctag">@param</span> matrix</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;<span class="number">0</span> &amp;&amp; n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//if one row/column left, no circle can be formed</span></span><br><span class="line">            <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) result.add(matrix[x][y++]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) result.add(matrix[x++][y]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//below, process a circle</span></span><br><span class="line">            <span class="comment">//top - move right</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++) result.add(matrix[x][y++]);</span><br><span class="line">            <span class="comment">//right - move down</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m-<span class="number">1</span>;i++) result.add(matrix[x++][y]);</span><br><span class="line">            <span class="comment">//bottom - move left</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++) result.add(matrix[x][y--]);</span><br><span class="line">            <span class="comment">//left - move up</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m-<span class="number">1</span>;i++) result.add(matrix[x--][y]);</span><br><span class="line">            x++;</span><br><span class="line">            y++;</span><br><span class="line">            m=m-<span class="number">2</span>;</span><br><span class="line">            n=n-<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Spiral_Matrix_-_螺旋矩阵">Spiral Matrix - 螺旋矩阵</h3><p><strong>Description</strong>: Given a matrix of m x n elements (m rows, n columns)]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maximum Subarray - 最大子串]]></title>
    <link href="http://ernestyj.github.io/2015/12/06/Maximum%20Subarray%20-%20%E6%9C%80%E5%A4%A7%E5%AD%90%E4%B8%B2/"/>
    <id>http://ernestyj.github.io/2015/12/06/Maximum Subarray - 最大子串/</id>
    <published>2015-12-06T12:44:47.000Z</published>
    <updated>2015-12-08T04:46:49.063Z</updated>
    <content type="html"><![CDATA[<h3 id="Maximum_Subarray_-_最大子串">Maximum Subarray - 最大子串</h3><p><strong>Description</strong>: Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p> For example, given the array [−2,1,−3,4,−1,2,1,−5,4],<br> the contiguous subarray [4,−1,2,1] has the largest sum = 6.</p>
<p>思路：动态规划。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumSubarray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">new</span> MaximumSubarray().maxSubArray(nums);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> local = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> global = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; len; k++)&#123;</span><br><span class="line">            <span class="comment">//TODO 注意不是Math.max(local + nums[k], local);</span></span><br><span class="line">            <span class="comment">//若local + nums[k] &lt; nums[k]则直接抛弃k前面的所有数</span></span><br><span class="line">            local = Math.max(local + nums[k], nums[k]);</span><br><span class="line">            global = Math.max(local, global);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> global;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Maximum_Subarray_-_最大子串">Maximum Subarray - 最大子串</h3><p><strong>Description</strong>: Find the contiguous subarray within an array (]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[N Queens - 皇后问题]]></title>
    <link href="http://ernestyj.github.io/2015/12/04/N%20Queens%20-%20%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>http://ernestyj.github.io/2015/12/04/N Queens - 皇后问题/</id>
    <published>2015-12-04T12:44:47.000Z</published>
    <updated>2015-12-06T01:56:26.600Z</updated>
    <content type="html"><![CDATA[<h3 id="N_Queens_-_皇后问题">N Queens - 皇后问题</h3><p><strong>Description</strong>: Given an integer n, return all distinct solutions to the n-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>
<p>皇后问题：每一个的横竖斜都没有其他皇后。</p>
<p>思路：回溯法。<br>关键：每一行只能有一个皇后，用一维数组存每行皇后所在列。用一维数组则在回溯的时候不需进行remove重置操作，因为回溯正好就回到上一行，可以接着找下一个合法列坐标。走完最后一行，坐标（row，colVal[row]）即皇后坐标。<br>参考：<a href="http://www.cnblogs.com/springfor/p/3870944.html" target="_blank" rel="external">http://www.cnblogs.com/springfor/p/3870944.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NQueens</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.cnblogs.com/springfor/p/3870944.html</span><br><span class="line">     * 回溯法</span><br><span class="line">     * 关键：每一行只能有一个皇后，用一维数组存每行皇后所在列。</span><br><span class="line">     * 用一维数组则在回溯的时候不需进行remove重置操作，因为回溯正好就回到上一行，可以接着找下一个合法列坐标。</span><br><span class="line">     * 走完最后一行，坐标（row，colVal[row]）即皇后坐标。</span><br><span class="line">     * <span class="doctag">@param</span> n</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> [] colVal = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dfsHelper(n, res, <span class="number">0</span>, colVal);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsHelper</span><span class="params">(<span class="keyword">int</span> n, List&lt;List&lt;String&gt;&gt; res, <span class="keyword">int</span> row, <span class="keyword">int</span>[] colVal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            List&lt;String&gt; aSolution = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == colVal[i]) s.append(<span class="string">"Q"</span>);</span><br><span class="line">                    <span class="keyword">else</span> s.append(<span class="string">"."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                aSolution.add(s.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(aSolution);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                colVal[row] = i;    <span class="comment">//(row,i)</span></span><br><span class="line">                <span class="keyword">if</span>(isValid(row, colVal)) dfsHelper(n, res, row + <span class="number">1</span>, colVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对角线的判断就是两点行差值和列差值是否相同</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> [] colVal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(colVal[row] == colVal[i] || Math.abs(colVal[row] - colVal[i]) == Math.abs(row - i))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="N_Queens_-_皇后问题">N Queens - 皇后问题</h3><p><strong>Description</strong>: Given an integer n, return all distinct solutions to the n-que]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pow(x, n) - 求指数]]></title>
    <link href="http://ernestyj.github.io/2015/12/03/Pow(x,%20n)%20-%20%E6%B1%82%E6%8C%87%E6%95%B0/"/>
    <id>http://ernestyj.github.io/2015/12/03/Pow(x, n) - 求指数/</id>
    <published>2015-12-03T12:44:47.000Z</published>
    <updated>2015-12-03T09:49:19.319Z</updated>
    <content type="html"><![CDATA[<h3 id="Pow(x,_n)_-_求指数">Pow(x, n) - 求指数</h3><p><strong>Description</strong>: Implement pow(x, n).</p>
<p>思路：二分法（递归）。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Pow().myPow(<span class="number">0.00001</span>, <span class="number">2147483647</span>));</span><br><span class="line"><span class="comment">//        System.out.println(new Pow().myPow(2, 5));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分法（递归）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / power(x, -n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> power(x, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> v = power(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> v * v;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v * v * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Pow(x,_n)_-_求指数">Pow(x, n) - 求指数</h3><p><strong>Description</strong>: Implement pow(x, n).</p>
<p>思路：二分法（递归）。</p>
<p>完整的java代码如下：</p]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Group Anagrams - 易位构词分组]]></title>
    <link href="http://ernestyj.github.io/2015/12/02/Group%20Anagrams%20-%20%E6%98%93%E4%BD%8D%E6%9E%84%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <id>http://ernestyj.github.io/2015/12/02/Group Anagrams - 易位构词分组/</id>
    <published>2015-12-02T12:44:47.000Z</published>
    <updated>2015-12-03T08:24:00.954Z</updated>
    <content type="html"><![CDATA[<h3 id="Group_Anagrams_-_易位构词分组">Group Anagrams - 易位构词分组</h3><p><strong>Description</strong>: Given an array of strings, group anagrams together.</p>
<p> For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br> Return:<br> [<br> [“ate”, “eat”,”tea”],<br> [“nat”,”tan”],<br> [“bat”]<br> ]<br> Note:<br> For the return value, each inner list’s elements must follow the lexicographic order. All inputs will be in lower-case.</p>
<p>思路：易位构词的排序结果是一样的。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupAnagrams</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strs = &#123; <span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span> &#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> GroupAnagrams().groupAnagrams(strs);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; list : result)&#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : list)&#123;</span><br><span class="line">                System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//易位构词的排序结果是一样的</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; books = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">char</span>[] chars;</span><br><span class="line">        List&lt;String&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++)&#123;</span><br><span class="line">            chars = strs[i].toCharArray();</span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line">            s = String.valueOf(chars);</span><br><span class="line">            <span class="keyword">if</span> (books.containsKey(s))&#123;</span><br><span class="line">                books.get(s).add(strs[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                temp.add(strs[i]);</span><br><span class="line">                books.put(s, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(books.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 超时</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams1(String[] strs) &#123;</span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">        List&lt;String&gt; temp;</span><br><span class="line">        HashMap&lt;HashMap&lt;Character, Integer&gt;, List&lt;String&gt;&gt; books = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; book;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++)&#123;</span><br><span class="line">            book = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">//获取小字典</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : strs[i].toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span> (book.containsKey(c)) book.put(c, book.get(c) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> book.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//大字典中找小字典</span></span><br><span class="line">            <span class="keyword">if</span> (books.containsKey(book)) &#123;</span><br><span class="line">                temp = books.get(book);</span><br><span class="line">                temp.add(strs[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                temp.add(strs[i]);</span><br><span class="line">                books.put(book, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(books.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Group_Anagrams_-_易位构词分组">Group Anagrams - 易位构词分组</h3><p><strong>Description</strong>: Given an array of strings, group anagrams toge]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rotate Image - 图像旋转]]></title>
    <link href="http://ernestyj.github.io/2015/12/01/Rotate%20Image%20-%20%E5%9B%BE%E5%83%8F%E6%97%8B%E8%BD%AC/"/>
    <id>http://ernestyj.github.io/2015/12/01/Rotate Image - 图像旋转/</id>
    <published>2015-12-01T12:44:47.000Z</published>
    <updated>2015-12-01T07:27:39.232Z</updated>
    <content type="html"><![CDATA[<h3 id="Rotate_Image_-_图像旋转">Rotate Image - 图像旋转</h3><p><strong>Description</strong>: You are given an n x n 2D matrix representing an image.<br> Rotate the image by 90 degrees (clockwise).</p>
<p> Follow up: Could you do this in-place?</p>
<p>思路：先转置再行逆转。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateImage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = matrix.length;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">new</span> RotateImage().rotate(matrix);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">                System.out.print(matrix[i][j] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先转置再行逆转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                reverseSwap(matrix, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len / <span class="number">2</span>; j++)&#123;</span><br><span class="line">                colSwap(matrix, i, j, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseSwap</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">        matrix[i][j] = matrix[j][i];</span><br><span class="line">        matrix[j][i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">colSwap</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">        matrix[i][j] = matrix[i][len - j - <span class="number">1</span>];</span><br><span class="line">        matrix[i][len - j - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Rotate_Image_-_图像旋转">Rotate Image - 图像旋转</h3><p><strong>Description</strong>: You are given an n x n 2D matrix representing an image]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Permutations II - 含重复元素的全排列]]></title>
    <link href="http://ernestyj.github.io/2015/11/30/Permutations%20II%20-%20%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://ernestyj.github.io/2015/11/30/Permutations II - 含重复元素的全排列/</id>
    <published>2015-11-30T12:44:47.000Z</published>
    <updated>2015-11-30T13:01:51.808Z</updated>
    <content type="html"><![CDATA[<h3 id="Permutations_II_-_含重复元素的全排列">Permutations II - 含重复元素的全排列</h3><p><strong>Description</strong>: Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p> For example,<br> [1,1,2] have the following unique permutations:<br> [1,1,2], [1,2,1], and [2,1,1].</p>
<p>此题与Permutations（无重复元素）思路一致，如下。<br>回溯法：从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理。<br>时间复杂度：n! 空间复杂度：（in place置换）</p>
<p>以abc为例子：</p>
<ol>
<li>a和a交换(固定a), 求后面bc的全排列： abc, acb。 求完后，a 和 b交换； 得到bac,开始第二轮</li>
<li>b和b交换(固定b), 求后面ac的全排列： bac, bca。 求完后，b 和 c交换； 得到cab,开始第三轮</li>
<li>c和c交换(固定c), 求后面ba的全排列： cab, cba.</li>
</ol>
<p>分析图：<a href="http://segmentfault.com/a/1190000002710424" target="_blank" rel="external">http://segmentfault.com/a/1190000002710424</a></p>
<p>注意：此题与Permutations（无重复元素）的不同在于输入集合含有重复元素。注意在回溯中添加跳过重复的判断（若不加则用例{1,-1,1,2,-1,2,2,-1}不通过）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; len &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">continue</span>;    <span class="comment">//跳过重复</span></span><br></pre></td></tr></table></figure></p>
<p>此外，若算法过程中用List存储元素，再通过判同过滤元素将无法通过用例{2,2,-1,2,3}，而算法过程中用Set则可以通过。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermutationsII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums[] = &#123; <span class="number">2</span>,<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">        <span class="keyword">new</span> PermutationsII().permuteUnique(nums);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : result)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : list) System.out.print(i);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Set&lt;List&lt;Integer&gt;&gt; resultSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; temp;</span><br><span class="line">    <span class="comment">/**注意：用例&#123;1,-1,1,2,-1,2,2,-1&#125;&#123;2,2,-1,2,3&#125;容易超时，注意添加跳过重复的逻辑判断</span><br><span class="line">     * 回溯法：从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理。</span><br><span class="line">     * 时间复杂度：n! 空间复杂度：（in place置换）</span><br><span class="line">     * 以abc为例子：</span><br><span class="line">     1. a和a交换(固定a), 求后面bc的全排列： abc, acb。 求完后，a 和 b交换； 得到bac,开始第二轮</span><br><span class="line">     2. b和b交换(固定b), 求后面ac的全排列： bac, bca。 求完后，b 和 c交换； 得到cab,开始第三轮</span><br><span class="line">     3. c和c交换(固定c), 求后面ba的全排列： cab, cba.</span><br><span class="line">     * http://blog.csdn.net/randyjiawenjie/article/details/6313729</span><br><span class="line">     * 分析图：http://segmentfault.com/a/1190000002710424</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        permutation(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;&gt;(resultSet);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == len - <span class="number">1</span>) &#123;</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">                temp.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            resultSet.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; len &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">continue</span>;    <span class="comment">//跳过重复</span></span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">                permutation(nums, start + <span class="number">1</span>, len);</span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Permutations_II_-_含重复元素的全排列">Permutations II - 含重复元素的全排列</h3><p><strong>Description</strong>: Given a collection of numbers that mig]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Permutations - 全排列]]></title>
    <link href="http://ernestyj.github.io/2015/11/29/Permutations%20-%20%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://ernestyj.github.io/2015/11/29/Permutations - 全排列/</id>
    <published>2015-11-29T12:44:47.000Z</published>
    <updated>2015-11-29T14:47:44.790Z</updated>
    <content type="html"><![CDATA[<h3 id="Permutations_-_全排列">Permutations - 全排列</h3><p><strong>Description</strong>: Given a collection of numbers, return all possible permutations.</p>
<p> For example,<br> [1,2,3] have the following permutations:<br> [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].</p>
<p>回溯法：从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理。<br>时间复杂度：n! 空间复杂度：（in place置换）</p>
<p>以abc为例子：</p>
<ol>
<li>a和a交换(固定a), 求后面bc的全排列： abc, acb。 求完后，a 和 b交换； 得到bac,开始第二轮</li>
<li>b和b交换(固定b), 求后面ac的全排列： bac, bca。 求完后，b 和 c交换； 得到cab,开始第三轮</li>
<li>c和c交换(固定c), 求后面ba的全排列： cab, cba.</li>
</ol>
<p>分析图：<a href="http://segmentfault.com/a/1190000002710424" target="_blank" rel="external">http://segmentfault.com/a/1190000002710424</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutations</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span> &#125;;</span><br><span class="line">        <span class="keyword">new</span> Permutations().permute(nums);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; temp;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 回溯法：从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理。</span><br><span class="line">     * 时间复杂度：n! 空间复杂度：（in place置换）</span><br><span class="line">     * 以abc为例子：</span><br><span class="line">     1. a和a交换(固定a), 求后面bc的全排列： abc, acb。 求完后，a 和 b交换； 得到bac,开始第二轮</span><br><span class="line">     2. b和b交换(固定b), 求后面ac的全排列： bac, bca。 求完后，b 和 c交换； 得到cab,开始第三轮</span><br><span class="line">     3. c和c交换(固定c), 求后面ba的全排列： cab, cba.</span><br><span class="line">     * http://blog.csdn.net/randyjiawenjie/article/details/6313729</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        permutation(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span>[] str, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == len - <span class="number">1</span>) &#123;</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">                temp.add(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; i ++) &#123;</span><br><span class="line">                swap(str, start, i);</span><br><span class="line">                permutation(str, start + <span class="number">1</span>, len);</span><br><span class="line">                swap(str, start, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Permutations_-_全排列">Permutations - 全排列</h3><p><strong>Description</strong>: Given a collection of numbers, return all possible permu]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Jump Game II - 跳数游戏]]></title>
    <link href="http://ernestyj.github.io/2015/11/28/Jump%20Game%20II%20-%20%E8%B7%B3%E6%95%B0%E6%B8%B8%E6%88%8F2/"/>
    <id>http://ernestyj.github.io/2015/11/28/Jump Game II - 跳数游戏2/</id>
    <published>2015-11-28T12:44:47.000Z</published>
    <updated>2015-11-28T12:45:24.707Z</updated>
    <content type="html"><![CDATA[<h3 id="Jump_Game_II_-_跳数游戏">Jump Game II - 跳数游戏</h3><p><strong>Description</strong>: Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p> Each element in the array represents your maximum jump length at that position.</p>
<p> Your goal is to reach the last index in the minimum number of jumps.</p>
<p> For example:<br> Given array A = [2,3,1,1,4]<br> The minimum number of jumps to reach the last index is 2.<br> (Jump 1 step from index 0 to 1, then 3 steps to the last index.)</p>
<p>首先明白，这个题只要我们求跳数，怎么跳、最后距离是多少都没让求，不要做无必要的计算。</p>
<p>贪心思路：<br>last:用最小跳数jumps可达的最大距离；<br>curr:用jumps + 1跳可达的最大距离；（贪心值）<br>有curr = max(i+nums[i]), 0 &lt;= i &lt;= last</p>
<p>分析图：<br><a href="http://www.cnblogs.com/lichen782/p/leetcode_Jump_Game_II.html" target="_blank" rel="external">http://www.cnblogs.com/lichen782/p/leetcode_Jump_Game_II.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpGame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> JumpGame().jump(nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 首先明白，这个题只要我们求跳数，怎么跳、最后距离是多少都没让求，不要做无必要的计算。</span><br><span class="line">     * 分析图：http://www.cnblogs.com/lichen782/p/leetcode_Jump_Game_II.html</span><br><span class="line">     * 贪心：</span><br><span class="line">     * last:用最小跳数jumps可达的最大距离；</span><br><span class="line">     * curr:用jumps + 1跳可达的最大距离；（贪心值）</span><br><span class="line">     * 有curr = max(i+nums[i]), 0 &lt;= i &lt;= last</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jumps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; last) &#123;</span><br><span class="line">                ++jumps;</span><br><span class="line">                last = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = Math.max(curr, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jumps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Jump_Game_II_-_跳数游戏">Jump Game II - 跳数游戏</h3><p><strong>Description</strong>: Given an array of non-negative integers, you are initi]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Multiply Strings - 大整数乘法]]></title>
    <link href="http://ernestyj.github.io/2015/11/26/Multiply%20Strings%20-%20%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/"/>
    <id>http://ernestyj.github.io/2015/11/26/Multiply Strings - 大整数乘法/</id>
    <published>2015-11-26T12:44:47.000Z</published>
    <updated>2015-11-26T12:05:20.649Z</updated>
    <content type="html"><![CDATA[<h3 id="Multiply_Strings_-_大整数乘法">Multiply Strings - 大整数乘法</h3><p><strong>Description</strong>: Given two numbers represented as strings, return multiplication of the numbers as a string.<br>Note: The numbers can be arbitrarily large and are non-negative.</p>
<p>思路：首先我们把每一位相乘，得到一个没有进位的临时结果，然后把临时结果从低位起依次进位。对于一个m位整数乘以n位整数的结果，最多只有m+n位。<br>要点：1. 字符串逆转问题；2. 进位（开辟m+n长度数组足以存储所有进位）；3. 结果最高位为0的情况。<br>参考图：<a href="http://www.cnblogs.com/TenosDoIt/p/3735309.html" target="_blank" rel="external">http://www.cnblogs.com/TenosDoIt/p/3735309.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * http://www.cnblogs.com/TenosDoIt/p/3735309.html</span><br><span class="line">    * 首先我们把每一位相乘，得到一个没有进位的临时结果，然后把临时结果从低位起依次进位。</span><br><span class="line">    * 对于一个m位整数乘以n位整数的结果，最多只有m+n位。</span><br><span class="line">    * <span class="doctag">@param</span> num1</span><br><span class="line">    * <span class="doctag">@param</span> num2</span><br><span class="line">    * <span class="doctag">@return</span></span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">       <span class="keyword">char</span>[] l = <span class="keyword">new</span> StringBuilder(num1).reverse().toString().toCharArray();</span><br><span class="line">       <span class="keyword">char</span>[] r = <span class="keyword">new</span> StringBuilder(num2).reverse().toString().toCharArray();</span><br><span class="line">       <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[num1. length() + num2.length()];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num1.length(); i++)&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num2.length(); j++)&#123;</span><br><span class="line">               ints[i + j] += (l[i] - <span class="string">'0'</span>) * (r[j] - <span class="string">'0'</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ints.length; i++)&#123;</span><br><span class="line">           builder.append(ints[i] % <span class="number">10</span>);</span><br><span class="line">           <span class="keyword">if</span> (i + <span class="number">1</span> &lt; ints.length) ints[i + <span class="number">1</span>] += ints[i] / <span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (builder.charAt(ints.length - <span class="number">1</span>) == <span class="string">'0'</span>) builder.deleteCharAt(ints.length - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> builder.reverse().toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Multiply_Strings_-_大整数乘法">Multiply Strings - 大整数乘法</h3><p><strong>Description</strong>: Given two numbers represented as strings, re]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Trapping Rain Water]]></title>
    <link href="http://ernestyj.github.io/2015/11/25/Trapping%20Rain%20Water/"/>
    <id>http://ernestyj.github.io/2015/11/25/Trapping Rain Water/</id>
    <published>2015-11-25T12:44:47.000Z</published>
    <updated>2015-11-25T05:19:38.057Z</updated>
    <content type="html"><![CDATA[<h3 id="Trapping_Rain_Water">Trapping Rain Water</h3><p><strong>Description</strong>: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example,<br> Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.<br> Ref: <a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="external">https://leetcode.com/problems/trapping-rain-water/</a></p>
<p>思路：对某个值A[i]来说，能trapped的最多的water取决于在i之前最高的值leftMostHeight[i]和在i右边的最高的值rightMostHeight[i]（均不包含自身）。如果min(left,right) &gt; A[i]，那么在i这个位置上能trapped的water就是min(left,right) – A[i]。<br>第一遍从左到右计算数组leftMostHeight，第二遍从右到左计算rightMostHeight，在第二遍的同时就可以计算出i位置的结果了，而且并不需要开空间来存放rightMostHeight数组。<br>时间复杂度是O(n)，只扫了两遍。<br>参考：<br><a href="http://blog.unieagle.net/2012/10/31/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Atrapping-rain-water/" target="_blank" rel="external">http://blog.unieagle.net/2012/10/31/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Atrapping-rain-water/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrappingRainWater</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] height = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">int</span> trapped = <span class="keyword">new</span> TrappingRainWater().trap(height);</span><br><span class="line">        System.out.println(trapped);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** http://blog.unieagle.net/2012/10/31/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Atrapping-rain-water/</span><br><span class="line">     * 思路：对某个值A[i]来说，能trapped的最多的water取决于在i之前最高的值leftMostHeight[i]</span><br><span class="line">     和在i右边的最高的值rightMostHeight[i]（均不包含自身）。</span><br><span class="line">     如果min(left,right) &gt; A[i]，那么在i这个位置上能trapped的water就是min(left,right) – A[i]。</span><br><span class="line">     * 第一遍从左到右计算数组leftMostHeight，第二遍从右到左计算rightMostHeight，</span><br><span class="line">     在第二遍的同时就可以计算出i位置的结果了，而且并不需要开空间来存放rightMostHeight数组。</span><br><span class="line">     * 时间复杂度是O(n)，只扫了两遍。</span><br><span class="line">     * <span class="doctag">@param</span> height</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leftMostHeight = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">int</span> max = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> trapped = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;    <span class="comment">//left -&gt; right</span></span><br><span class="line">            leftMostHeight[i] = max;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt; max) max = height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        max = height[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;    <span class="comment">//right -&gt; left</span></span><br><span class="line">            <span class="keyword">if</span> (Math.min(leftMostHeight[i], max) &gt; height[i])&#123;</span><br><span class="line">                trapped += Math.min(leftMostHeight[i], max) - height[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt; max) max = height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> trapped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Trapping_Rain_Water">Trapping Rain Water</h3><p><strong>Description</strong>: Given n non-negative integers representing an elevatio]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[First Missing Positive - 第一个缺失的正整数]]></title>
    <link href="http://ernestyj.github.io/2015/11/24/First%20Missing%20Positive%20-%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0/"/>
    <id>http://ernestyj.github.io/2015/11/24/First Missing Positive - 第一个缺失的正整数/</id>
    <published>2015-11-24T12:44:47.000Z</published>
    <updated>2015-11-24T11:26:41.537Z</updated>
    <content type="html"><![CDATA[<h3 id="First_Missing_Positive_-_第一个缺失的正整数">First Missing Positive - 第一个缺失的正整数</h3><p><strong>Description</strong>: Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,<br> Given [1,2,0] return 3,<br> and [3,4,-1,1] return 2.</p>
<p> Your algorithm should run in O(n) time and uses constant space.</p>
<p>思路：交换数组元素，使得数组中第i位存放数值(i+1)。最后遍历数组，寻找第一个不符合此要求的元素，返回这个元素。整个过程需要遍历两次数组，复杂度为O(n)。<br>参考图：<br><a href="http://www.cnblogs.com/AnnieKim/archive/2013/04/21/3034631.html" target="_blank" rel="external">http://www.cnblogs.com/AnnieKim/archive/2013/04/21/3034631.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstMissingPositive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>,-<span class="number">1</span>,<span class="number">23</span>,<span class="number">7</span>,<span class="number">21</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">18</span>,<span class="number">21</span>,-<span class="number">1</span>,<span class="number">16</span>,<span class="number">1</span>,<span class="number">13</span>,-<span class="number">3</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,-<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">new</span> FirstMissingPositive().firstMissingPositive(nums);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 交换数组元素，使得数组中第i位存放数值(i+1)。最后遍历数组，寻找第一个不符合此要求的元素，</span><br><span class="line">     * 返回这个元素。整个过程需要遍历两次数组，复杂度为O(n)。</span><br><span class="line">     * 参考图：http://www.cnblogs.com/AnnieKim/archive/2013/04/21/3034631.html</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length)&#123;    <span class="comment">//这里不使用for循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; nums.length &amp;&amp; nums[i] != i + <span class="number">1</span> &amp;&amp;</span><br><span class="line">                    nums[nums[i] - <span class="number">1</span>] != nums[i])&#123; <span class="comment">//TODO 此条件易漏，否则进入无限循环</span></span><br><span class="line">                swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="First_Missing_Positive_-_第一个缺失的正整数">First Missing Positive - 第一个缺失的正整数</h3><p><strong>Description</strong>: Given an unsorted intege]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

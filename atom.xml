<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Eugene's Blog]]></title>
  <subtitle><![CDATA[成长之旅]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://eugeneyang.com/"/>
  <updated>2016-05-06T09:07:16.123Z</updated>
  <id>http://eugeneyang.com/</id>
  
  <author>
    <name><![CDATA[Jian Yang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Different Ways to Add Parentheses - 不同添加括号的方式]]></title>
    <link href="http://eugeneyang.com/2016/05/05/Different%20Ways%20to%20Add%20Parentheses%20-%20%E4%B8%8D%E5%90%8C%E6%B7%BB%E5%8A%A0%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://eugeneyang.com/2016/05/05/Different Ways to Add Parentheses - 不同添加括号的方式/</id>
    <published>2016-05-05T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.123Z</updated>
    <content type="html"><![CDATA[<h3 id="Different_Ways_to_Add_Parentheses_-_不同添加括号的方式">Different Ways to Add Parentheses - 不同添加括号的方式</h3><p><strong>Description</strong>: Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.</p>
<p>Example Input: Input: “2<em>3-4</em>5”<br> (2<em>(3-(4</em>5))) = -34<br> ((2<em>3)-(4</em>5)) = -14<br> ((2<em>(3-4))</em>5) = -10<br> (2<em>((3-4)</em>5)) = -10<br> (((2<em>3)-4)</em>5) = 10<br> Output: [-34, -14, -10, -10, 10]</p>
<p>思路：分治法:对于输入字符串，若其中有运算符，则将其分为两部分，分别递归计算其值，然后将左值集合与右值集合进行交叉运算，将运算结果放入结果集中；若没有运算符，则直接将字符串转化为整型数放入结果集中。</p>
<p>参考链接：<a href="http://blog.csdn.net/foreverling/article/details/49742089" target="_blank" rel="external">http://blog.csdn.net/foreverling/article/details/49742089</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DifferentWaysToAddParentheses</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://blog.csdn.net/foreverling/article/details/49742089</span><br><span class="line">     * 分治法:对于输入字符串，若其中有运算符，则将其分为两部分，分别递归计算其值，然后将左值集合与右值集合进行交叉运算，</span><br><span class="line">     将运算结果放入结果集中；若没有运算符，则直接将字符串转化为整型数放入结果集中。</span><br><span class="line">     * <span class="doctag">@param</span> input</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;input.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = input.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch==<span class="string">'+'</span> || ch==<span class="string">'-'</span> || ch==<span class="string">'*'</span>) &#123;</span><br><span class="line">                List&lt;Integer&gt; left = diffWaysToCompute(input.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> n : left) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> m : right) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ch==<span class="string">'+'</span>) res.add(n+m);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (ch==<span class="string">'-'</span>) res.add(n-m);</span><br><span class="line">                        <span class="keyword">else</span> res.add(n*m);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.size()==<span class="number">0</span>)  res.add(Integer.parseInt(input));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Different_Ways_to_Add_Parentheses_-_不同添加括号的方式">Different Ways to Add Parentheses - 不同添加括号的方式</h3><p><strong>Description</strong>: Gi]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Search a 2D Matrix II - 搜索2D矩阵II]]></title>
    <link href="http://eugeneyang.com/2016/05/04/Search%20a%202D%20Matrix%20II%20-%20%E6%90%9C%E7%B4%A22D%E7%9F%A9%E9%98%B5II/"/>
    <id>http://eugeneyang.com/2016/05/04/Search a 2D Matrix II - 搜索2D矩阵II/</id>
    <published>2016-05-04T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.121Z</updated>
    <content type="html"><![CDATA[<h3 id="Search_a_2D_Matrix_II_-_搜索2D矩阵II">Search a 2D Matrix II - 搜索2D矩阵II</h3><p><strong>Description</strong>: Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:<br> Integers in each row are sorted in ascending from left to right.<br> Integers in each column are sorted in ascending from top to bottom.</p>
<p>For example, Consider the following matrix:<br> [<br> [1,   4,  7, 11, 15],<br> [2,   5,  8, 12, 19],<br> [3,   6,  9, 16, 22],<br> [10, 13, 14, 17, 24],<br> [18, 21, 23, 26, 30]<br> ]<br> Given target = 5, return true.<br> Given target = 20, return false.</p>
<p>思路：均从右上角开始搜索.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Search2DMatrixII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 均从右上角开始搜索</span><br><span class="line">     * <span class="doctag">@param</span> matrix</span><br><span class="line">     * <span class="doctag">@param</span> target</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;m &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j]==target)&#123;</span><br><span class="line">                found = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j]&lt;target) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Search_a_2D_Matrix_II_-_搜索2D矩阵II">Search a 2D Matrix II - 搜索2D矩阵II</h3><p><strong>Description</strong>: Write an efficient algorithm]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sliding Window Maximum - 滑动窗口最大值]]></title>
    <link href="http://eugeneyang.com/2016/05/03/Sliding%20Window%20Maximum%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://eugeneyang.com/2016/05/03/Sliding Window Maximum - 滑动窗口最大值/</id>
    <published>2016-05-03T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.119Z</updated>
    <content type="html"><![CDATA[<h3 id="Sliding_Window_Maximum_-_滑动窗口最大值">Sliding Window Maximum - 滑动窗口最大值</h3><p><strong>Description</strong>: Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
<p>思路：一、双端队列维护窗口(存下标). 时间O(N) 空间O(K)<br>二、优先队列(堆)维护窗口. 时间O(NlogK) 空间O(K)</p>
<p>参考链接：<a href="https://segmentfault.com/a/1190000003903509" target="_blank" rel="external">https://segmentfault.com/a/1190000003903509</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlidingWindowMaximum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * https://segmentfault.com/a/1190000003903509</span><br><span class="line">     * 双端队列维护窗口(存下标). 时间O(N) 空间O(K)</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@param</span> k</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len-k+<span class="number">1</span>];</span><br><span class="line">        ArrayDeque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="comment">// 每当新数进来时，如果发现队列头部的数的下标，是窗口最左边数的下标，则扔掉</span></span><br><span class="line">            <span class="keyword">if</span>(!deque.isEmpty() &amp;&amp; deque.peekFirst() == i-k) deque.poll();</span><br><span class="line">            <span class="comment">// 把队列尾部所有比新数小的都扔掉，保证队列是降序的</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()]&lt;nums[i]) deque.removeLast();</span><br><span class="line">            <span class="comment">// 加入新数</span></span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            <span class="comment">// 队列头部就是该窗口内第一大的</span></span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&gt;=k) res[i-k+<span class="number">1</span>] = nums[deque.peek()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优先队列(堆)维护窗口. 时间O(NlogK) 空间O(K)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len==<span class="number">0</span> || k==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len-k+<span class="number">1</span>];</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            queue.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result[<span class="number">0</span>] = queue.peek();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=k; i&lt;len; i++)&#123;</span><br><span class="line">            queue.remove(nums[i-k]);</span><br><span class="line">            queue.offer(nums[i]);</span><br><span class="line">            result[i-k+<span class="number">1</span>] = queue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Sliding_Window_Maximum_-_滑动窗口最大值">Sliding Window Maximum - 滑动窗口最大值</h3><p><strong>Description</strong>: Given an array nums, there i]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Product of Array Except Self - 数组乘积（除当前元素外）]]></title>
    <link href="http://eugeneyang.com/2016/05/02/Product%20of%20Array%20Except%20Self%20-%20%E6%95%B0%E7%BB%84%E4%B9%98%E7%A7%AF%EF%BC%88%E9%99%A4%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E5%A4%96%EF%BC%89/"/>
    <id>http://eugeneyang.com/2016/05/02/Product of Array Except Self - 数组乘积（除当前元素外）/</id>
    <published>2016-05-02T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.116Z</updated>
    <content type="html"><![CDATA[<h3 id="Product_of_Array_Except_Self_-_数组乘积（除当前元素外）">Product of Array Except Self - 数组乘积（除当前元素外）</h3><p><strong>Description</strong>: Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Solve it without division and in O(n).</p>
<p>For example, given [1,2,3,4], return [24,12,8,6].</p>
<p>Follow up:<br>Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)</p>
<p>思路：先从左往右求积,再从右往左求积.</p>
<p>参考链接：<a href="https://leetcode.com/discuss/46104/simple-java-solution-in-o-n-without-extra-space" target="_blank" rel="external">https://leetcode.com/discuss/46104/simple-java-solution-in-o-n-without-extra-space</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductOfArrayExceptSelf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * https://leetcode.com/discuss/46104/simple-java-solution-in-o-n-without-extra-space</span><br><span class="line">     * 先从左往右求积,再从右往左求积.</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">            res[i] = res[i-<span class="number">1</span>] * nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] *= right;</span><br><span class="line">            right *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Product_of_Array_Except_Self_-_数组乘积（除当前元素外）">Product of Array Except Self - 数组乘积（除当前元素外）</h3><p><strong>Description</strong>: Given ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Lowest Common Ancestor of a Binary Tree - 二叉树最低公共祖先节点]]></title>
    <link href="http://eugeneyang.com/2016/04/30/Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9/"/>
    <id>http://eugeneyang.com/2016/04/30/Lowest Common Ancestor of a Binary Tree - 二叉树最低公共祖先节点/</id>
    <published>2016-04-30T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.114Z</updated>
    <content type="html"><![CDATA[<h3 id="Lowest_Common_Ancestor_of_a_Binary_Tree_-_二叉树最低公共祖先节点">Lowest Common Ancestor of a Binary Tree - 二叉树最低公共祖先节点</h3><p><strong>Description</strong>: Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<p>思路：若当前子树同时含p和q,根节点为LCA;若只有其一,则LCA为其一;若都不含,则为null。</p>
<p>参考链接：<a href="https://leetcode.com/discuss/45386/4-lines-c-java-python-ruby" target="_blank" rel="external">https://leetcode.com/discuss/45386/4-lines-c-java-python-ruby</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowestCommonAncestorOfBinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 若当前子树同时含p和q,根节点为LCA;若只有其一,则LCA为其一;若都不含,则为null.</span><br><span class="line">     https://leetcode.com/discuss/45386/4-lines-c-java-python-ruby</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     * <span class="doctag">@param</span> p</span><br><span class="line">     * <span class="doctag">@param</span> q</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left==<span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right==<span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Lowest_Common_Ancestor_of_a_Binary_Tree_-_二叉树最低公共祖先节点">Lowest Common Ancestor of a Binary Tree - 二叉树最低公共祖先节点</h3><p><strong>Descript]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Palindrome Linked List - 回文链表]]></title>
    <link href="http://eugeneyang.com/2016/04/29/Palindrome%20Linked%20List%20-%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>http://eugeneyang.com/2016/04/29/Palindrome Linked List - 回文链表/</id>
    <published>2016-04-29T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.113Z</updated>
    <content type="html"><![CDATA[<h3 id="Palindrome_Linked_List_-_回文链表">Palindrome Linked List - 回文链表</h3><p><strong>Description</strong>: Given a singly linked list, determine if it is a palindrome.<br>Follow up: Could you do it in O(n) time and O(1) space?</p>
<p>思路：一、此法空间O(1),但是很容易出错. 先找到中点并同时逆转前半部分,再从中点往头/尾遍历并比较.<br>二、先转成数组再比较。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromeLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 此法空间O(1),但是很容易出错. 先找到中点并同时逆转前半部分,再从中点往头/尾遍历并比较.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head;</span><br><span class="line">        ListNode p3 = p1.next;</span><br><span class="line">        ListNode pre = p1;</span><br><span class="line">        <span class="comment">//find mid pointer, and reverse head half part</span></span><br><span class="line">        <span class="keyword">while</span>(p2.next != <span class="keyword">null</span> &amp;&amp; p2.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p2 = p2.next.next;</span><br><span class="line">            pre = p1;</span><br><span class="line">            p1 = p3;</span><br><span class="line">            p3 = p3.next;</span><br><span class="line">            p1.next = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//odd number of elements, need left move p1 one step</span></span><br><span class="line">        <span class="keyword">if</span>(p2.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//compare from mid to head/tail</span></span><br><span class="line">        <span class="keyword">while</span>(p3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.val != p3.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p3 = p3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(p.val);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = list.size();</span><br><span class="line">        <span class="keyword">if</span> (len&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(i).compareTo(list.get(len-i-<span class="number">1</span>))!=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Palindrome_Linked_List_-_回文链表">Palindrome Linked List - 回文链表</h3><p><strong>Description</strong>: Given a singly linked list, determ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Lowest Common Ancestor of a Binary Search Tree - 二叉搜索树最低公共祖先节点]]></title>
    <link href="http://eugeneyang.com/2016/04/29/Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree%20-%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9/"/>
    <id>http://eugeneyang.com/2016/04/29/Lowest Common Ancestor of a Binary Search Tree - 二叉搜索树最低公共祖先节点/</id>
    <published>2016-04-29T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.111Z</updated>
    <content type="html"><![CDATA[<h3 id="Lowest_Common_Ancestor_of_a_Binary_Search_Tree_-_二叉搜索树最低公共祖先节点">Lowest Common Ancestor of a Binary Search Tree - 二叉搜索树最低公共祖先节点</h3><p><strong>Description</strong>: Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<p>思路：二分搜索。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowestCommonAncestorOfBinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简洁版</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ((root.val - p.val) * (root.val - q.val) &gt; <span class="number">0</span>)</span><br><span class="line">            root = p.val &lt; root.val ? root.left : root.right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> TreeNode node;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor1</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        binarySearch(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">binarySearch</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> min = p.val, max = q.val;</span><br><span class="line">        <span class="keyword">if</span> (p.val&gt;q.val) &#123;</span><br><span class="line">            min = q.val;</span><br><span class="line">            max = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max&lt;root.val) binarySearch(root.left, p ,q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.val&lt;min) binarySearch(root.right, p, q);</span><br><span class="line">        <span class="keyword">else</span> node = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Lowest_Common_Ancestor_of_a_Binary_Search_Tree_-_二叉搜索树最低公共祖先节点">Lowest Common Ancestor of a Binary Search Tree - 二叉搜索树最低公共祖先节点</h3><]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Number Of Digit One - 数字1的个数]]></title>
    <link href="http://eugeneyang.com/2016/04/28/Number%20Of%20Digit%20One%20-%20%E6%95%B0%E5%AD%971%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/04/28/Number Of Digit One - 数字1的个数/</id>
    <published>2016-04-28T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.108Z</updated>
    <content type="html"><![CDATA[<h3 id="Number_Of_Digit_One_-_数字1的个数">Number Of Digit One - 数字1的个数</h3><p><strong>Description</strong>: Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.<br> For example: Given n = 13,<br> Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.</p>
<p>思路：一、考虑把某一个位数上的数字设成1后，看其他位置有多少种选择。然后把每个数字位取1而有的选择都加起来就可以了。<br>     比如，假设输入为392， 那么把个位设置成1之后，十位和百位的选择就有00~39共40种，所以个位上可以有40个1。然后把十位设置成1之后，百位和个位有 00 ~39共40中选择，注意这儿并不是32或者33种，因为当10位上的数设成1之后，319也是小于392的，所以个位可以取所有的0 ~9。然后百位设成1后，十位和个位有00 ~99，共100种选择。所以加起来就是： 40 + 40 + 100 = 180 种可能性，也就是180 个 1。</p>
<p>二、按个位/十位…分别计算一的个数:<br>1 . 设k为数字所在位(个位k=1,百位k=10),<br>     k=1时,由于每10个数其个位就必定有1个一,于是有(n/k)/10组十个数;<br>     k=10时,由于每100个数其十位就必定有10个一,于是有(n/k)/10组一百个数,其十位上一的个数有(n/k)/10<em>k;<br>     …<br>     设r=n/k,k处一的个数为r/10</em>k;</p>
<pre><code><span class="number">2.</span> 处理特殊情况,每<span class="number">10</span>个组出现额外<span class="number">1</span>个一,设m=n%k,修正k处一的个数为r/<span class="number">10</span>*k + (r%<span class="number">10</span>==<span class="number">1</span>?m+<span class="number">1</span>:<span class="number">0</span>)
<span class="number">3.</span> 继续特殊情况,如n=<span class="number">20</span>,其十位一的个数应该额外加<span class="number">10</span>,规律是当前位的数字≥<span class="number">2</span>时应额外加<span class="number">10</span>, 修正k处一的个数为(r+<span class="number">8</span>)/<span class="number">10</span>*k + (r%<span class="number">10</span>==<span class="number">1</span>?m+<span class="number">1</span>:<span class="number">0</span>)
</code></pre><p>参考链接：<a href="https://leetcode.com/discuss/85529/very-easy-to-understand-java-solution-0ms-%E9%99%84%E4%B8%AD%E6%96%87%E8%A7%A3%E9%87%8A" target="_blank" rel="external">https://leetcode.com/discuss/85529/very-easy-to-understand-java-solution-0ms-%E9%99%84%E4%B8%AD%E6%96%87%E8%A7%A3%E9%87%8A</a><br><a href="https://leetcode.com/discuss/46366/ac-short-java-solution" target="_blank" rel="external">https://leetcode.com/discuss/46366/ac-short-java-solution</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOfDigitOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * https://leetcode.com/discuss/85529/very-easy-to-understand-java-solution-0ms-%E9%99%84%E4%B8%AD%E6%96%87%E8%A7%A3%E9%87%8A</span><br><span class="line">     * 考虑把某一个位数上的数字设成1后，看其他位置有多少种选择。然后把每个数字位取1而有的选择都加起来就可以了。</span><br><span class="line">     比如，假设输入为392， 那么把个位设置成1之后，十位和百位的选择就有00~39共40种，所以个位上可以有40个1。</span><br><span class="line">     然后把十位设置成1之后，百位和个位有 00 ~39共40中选择，注意这儿并不是32或者33种，</span><br><span class="line">     因为当10位上的数设成1之后，319也是小于392的，所以个位可以取所有的0~9。然后百位设成1后，十位和个位有00~99，共100种选择。</span><br><span class="line">     所以加起来就是： 40 + 40 + 100 = 180 种可能性，也就是180 个 1。</span><br><span class="line">     // A number is divided into three parts, front, curDigit and rear.</span><br><span class="line">     For example, if input is 123456789, when we are considering the situation if we set the digit 5 to 1,</span><br><span class="line">     then: front = 1234, curDigit = 5, rear = 6789, rearSize = 1000</span><br><span class="line">     * <span class="doctag">@param</span> n</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rearSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> mod = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(mod &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">long</span> front = n / (mod * <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">long</span> rear = n % mod;</span><br><span class="line">            <span class="keyword">int</span> curDigit =(<span class="keyword">int</span>) (n % (mod * <span class="number">10</span>)) / rearSize;</span><br><span class="line">            <span class="keyword">if</span>(curDigit &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                count += ((front + <span class="number">1</span>) * rearSize);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curDigit == <span class="number">1</span>)&#123;</span><br><span class="line">                count += (front * rearSize + rear + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                count += (front * rearSize);</span><br><span class="line">            &#125;</span><br><span class="line">            mod *= <span class="number">10</span>;</span><br><span class="line">            rearSize *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * https://leetcode.com/discuss/46366/ac-short-java-solution</span><br><span class="line">     * 按个位/十位...分别计算一的个数:</span><br><span class="line">     * 1. 设k为数字所在位(个位k=1,百位k=10),</span><br><span class="line">     k=1时,由于每10个数其个位就必定有1个一,于是有(n/k)/10组十个数;</span><br><span class="line">     k=10时,由于每100个数其十位就必定有10个一,于是有(n/k)/10组一百个数,其十位上一的个数有(n/k)/10*k;...</span><br><span class="line">     设r=n/k,k处一的个数为r/10*k;</span><br><span class="line">     2. 处理特殊情况,每10个组出现额外1个一,设m=n%k,修正k处一的个数为r/10*k + (r%10==1?m+1:0)</span><br><span class="line">     3. 继续特殊情况,如n=20,其十位一的个数应该额外加10,规律是当前位的数字≥2时应额外加10,</span><br><span class="line">     修正k处一的个数为(r+8)/10*k + (r%10==1?m+1:0)</span><br><span class="line"></span><br><span class="line">     * <span class="doctag">@param</span> n</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> k = <span class="number">1</span>; k &lt;= n; k *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> r = n/k, m = n%k;</span><br><span class="line">            <span class="comment">// sum up the count of ones on every place k</span></span><br><span class="line">            count += (r+<span class="number">8</span>)/<span class="number">10</span>*k + (r%<span class="number">10</span>==<span class="number">1</span> ? m+<span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO Memory Limit Exceeded</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            builder.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;builder.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (builder.charAt(i)==<span class="string">'1'</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Number_Of_Digit_One_-_数字1的个数">Number Of Digit One - 数字1的个数</h3><p><strong>Description</strong>: Given an integer n, count the total ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kth Smallest Element in a BST - 二叉搜索树中第K小元素]]></title>
    <link href="http://eugeneyang.com/2016/04/25/Kth%20Smallest%20Element%20in%20a%20BST%20-%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E5%85%83%E7%B4%A0/"/>
    <id>http://eugeneyang.com/2016/04/25/Kth Smallest Element in a BST - 二叉搜索树中第K小元素/</id>
    <published>2016-04-25T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.106Z</updated>
    <content type="html"><![CDATA[<h3 id="Kth_Smallest_Element_in_a_BST_-_二叉搜索树中第K小元素">Kth Smallest Element in a BST - 二叉搜索树中第K小元素</h3><p><strong>Description</strong>: Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.<br>Note: You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p> Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
<p> Hint: Try to utilize the property of a BST.<br> What if you could modify the BST node’s structure?<br> The optimal runtime complexity is O(height of BST).</p>
<p>思路：一、二分搜索O(h=logn),充分利用BST的大小排列性质<br>二、递归中序遍历取第k小 O(n)</p>
<p>参考链接：<a href="https://leetcode.com/discuss/43771/implemented-java-binary-search-order-iterative-recursive" target="_blank" rel="external">https://leetcode.com/discuss/43771/implemented-java-binary-search-order-iterative-recursive</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthSmallestElementInBST</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**https://leetcode.com/discuss/43771/implemented-java-binary-search-order-iterative-recursive</span><br><span class="line">     * 二分搜索O(h=logn),充分利用BST的大小排列性质</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     * <span class="doctag">@param</span> k</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = countNodes(root.left);</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= count) &#123;   <span class="comment">//在左子树</span></span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root.left, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; count + <span class="number">1</span>) &#123; <span class="comment">//在右子树</span></span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root.right, k-<span class="number">1</span>-count); <span class="comment">// 1 is counted as current node</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countNodes(n.left) + countNodes(n.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归中序遍历取第k小 O(n)</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest1</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> list.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(node.left);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        inorder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Kth_Smallest_Element_in_a_BST_-_二叉搜索树中第K小元素">Kth Smallest Element in a BST - 二叉搜索树中第K小元素</h3><p><strong>Description</strong>: Given ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Majority Element II - 众数II]]></title>
    <link href="http://eugeneyang.com/2016/04/24/Majority%20Element%20II%20-%20%E4%BC%97%E6%95%B0II/"/>
    <id>http://eugeneyang.com/2016/04/24/Majority Element II - 众数II/</id>
    <published>2016-04-24T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.104Z</updated>
    <content type="html"><![CDATA[<h3 id="Majority_Element_II_-_众数II">Majority Element II - 众数II</h3><p><strong>Description</strong>: Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.</p>
<p>思路：Moore’s Voting Algorithm:根据题目有两个候选者,分别为这两个数设置count计数,遍历数组若出现相同的数则加一,否则都减一.当任一count为0时,候选者替换为当前数.再遍历一次数组,确认出现次数超过⌊ n/3 ⌋。</p>
<p>参考链接：<a href="https://leetcode.com/discuss/69126/concise-java-solution-based-on-moores-voting-algorithm" target="_blank" rel="external">https://leetcode.com/discuss/69126/concise-java-solution-based-on-moores-voting-algorithm</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MajorityElementII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Moore's Voting Algorithm:根据题目有两个候选者,分别为这两个数设置count计数,遍历数组若出现相同的数则加一,否则都减一.</span><br><span class="line">     当任一count为0时,候选者替换为当前数.再遍历一次数组,确认出现次数超过⌊ n/3 ⌋.</span><br><span class="line">     * https://leetcode.com/discuss/69126/concise-java-solution-based-on-moores-voting-algorithm</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> fir = <span class="number">0</span>, sec = <span class="number">1</span>;   <span class="comment">//TODO 使fir,sec两数保持不同</span></span><br><span class="line">        <span class="keyword">int</span> firCount = <span class="number">0</span>, secCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fir == nums[i]) firCount++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sec == nums[i]) secCount++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (firCount == <span class="number">0</span>) &#123;</span><br><span class="line">                fir = nums[i];</span><br><span class="line">                firCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secCount == <span class="number">0</span>) &#123;</span><br><span class="line">                sec = nums[i];</span><br><span class="line">                secCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                firCount--;</span><br><span class="line">                secCount--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        firCount = <span class="number">0</span>; secCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;    <span class="comment">// Count again for x1, x2</span></span><br><span class="line">            <span class="keyword">if</span> (i == fir) firCount++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == sec) secCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (firCount&gt;len/<span class="number">3</span>) res.add(fir);</span><br><span class="line">        <span class="keyword">if</span> (secCount&gt;len/<span class="number">3</span>) res.add(sec);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Majority_Element_II_-_众数II">Majority Element II - 众数II</h3><p><strong>Description</strong>: Given an integer array of size n, find a]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Summary Ranges - 区间归纳]]></title>
    <link href="http://eugeneyang.com/2016/04/23/Summary%20Ranges%20-%20%E5%8C%BA%E9%97%B4%E5%BD%92%E7%BA%B3/"/>
    <id>http://eugeneyang.com/2016/04/23/Summary Ranges - 区间归纳/</id>
    <published>2016-04-23T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.102Z</updated>
    <content type="html"><![CDATA[<h3 id="Summary_Ranges_-_区间归纳">Summary Ranges - 区间归纳</h3><p><strong>Description</strong>: Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>For example, given [0,1,2,4,5,7], return [“0-&gt;2”,”4-&gt;5”,”7”].</p>
<p>思路简单，注意如何写出简洁的代码。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SummaryRanges</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span>&lt;nums.length &amp;&amp; nums[i+<span class="number">1</span>]-nums[i]==<span class="number">1</span>) i++;</span><br><span class="line">            <span class="keyword">if</span>(n!=nums[i])&#123;</span><br><span class="line">                list.add(n+<span class="string">"-&gt;"</span>+nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                list.add(n+<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> start = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        builder.append(start);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]-nums[i-<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (count==<span class="number">1</span>) &#123;</span><br><span class="line">                    result.add(builder.toString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(builder.append(<span class="string">"-&gt;"</span>+nums[i-<span class="number">1</span>]).toString());</span><br><span class="line">                &#125;</span><br><span class="line">                builder = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>+nums[i]);</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count!=<span class="number">1</span>) result.add(builder.append(<span class="string">"-&gt;"</span>+nums[nums.length-<span class="number">1</span>]).toString());</span><br><span class="line">        <span class="keyword">else</span> result.add(builder.toString());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Summary_Ranges_-_区间归纳">Summary Ranges - 区间归纳</h3><p><strong>Description</strong>: Given a sorted integer array without duplicates, r]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Basic Calculator II - 基本计算器II]]></title>
    <link href="http://eugeneyang.com/2016/04/21/Basic%20Calculator%20II%20-%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8II/"/>
    <id>http://eugeneyang.com/2016/04/21/Basic Calculator II - 基本计算器II/</id>
    <published>2016-04-21T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.082Z</updated>
    <content type="html"><![CDATA[<h3 id="Basic_Calculator_II_-_基本计算器II">Basic Calculator II - 基本计算器II</h3><p><strong>Description</strong>: Implement a basic calculator to evaluate a simple expression string.<br> The expression string contains only non-negative integers, +, -, <em>, / operators and empty spaces . The integer division should truncate toward zero.<br> You may assume that the given expression is always valid.<br> Some examples:<br> “3+2</em>2” = 7<br> “ 3/2 “ = 1<br> “ 3+5 / 2 “ = 5</p>
<p>思路：遇到数字则读完数字,遇到符号或到了末尾则检视上一次符号lastSign:lastSign为’-‘’+’则相应压栈;lastSign为’*’’/‘则弹栈与当前数计算后压栈;此外更新lastSign,当前值清零.<br>最后,求栈中元素和返回.</p>
<p>参考链接：<a href="https://leetcode.com/discuss/41902/share-my-java-solution" target="_blank" rel="external">https://leetcode.com/discuss/41902/share-my-java-solution</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicCalculatorII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *https://leetcode.com/discuss/41902/share-my-java-solution</span><br><span class="line">     *遇到数字则读完数字,遇到符号或到了末尾则检视上一次符号lastSign:lastSign为'-''+'则相应压栈;</span><br><span class="line">     lastSign为'*''/'则弹栈与当前数计算后压栈;此外更新lastSign,当前值清零.</span><br><span class="line">     最后,求栈中元素和返回.</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;    <span class="comment">//初始值</span></span><br><span class="line">        <span class="keyword">char</span> lastSign = <span class="string">'+'</span>;    <span class="comment">//初始符号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(c)) num = num*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>((!Character.isDigit(c) &amp;&amp; <span class="string">' '</span>!=c) || i==len-<span class="number">1</span>)&#123;  <span class="comment">//TODO 注意到了末尾的情况</span></span><br><span class="line">                <span class="keyword">if</span>(lastSign==<span class="string">'-'</span>) stack.push(-num);</span><br><span class="line">                <span class="keyword">if</span>(lastSign==<span class="string">'+'</span>) stack.push(num);</span><br><span class="line">                <span class="keyword">if</span>(lastSign==<span class="string">'*'</span>) stack.push(stack.pop()*num);</span><br><span class="line">                <span class="keyword">if</span>(lastSign==<span class="string">'/'</span>) stack.push(stack.pop()/num);</span><br><span class="line">                lastSign = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: stack) res += i;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Basic_Calculator_II_-_基本计算器II">Basic Calculator II - 基本计算器II</h3><p><strong>Description</strong>: Implement a basic calculator to ev]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[String to Integer (atoi) - 字符串转化为整型]]></title>
    <link href="http://eugeneyang.com/2016/04/20/String%20to%20Integer%20(atoi)%20-%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E5%9E%8B/"/>
    <id>http://eugeneyang.com/2016/04/20/String to Integer (atoi) - 字符串转化为整型/</id>
    <published>2016-04-20T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.081Z</updated>
    <content type="html"><![CDATA[<h3 id="String_to_Integer_(atoi)_-_字符串转化为整型">String to Integer (atoi) - 字符串转化为整型</h3><p><strong>Description</strong>: Implement atoi to convert a string to an integer.<br> Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p>
<p>思路：此题用例极易出错,注意各种条件</p>
<p>参考链接：<a href="https://leetcode.com/discuss/32813/java-solution-with-4-steps-explanations" target="_blank" rel="external">https://leetcode.com/discuss/32813/java-solution-with-4-steps-explanations</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToInteger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**TODO 此题用例极易出错,注意各种条件</span><br><span class="line">     * https://leetcode.com/discuss/32813/java-solution-with-4-steps-explanations</span><br><span class="line">     * <span class="doctag">@param</span> str</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, sign = <span class="number">1</span>, total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//1. Remove Spaces</span></span><br><span class="line">        <span class="keyword">while</span>(str.charAt(i)==<span class="string">' '</span> &amp;&amp; i&lt;str.length()) i++;</span><br><span class="line">        <span class="comment">//2. Handle signs</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i)==<span class="string">'+'</span> || str.charAt(i)==<span class="string">'-'</span>)&#123;</span><br><span class="line">            sign = str.charAt(i)==<span class="string">'+'</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. Convert number and avoid overflow</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;str.length())&#123;</span><br><span class="line">            <span class="keyword">int</span> digit = str.charAt(i)-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(digit&lt;<span class="number">0</span> || digit&gt;<span class="number">9</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//check if total will be overflow after 10 times and add digit</span></span><br><span class="line">            <span class="keyword">if</span>(Integer.MAX_VALUE/<span class="number">10</span>&lt;total || Integer.MAX_VALUE/<span class="number">10</span>==total &amp;&amp; Integer.MAX_VALUE%<span class="number">10</span>&lt;digit)</span><br><span class="line">                <span class="keyword">return</span> sign==<span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            total = <span class="number">10</span>*total + digit;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total*sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="String_to_Integer_(atoi)_-_字符串转化为整型">String to Integer (atoi) - 字符串转化为整型</h3><p><strong>Description</strong>: Implement atoi to conv]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Implement Stack using Queues - 用队列实现栈]]></title>
    <link href="http://eugeneyang.com/2016/04/18/Implement%20Stack%20using%20Queues%20-%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>http://eugeneyang.com/2016/04/18/Implement Stack using Queues - 用队列实现栈/</id>
    <published>2016-04-18T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.079Z</updated>
    <content type="html"><![CDATA[<h3 id="Implement_Stack_using_Queues_-_用队列实现栈">Implement Stack using Queues - 用队列实现栈</h3><p><strong>Description</strong>: Implement the following operations of a stack using queues.<br> push(x) – Push element x onto stack.<br> pop() – Removes the element on top of the stack.<br> top() – Get the top element.<br> empty() – Return whether the stack is empty.</p>
<p>Notes:<br> You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid.<br> Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.<br> You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</p>
<p>思路：仅借助一个队列,但是push操作慢</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Integer&gt; q;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Push element x onto stack.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            q.offer(x);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;q.size()-<span class="number">1</span>; i++) q.offer(q.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Removes the element on top of the stack.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            q.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the top element.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> q.peek();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return whether the stack is empty.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> q.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Implement_Stack_using_Queues_-_用队列实现栈">Implement Stack using Queues - 用队列实现栈</h3><p><strong>Description</strong>: Implement the foll]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Basic Calculator - 基础计算器]]></title>
    <link href="http://eugeneyang.com/2016/04/17/Basic%20Calculator%20-%20%E5%9F%BA%E7%A1%80%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://eugeneyang.com/2016/04/17/Basic Calculator - 基础计算器/</id>
    <published>2016-04-17T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.077Z</updated>
    <content type="html"><![CDATA[<h3 id="Basic_Calculator_-_基础计算器">Basic Calculator - 基础计算器</h3><p><strong>Description</strong>: Implement a basic calculator to evaluate a simple expression string.<br> The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .<br> You may assume that the given expression is always valid.</p>
<p>Some examples:<br> “1 + 1” = 2<br> “ 2-1 + 2 “ = 3<br> “(1+(4+5+2)-3)+(6+8)” = 23</p>
<p>Note: Do not use the eval built-in library function.</p>
<p>思路：遇到”+”或”-“改变符号,遇到数字则读完数字并利用符号进行运算,遇到”(“压栈结果与符号并重置结果与符号,遇到”)”弹栈并计算结果.</p>
<p>参考链接：<a href="https://leetcode.com/discuss/39553/iterative-java-solution-with-stack" target="_blank" rel="external">https://leetcode.com/discuss/39553/iterative-java-solution-with-stack</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * https://leetcode.com/discuss/39553/iterative-java-solution-with-stack</span><br><span class="line">     * 遇到"+"或"-"改变符号,遇到数字则读完数字并利用符号进行运算,遇到"("压栈结果与符号并重置结果与符号,遇到")"弹栈并计算结果.</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>, result = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = s.charAt(i)-<span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">while</span> (i+<span class="number">1</span>&lt;s.length() &amp;&amp; Character.isDigit(s.charAt(i+<span class="number">1</span>))) &#123;</span><br><span class="line">                    sum = sum*<span class="number">10</span> + s.charAt(i+<span class="number">1</span>)-<span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                result += sum*sign;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'+'</span>)</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'-'</span>)</span><br><span class="line">                sign = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                stack.push(result);</span><br><span class="line">                stack.push(sign);</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">                result = result*stack.pop() + stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Basic_Calculator_-_基础计算器">Basic Calculator - 基础计算器</h3><p><strong>Description</strong>: Implement a basic calculator to evaluate a s]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Count Complete Tree Nodes - 完全二叉树节点数]]></title>
    <link href="http://eugeneyang.com/2016/04/16/Count%20Complete%20Tree%20Nodes%20-%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/04/16/Count Complete Tree Nodes - 完全二叉树节点数/</id>
    <published>2016-04-16T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.074Z</updated>
    <content type="html"><![CDATA[<h3 id="Count_Complete_Tree_Nodes_-_完全二叉树节点数">Count Complete Tree Nodes - 完全二叉树节点数</h3><p><strong>Description</strong>: Given a complete binary tree, count the number of nodes.</p>
<p>思路：一、满二叉树节点数=2^h-1，递归计算<br>二、借助队列一层一层遍历，超时</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/06/leetcode-count-complete-tree-nodes-java/" target="_blank" rel="external">http://www.programcreek.com/2014/06/leetcode-count-complete-tree-nodes-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountCompleteTreeNodes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2014/06/leetcode-count-complete-tree-nodes-java/</span><br><span class="line">     * 满二叉树节点数=2^h-1</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = leftDepth(root);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = rightDepth(root);</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;leftDepth)-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>+countNodes(root.left)+countNodes(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">            h++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">            h++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; qNext = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            TreeNode n = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (n.left!=<span class="keyword">null</span>) qNext.offer(n.left);</span><br><span class="line">            <span class="keyword">if</span> (n.right!=<span class="keyword">null</span>) qNext.offer(n.right);</span><br><span class="line">            <span class="keyword">if</span> (q.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">if</span> (!qNext.isEmpty())&#123;</span><br><span class="line">                    count += qNext.size();</span><br><span class="line">                    q = qNext;</span><br><span class="line">                    qNext = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Count_Complete_Tree_Nodes_-_完全二叉树节点数">Count Complete Tree Nodes - 完全二叉树节点数</h3><p><strong>Description</strong>: Given a complete bin]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maximal Square - 最大正方形]]></title>
    <link href="http://eugeneyang.com/2016/04/15/Maximal%20Square%20-%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <id>http://eugeneyang.com/2016/04/15/Maximal Square - 最大正方形/</id>
    <published>2016-04-15T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.072Z</updated>
    <content type="html"><![CDATA[<h3 id="Maximal_Square_-_最大正方形">Maximal Square - 最大正方形</h3><p><strong>Description</strong>: Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing all 1’s and return its area.</p>
<p>For example, given the following matrix:<br>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0<br>Return 4.</p>
<p>思路：假设dp[i][j]表示以i,j为右下角的正方形的最大边长，则有<br>     dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])+1<br>     若matrix[i][j]==1,dp[i][j]=0.</p>
<p>参考链接：<a href="https://segmentfault.com/a/1190000003709497" target="_blank" rel="external">https://segmentfault.com/a/1190000003709497</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximalSquare</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**https://segmentfault.com/a/1190000003709497</span><br><span class="line">     * 假设dp[i][j]表示以i,j为右下角的正方形的最大边长，则有</span><br><span class="line">     dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])+1</span><br><span class="line">     若matrix[i][j]==1,dp[i][j]=0.</span><br><span class="line">     * <span class="doctag">@param</span> matrix</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>]==<span class="string">'0'</span>) dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                max = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j]==<span class="string">'0'</span>) dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">                max = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j]==<span class="string">'0'</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> min = Math.min(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]);</span><br><span class="line">                    dp[i][j] = Math.min(min, dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (max&lt;dp[i][j]) max = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max*max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Maximal_Square_-_最大正方形">Maximal Square - 最大正方形</h3><p><strong>Description</strong>: Given a 2D binary matrix filled with 0’s and 1’s]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Contains Duplicate III - 重复元素III]]></title>
    <link href="http://eugeneyang.com/2016/04/14/Contains%20Duplicate%20III%20-%20%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III/"/>
    <id>http://eugeneyang.com/2016/04/14/Contains Duplicate III - 重复元素III/</id>
    <published>2016-04-14T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.070Z</updated>
    <content type="html"><![CDATA[<h3 id="Contains_Duplicate_III_-_重复元素III">Contains Duplicate III - 重复元素III</h3><p><strong>Description</strong>: Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.</p>
<p>思路：O(nlog(k)),借助TreeSet维护窗口k</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/06/leetcode-contains-duplicate-iii-java/" target="_blank" rel="external">http://www.programcreek.com/2014/06/leetcode-contains-duplicate-iii-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainsDuplicateIII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * O(nlog(k)),借助TreeSet维护窗口k</span><br><span class="line">     * http://www.programcreek.com/2014/06/leetcode-contains-duplicate-iii-java/</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@param</span> k</span><br><span class="line">     * <span class="doctag">@param</span> t</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = nums[i];</span><br><span class="line">            <span class="keyword">if</span> ((set.floor(c)!=<span class="keyword">null</span> &amp;&amp; c&lt;=set.floor(c)+t)</span><br><span class="line">                    || (set.ceiling(c)!=<span class="keyword">null</span> &amp;&amp; c&gt;=set.ceiling(c)-t))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            set.add(c);</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=k) set.remove(nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(此法超时)维护窗口k, 注意边界情况 [-1,2147483647] 1 2147483647</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span> || nums.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (nums.length-<span class="number">1</span>&lt;=k) len = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> len = k;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j=i+<span class="number">1</span>; j&lt;=len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i!=j &amp;&amp; Math.abs((<span class="keyword">long</span>)nums[j]-nums[i])&lt;=t) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length-<span class="number">1</span>&lt;=k) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=k+<span class="number">1</span>; i&lt;nums.length; i++)&#123;    <span class="comment">//窗口滚动</span></span><br><span class="line">            <span class="keyword">for</span> (j=i-k; j&lt;i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs((<span class="keyword">long</span>)nums[j]-nums[i])&lt;=t) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Contains_Duplicate_III_-_重复元素III">Contains Duplicate III - 重复元素III</h3><p><strong>Description</strong>: Given an array of integers, ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The Skyline Problem - 天际线问题]]></title>
    <link href="http://eugeneyang.com/2016/04/13/The%20Skyline%20Problem%20-%20%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98/"/>
    <id>http://eugeneyang.com/2016/04/13/The Skyline Problem - 天际线问题/</id>
    <published>2016-04-13T12:44:47.000Z</published>
    <updated>2016-05-06T09:07:16.068Z</updated>
    <content type="html"><![CDATA[<h3 id="The_Skyline_Problem_-_天际线问题">The Skyline Problem - 天际线问题</h3><p><strong>Description</strong>: A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).<br>A key point is the left endpoint of a horizontal line segment.</p>
<p>原题链接：<a href="https://leetcode.com/problems/the-skyline-problem/" target="_blank" rel="external">https://leetcode.com/problems/the-skyline-problem/</a></p>
<p>思路：借助大顶堆，时间O(NlogN) 空间O(N)。<br>1 把这些矩形拆成两个点，一个左上顶点，一个右上顶点。将所有顶点按照横坐标排序后，开始遍历这些点。<br>2 遍历时，通过一个大顶堆来得知当前图形的最高位置。堆顶是所有顶点中最高的点，只要这个点没被移出堆，说明这个最高的矩形还没结束。<br>3 对于左顶点，我们将其加入堆中。对于右顶点，我们找出堆中其相应的左顶点，然后移出这个左顶点，同时也意味这这个矩形的结束。<br>4 代码中，为了区分左右顶点，左顶点高度值是负数，而右顶点高度值则存的是正数。注意，堆中先加入一个0高度，帮助我们在只有最矮的建筑物时选择最低值</p>
<p>参考链接：<a href="https://segmentfault.com/a/1190000003786782" target="_blank" rel="external">https://segmentfault.com/a/1190000003786782</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheSkylineProblem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**时间O(NlogN) 空间O(N)</span><br><span class="line">     * https://segmentfault.com/a/1190000003786782</span><br><span class="line">     * 把这些矩形拆成两个点，一个左上顶点，一个右上顶点。将所有顶点按照横坐标排序后，开始遍历这些点。</span><br><span class="line">     遍历时，通过一个大顶堆来得知当前图形的最高位置。堆顶是所有顶点中最高的点，只要这个点没被移出堆，说明这个最高的矩形还没结束。</span><br><span class="line">     对于左顶点，我们将其加入堆中。对于右顶点，我们找出堆中其相应的左顶点，然后移出这个左顶点，同时也意味这这个矩形的结束。</span><br><span class="line">     代码中，为了区分左右顶点，左顶点高度值是负数，而右顶点高度值则存的是正数。</span><br><span class="line">     注意:堆中先加入一个0高度，帮助我们在只有最矮的建筑物时选择最低值</span><br><span class="line">     * <span class="doctag">@param</span> buildings</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; height = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] b:buildings) &#123;    <span class="comment">// 构建左右顶点混合列表</span></span><br><span class="line">            height.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;b[<span class="number">0</span>], -b[<span class="number">2</span>]&#125;); <span class="comment">// 左高度为负数</span></span><br><span class="line">            height.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;b[<span class="number">1</span>], b[<span class="number">2</span>]&#125;);  <span class="comment">// 右高度为正数</span></span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(height, (a, b) -&gt; &#123;    <span class="comment">// 按横坐标排序，相同横坐标其纵坐标小的在前</span></span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] != b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">11</span>, (i1,i2) -&gt; (i2-i1));    <span class="comment">// 构建大顶堆，按照纵坐标来判断大小</span></span><br><span class="line">        pq.offer(<span class="number">0</span>);    <span class="comment">// 将地平线值0先加入堆中</span></span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;   <span class="comment">// prev用于记录上次keypoint的高度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] h:height) &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[<span class="number">1</span>] &lt; <span class="number">0</span>) pq.offer(-h[<span class="number">1</span>]);   <span class="comment">// 将左顶点加入堆中</span></span><br><span class="line">            <span class="keyword">else</span> pq.remove(h[<span class="number">1</span>]);    <span class="comment">// 将右顶点对应的左顶点移去</span></span><br><span class="line">            <span class="keyword">int</span> cur = pq.peek();</span><br><span class="line">            <span class="keyword">if</span>(prev != cur) &#123;   <span class="comment">// 如果堆的新顶部和上个keypoint高度不一样，则加入一个新的keypoint</span></span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;h[<span class="number">0</span>], cur&#125;);</span><br><span class="line">                prev = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="The_Skyline_Problem_-_天际线问题">The Skyline Problem - 天际线问题</h3><p><strong>Description</strong>: A city’s skyline is the outer contour ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Combination Sum III - 组合和III]]></title>
    <link href="http://eugeneyang.com/2016/04/12/Combination%20Sum%20III%20-%20%E7%BB%84%E5%90%88%E5%92%8CIII/"/>
    <id>http://eugeneyang.com/2016/04/12/Combination Sum III - 组合和III/</id>
    <published>2016-04-12T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:15.041Z</updated>
    <content type="html"><![CDATA[<h3 id="Combination_Sum_III_-_组合和III">Combination Sum III - 组合和III</h3><p><strong>Description</strong>: Find all possible combinations of k numbers that add up to a number n, given that only numbers<br> from 1 to 9 can be used and each combination should be a unique set of numbers.<br> Ensure that numbers within the set are sorted in ascending order.</p>
<p> Example 1:<br> Input: k = 3, n = 7<br> Output: [[1,2,4]]<br> Example 2:<br> Input: k = 3, n = 9<br> Output: [[1,2,6], [1,3,5], [2,3,4]]</p>
<p>思路：回溯</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSumIII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(k, n, list, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> sum, List&lt;Integer&gt; list, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span> &amp;&amp; list.size()==k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=<span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum-i&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(list.size()&gt;=k) <span class="keyword">break</span>;</span><br><span class="line">            list.add(i);</span><br><span class="line">            dfs(k, sum-i, list, i+<span class="number">1</span>);   <span class="comment">//TODO 注意i+1不要写成start+1</span></span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Combination_Sum_III_-_组合和III">Combination Sum III - 组合和III</h3><p><strong>Description</strong>: Find all possible combinations of k ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Eugene's Blog]]></title>
  <subtitle><![CDATA[成长之旅]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://eugeneyang.com/"/>
  <updated>2016-04-12T03:04:15.041Z</updated>
  <id>http://eugeneyang.com/</id>
  
  <author>
    <name><![CDATA[Jian Yang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Combination Sum III - 组合和III]]></title>
    <link href="http://eugeneyang.com/2016/04/12/Combination%20Sum%20III%20-%20%E7%BB%84%E5%90%88%E5%92%8CIII/"/>
    <id>http://eugeneyang.com/2016/04/12/Combination Sum III - 组合和III/</id>
    <published>2016-04-12T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:15.041Z</updated>
    <content type="html"><![CDATA[<h3 id="Combination_Sum_III_-_组合和III">Combination Sum III - 组合和III</h3><p><strong>Description</strong>: Find all possible combinations of k numbers that add up to a number n, given that only numbers<br> from 1 to 9 can be used and each combination should be a unique set of numbers.<br> Ensure that numbers within the set are sorted in ascending order.</p>
<p> Example 1:<br> Input: k = 3, n = 7<br> Output: [[1,2,4]]<br> Example 2:<br> Input: k = 3, n = 9<br> Output: [[1,2,6], [1,3,5], [2,3,4]]</p>
<p>思路：回溯</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSumIII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(k, n, list, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> sum, List&lt;Integer&gt; list, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span> &amp;&amp; list.size()==k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=<span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum-i&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(list.size()&gt;=k) <span class="keyword">break</span>;</span><br><span class="line">            list.add(i);</span><br><span class="line">            dfs(k, sum-i, list, i+<span class="number">1</span>);   <span class="comment">//TODO 注意i+1不要写成start+1</span></span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Combination_Sum_III_-_组合和III">Combination Sum III - 组合和III</h3><p><strong>Description</strong>: Find all possible combinations of k ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kth Largest Element in an Array - 数组中第K大元素]]></title>
    <link href="http://eugeneyang.com/2016/04/11/Kth%20Largest%20Element%20in%20an%20Array%20-%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://eugeneyang.com/2016/04/11/Kth Largest Element in an Array - 数组中第K大元素/</id>
    <published>2016-04-11T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:15.037Z</updated>
    <content type="html"><![CDATA[<h3 id="Kth_Largest_Element_in_an_Array_-_数组中第K大元素">Kth Largest Element in an Array - 数组中第K大元素</h3><p><strong>Description</strong>: Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.<br> For example, Given [3,2,1,5,6,4] and k = 2, return 5.<br> Note:  You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<p>思路：采用快速排序的思想选择第K大元素</p>
<p>参考链接：<a href="https://leetcode.com/discuss/45627/ac-clean-quickselect-java-solution-avg-o-n-time" target="_blank" rel="external">https://leetcode.com/discuss/45627/ac-clean-quickselect-java-solution-avg-o-n-time</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthLargestElementInArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * https://leetcode.com/discuss/45627/ac-clean-quickselect-java-solution-avg-o-n-time</span><br><span class="line">     * O(n)</span><br><span class="line">     * <span class="doctag">@param</span> a</span><br><span class="line">     * <span class="doctag">@param</span> k</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">int</span> p = quickSelect(a, <span class="number">0</span>, n-<span class="number">1</span>, n-k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return the index of the kth smallest number</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// use quick sort's idea, put nums that are &lt;= pivot to the left, put nums that are  &gt; pivot to the right</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi, pivot = a[hi];</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i++]&gt;pivot) swap(a, --i, --j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, hi);</span><br><span class="line">        <span class="keyword">int</span> m = i-lo+<span class="number">1</span>; <span class="comment">// count the nums that are &lt;= pivot from lo</span></span><br><span class="line">        <span class="keyword">if</span> (m==k) <span class="keyword">return</span> i;   <span class="comment">// pivot is the one!</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m&gt;k) <span class="keyword">return</span> quickSelect(a, lo, i-<span class="number">1</span>, k);    <span class="comment">// pivot is too big, so it must be on the left</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(a, i+<span class="number">1</span>, hi, k-m);<span class="comment">// pivot is too small, so it must be on the right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Kth_Largest_Element_in_an_Array_-_数组中第K大元素">Kth Largest Element in an Array - 数组中第K大元素</h3><p><strong>Description</strong>: Find the]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shortest Palindrome - 最短回文]]></title>
    <link href="http://eugeneyang.com/2016/04/10/Shortest%20Palindrome%20-%20%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87/"/>
    <id>http://eugeneyang.com/2016/04/10/Shortest Palindrome - 最短回文/</id>
    <published>2016-04-10T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:15.035Z</updated>
    <content type="html"><![CDATA[<h3 id="Shortest_Palindrome_-_最短回文">Shortest Palindrome - 最短回文</h3><p><strong>Description</strong>: Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.<br> For example:<br> Given “aacecaaa”, return “aaacecaaa”.<br> Given “abcd”, return “dcbabcd”.</p>
<p>思路：一、普通方法，寻找从第一个字符起的最长回文串,再逆转剩余部分并拼接到字符串首部。此法速度慢，险些超时。<br>二、使用KMP思想，1.求字符串s的翻转s_rev<br>     2.将两个字符串进行拼接：{s}#{s_rev}<br>     3.找出新字符串中最长公共前缀后缀长度comLen</p>
<pre><code><span class="number">4</span>. s_rev.<span class="function"><span class="title">substring</span><span class="params">(<span class="number">0</span>, s.length()</span></span> - comLen)就是在原字符串头部插入的子串部分
</code></pre><p>参考链接：<a href="https://leetcode.com/discuss/61416/my-9-lines-three-pointers-java-solution-with-explanation" target="_blank" rel="external">https://leetcode.com/discuss/61416/my-9-lines-three-pointers-java-solution-with-explanation</a><br><a href="https://segmentfault.com/a/1190000003059361" target="_blank" rel="external">https://segmentfault.com/a/1190000003059361</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortestPalindrome</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 此解易理解,但3%接近超时</span><br><span class="line">     * https://leetcode.com/discuss/61416/my-9-lines-three-pointers-java-solution-with-explanation</span><br><span class="line">     * 寻找从第一个字符起的最长回文串,再逆转剩余部分并拼接到字符串首部</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, end = s.length()-<span class="number">1</span>, j = end;</span><br><span class="line">        <span class="keyword">char</span> chs[] = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chs[i] == chs[j]) &#123;</span><br><span class="line">                i++; j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">//重置</span></span><br><span class="line">                i = <span class="number">0</span>; end--; j = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s.substring(end+<span class="number">1</span>)).reverse().append(chs).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * https://segmentfault.com/a/1190000003059361</span><br><span class="line">     * 思路：1.求字符串s的翻转s_rev</span><br><span class="line">     2.将两个字符串进行拼接：&#123;s&#125;#&#123;s_rev&#125;</span><br><span class="line">     3.找出新字符串中最长公共前缀后缀长度comLen</span><br><span class="line">     4. s_rev.substring(0, s.length() - comLen)就是在原字符串头部插入的子串部分</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        <span class="keyword">return</span> builder.reverse().substring(<span class="number">0</span>, s.length() - getCommonLength(s)) + s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getCommonLength</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">        String rev = <span class="keyword">new</span> StringBuilder(str).reverse().toString();</span><br><span class="line">        builder.append(<span class="string">"#"</span>).append(rev);</span><br><span class="line">        <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[builder.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; p.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = p[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; builder.charAt(i) != builder.charAt(j)) j = p[j - <span class="number">1</span>];</span><br><span class="line">            p[i] = j == <span class="number">0</span> ? (builder.charAt(i) == builder.charAt(<span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>) : j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[p.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Shortest_Palindrome_-_最短回文">Shortest Palindrome - 最短回文</h3><p><strong>Description</strong>: Given a string S, you are allowed to con]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[House Robber II - 房屋偷窃II]]></title>
    <link href="http://eugeneyang.com/2016/04/09/House%20Robber%20II%20-%20%E6%88%BF%E5%B1%8B%E5%81%B7%E7%AA%83II/"/>
    <id>http://eugeneyang.com/2016/04/09/House Robber II - 房屋偷窃II/</id>
    <published>2016-04-09T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:15.032Z</updated>
    <content type="html"><![CDATA[<h3 id="House_Robber_II_-_房屋偷窃II">House Robber II - 房屋偷窃II</h3><p><strong>Description</strong>: Note: This is an extension of House Robber.<br> After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.<br> Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>思路：DP, s(i)=max{s(i-1), s(i-2)+nums(i)}<br>分两种情况,遍历数组两次,1.包含第一个,不含最后一个;2.包含最后一个,不含第一个.<br>注意边界条件易错。</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/05/leetcode-house-robber-ii-java/" target="_blank" rel="external">http://www.programcreek.com/2014/05/leetcode-house-robber-ii-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobberII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DP, s(i)=max&#123;s(i-1), s(i-2)+nums(i)&#125;</span></span><br><span class="line">    <span class="comment">//分两种情况,遍历数组两次,1.包含第一个,不含最后一个;2.包含最后一个,不含第一个.</span></span><br><span class="line">    <span class="comment">//http://www.programcreek.com/2014/05/leetcode-house-robber-ii-java/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (len==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (len==<span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">//剔除最后一个元素</span></span><br><span class="line">        s[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        s[<span class="number">1</span>] = Math.max(s[<span class="number">0</span>], nums[<span class="number">1</span>]); <span class="comment">//TODO 易错</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;len-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            s[i] = Math.max(s[i-<span class="number">1</span>], s[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = s[len-<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//剔除第一个元素</span></span><br><span class="line">        s[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        s[<span class="number">2</span>] = Math.max(s[<span class="number">1</span>], nums[<span class="number">2</span>]); <span class="comment">//TODO 易错</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;len; i++)&#123;</span><br><span class="line">            s[i] = Math.max(s[i-<span class="number">1</span>], s[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(temp, s[len-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="House_Robber_II_-_房屋偷窃II">House Robber II - 房屋偷窃II</h3><p><strong>Description</strong>: Note: This is an extension of House Robber.<]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Word Search II - 单词搜索II]]></title>
    <link href="http://eugeneyang.com/2016/04/08/Word%20Search%20II%20-%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II/"/>
    <id>http://eugeneyang.com/2016/04/08/Word Search II - 单词搜索II/</id>
    <published>2016-04-08T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:15.029Z</updated>
    <content type="html"><![CDATA[<h3 id="Word_Search_II_-_单词搜索II">Word Search II - 单词搜索II</h3><p><strong>Description</strong>: Given a 2D board and a list of words from the dictionary, find all words in the board.<br> Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p>For example,<br> Given words = [“oath”,”pea”,”eat”,”rain”] and board =<br> [<br> [‘o’,’a’,’a’,’n’],<br> [‘e’,’t’,’a’,’e’],<br> [‘i’,’h’,’k’,’r’],<br> [‘i’,’f’,’l’,’v’]<br> ]<br> Return [“eat”,”oath”].<br> Note: You may assume that all inputs are consist of lowercase letters a-z.</p>
<p>思路：若采用跟Word Search一样的思路,将超时. 回溯中引入Trie,当前候选字符串不在所有单词的前缀中时,剪枝.</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/06/leetcode-word-search-ii-java/" target="_blank" rel="external">http://www.programcreek.com/2014/06/leetcode-word-search-ii-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordSearchII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**http://www.programcreek.com/2014/06/leetcode-word-search-ii-java/</span><br><span class="line">     * 若采用跟Word Search一样的思路,将超时.</span><br><span class="line">     * 回溯中引入Trie,当前候选字符串不在所有单词的前缀中时,剪枝.</span><br><span class="line">     * <span class="doctag">@param</span> board</span><br><span class="line">     * <span class="doctag">@param</span> words</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();   <span class="comment">//防止重复的单词</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line">    Trie trie;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        trie = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span> (String word: words) trie.insert(word);</span><br><span class="line">        m = board.length;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">                dfs(board, visited, <span class="string">""</span>, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">boolean</span>[][] visited, String str, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=m||j&gt;=n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[i][j]) <span class="keyword">return</span>;</span><br><span class="line">        str = str+board[i][j];</span><br><span class="line">        <span class="keyword">if</span> (!trie.startsWith(str)) <span class="keyword">return</span>;  <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (trie.search(str)) result.add(str);</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        dfs(board, visited, str, i-<span class="number">1</span>, j);</span><br><span class="line">        dfs(board, visited, str, i+<span class="number">1</span>, j);</span><br><span class="line">        dfs(board, visited, str, i, j-<span class="number">1</span>);</span><br><span class="line">        dfs(board, visited, str, i, j+<span class="number">1</span>);</span><br><span class="line">        visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组实现Trie</span></span><br><span class="line"><span class="comment">//Trie Node</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">public</span> String item = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Trie</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: word.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.children[c-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                node.children[c-<span class="string">'a'</span>]= <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.item = word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: word.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.children[c-<span class="string">'a'</span>]==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            node = node.children[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.item.equals(word))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: prefix.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.children[c-<span class="string">'a'</span>]==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            node = node.children[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Word_Search_II_-_单词搜索II">Word Search II - 单词搜索II</h3><p><strong>Description</strong>: Given a 2D board and a list of words from the ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Add and Search Word - Data structure design - 添加与查找单词数据结构设计]]></title>
    <link href="http://eugeneyang.com/2016/04/07/Add%20and%20Search%20Word%20-%20Data%20structure%20design%20-%20%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%9F%A5%E6%89%BE%E5%8D%95%E8%AF%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://eugeneyang.com/2016/04/07/Add and Search Word - Data structure design - 添加与查找单词数据结构设计/</id>
    <published>2016-04-07T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:15.026Z</updated>
    <content type="html"><![CDATA[<h3 id="Add_and_Search_Word_-_Data_structure_design_-_添加与查找单词数据结构设计">Add and Search Word - Data structure design - 添加与查找单词数据结构设计</h3><p><strong>Description</strong>: Design a data structure that supports the following two operations:<br> void addWord(word)<br> bool search(word)<br> search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.</p>
<p> For example:<br> addWord(“bad”)<br> addWord(“dad”)<br> addWord(“mad”)<br> search(“pad”) -&gt; false<br> search(“bad”) -&gt; true<br> search(“.ad”) -&gt; true<br> search(“b..”) -&gt; true<br> Note:<br> You may assume that all words are consist of lowercase letters a-z.</p>
<p>思路：采用Implement Trie (Prefix Tree) 中的数据结构，搜索单词时使用回溯。回溯中注意返回条件，否则可能超时。</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/05/leetcode-add-and-search-word-data-structure-design-java/" target="_blank" rel="external">http://www.programcreek.com/2014/05/leetcode-add-and-search-word-data-structure-design-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddAndSearchWordDesign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http://www.programcreek.com/2014/05/leetcode-add-and-search-word-data-structure-design-java/</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        HashMap&lt;Character, TrieNode&gt; children = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> isLeaf;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.c = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line">    <span class="comment">// WordDictionary wordDictionary = new WordDictionary();</span></span><br><span class="line">    <span class="comment">// wordDictionary.addWord("word");</span></span><br><span class="line">    <span class="comment">// wordDictionary.search("pattern");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WordDictionary</span><span class="params">()</span></span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Adds a word into the data structure.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            HashMap&lt;Character, TrieNode&gt; children = root.children;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.length(); i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (children.containsKey(c))&#123;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    TrieNode node = <span class="keyword">new</span> TrieNode(c);</span><br><span class="line">                    children.put(c, node);</span><br><span class="line">                    <span class="keyword">if</span> (i==word.length()-<span class="number">1</span>) node.isLeaf = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                children = children.get(c).children;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Returns if the word is in the data structure. A word could</span></span><br><span class="line">        <span class="comment">// contain the dot character '.' to represent any one letter.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dfsSearch(root.children, word, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfsSearch</span><span class="params">(HashMap&lt;Character, TrieNode&gt; children, String word, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (start==word.length())&#123;</span><br><span class="line">                <span class="keyword">if</span> (children.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(start);</span><br><span class="line">            <span class="keyword">if</span> (children.containsKey(c))&#123;</span><br><span class="line">                <span class="keyword">if</span> (start==word.length()-<span class="number">1</span> &amp;&amp; children.get(c).isLeaf) <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//TODO 不加此条将超时</span></span><br><span class="line">                <span class="keyword">return</span> dfsSearch(children.get(c).children, word, start+<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;Character, TrieNode&gt; child : children.entrySet())&#123;</span><br><span class="line">                    <span class="keyword">if</span> (start==word.length()-<span class="number">1</span> &amp;&amp; child.getValue().isLeaf) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//TODO 不能漏</span></span><br><span class="line">                    <span class="keyword">if</span> (dfsSearch(child.getValue().children, word, start+<span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//发现一条路径是可行的则返回true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Add_and_Search_Word_-_Data_structure_design_-_添加与查找单词数据结构设计">Add and Search Word - Data structure design - 添加与查找单词数据结构设计</h3><p><str]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Course Schedule II - 课程调度II]]></title>
    <link href="http://eugeneyang.com/2016/04/06/Course%20Schedule%20II%20-%20%E8%AF%BE%E7%A8%8B%E8%B0%83%E5%BA%A6II/"/>
    <id>http://eugeneyang.com/2016/04/06/Course Schedule II - 课程调度II/</id>
    <published>2016-04-06T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:15.023Z</updated>
    <content type="html"><![CDATA[<h3 id="Course_Schedule_II_-_课程调度II">Course Schedule II - 课程调度II</h3><p><strong>Description</strong>:<br>There are a total of n courses you have to take, labeled from 0 to n - 1.<br>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]<br>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.<br>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>For example:<br>2, [[1,0]]<br>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]<br>4, [[1,0],[2,0],[3,1],[3,2]]<br>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</p>
<p>思路：Course Schedule I思路一致，有向图BFS(边列表):队列存没有依赖的节点</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseSchedule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2014/05/leetcode-course-schedule-java/</span><br><span class="line">     * 有向图BFS(边列表):队列存没有依赖的节点</span><br><span class="line">     * <span class="doctag">@param</span> numCourses</span><br><span class="line">     * <span class="doctag">@param</span> prerequisites</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prerequisites.length;</span><br><span class="line">        <span class="keyword">if</span>(numCourses==<span class="number">0</span> || len==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// counter for number of prerequisites</span></span><br><span class="line">        <span class="keyword">int</span>[] pCount = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) pCount[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">        <span class="comment">//store courses that have no prerequisites</span></span><br><span class="line">        LinkedList&lt;Integer&gt; queueNoPre = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pCount[i]==<span class="number">0</span>) queueNoPre.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// number of courses that have no prerequisites</span></span><br><span class="line">        <span class="keyword">int</span> numNoPre = queueNoPre.size();</span><br><span class="line">        <span class="keyword">while</span>(!queueNoPre.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> top = queueNoPre.remove();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                <span class="comment">// if a course's prerequisite can be satisfied by a course in queue</span></span><br><span class="line">                <span class="keyword">if</span>(prerequisites[i][<span class="number">1</span>]==top)&#123;</span><br><span class="line">                    pCount[prerequisites[i][<span class="number">0</span>]]--;  <span class="comment">//依赖减一</span></span><br><span class="line">                    <span class="keyword">if</span>(pCount[prerequisites[i][<span class="number">0</span>]]==<span class="number">0</span>)&#123; <span class="comment">//若依赖清零了</span></span><br><span class="line">                        numNoPre++;</span><br><span class="line">                        queueNoPre.add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numNoPre == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Course_Schedule_II_-_课程调度II">Course Schedule II - 课程调度II</h3><p><strong>Description</strong>:<br>There are a total of n courses you ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Minimum Size Subarray Sum - 最小子串和]]></title>
    <link href="http://eugeneyang.com/2016/04/05/Minimum%20Size%20Subarray%20Sum%20-%20%E6%9C%80%E5%B0%8F%E5%AD%90%E4%B8%B2%E5%92%8C/"/>
    <id>http://eugeneyang.com/2016/04/05/Minimum Size Subarray Sum - 最小子串和/</id>
    <published>2016-04-05T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:15.008Z</updated>
    <content type="html"><![CDATA[<h3 id="Minimum_Size_Subarray_Sum_-_最小子串和">Minimum Size Subarray Sum - 最小子串和</h3><p><strong>Description</strong>: Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p>
<p>For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint.</p>
<p>思路：滑动窗口法:双指针,当sum&gt;=s,移动左指针;当sum&lt;s,移动右指针.</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/05/leetcode-minimum-size-subarray-sum-java/" target="_blank" rel="external">http://www.programcreek.com/2014/05/leetcode-minimum-size-subarray-sum-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumSizeSubarraySum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 滑动窗口法:双指针,当sum&gt;=s,移动左指针;当sum&lt;s,移动右指针.</span><br><span class="line">     * http://www.programcreek.com/2014/05/leetcode-minimum-size-subarray-sum-java/</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = nums.length;</span><br><span class="line">        <span class="keyword">int</span> winSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (j&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i==j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i]&gt;=s) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">if</span> (j&lt;nums.length) winSum += nums[j];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> minLen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (winSum&gt;=s) &#123;</span><br><span class="line">                    minLen = Math.min(minLen, j-i+<span class="number">1</span>);</span><br><span class="line">                    winSum -= nums[i];</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">if</span> (j&lt;nums.length) winSum += nums[j];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> i==<span class="number">0</span> ? <span class="number">0</span> : minLen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Minimum_Size_Subarray_Sum_-_最小子串和">Minimum Size Subarray Sum - 最小子串和</h3><p><strong>Description</strong>: Given an array of n positi]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Implement Trie (Prefix Tree) - Trie树(前缀树)实现]]></title>
    <link href="http://eugeneyang.com/2016/04/04/Implement%20Trie%20(Prefix%20Tree)%20-%20Trie%E6%A0%91(%E5%89%8D%E7%BC%80%E6%A0%91)%E5%AE%9E%E7%8E%B0/"/>
    <id>http://eugeneyang.com/2016/04/04/Implement Trie (Prefix Tree) - Trie树(前缀树)实现/</id>
    <published>2016-04-04T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:15.006Z</updated>
    <content type="html"><![CDATA[<h3 id="Implement_Trie_(Prefix_Tree)_-_Trie树(前缀树)实现">Implement Trie (Prefix Tree) - Trie树(前缀树)实现</h3><p><strong>Description</strong>: Implement a trie with insert, search, and startsWith methods.<br> Note: You may assume that all inputs are consist of lowercase letters a-z.</p>
<p>参考链接：数据结构参考 <a href="http://www.programcreek.com/2014/05/leetcode-implement-trie-prefix-tree-java/" target="_blank" rel="external">http://www.programcreek.com/2014/05/leetcode-implement-trie-prefix-tree-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplementTriePrefixTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据结构参考 http://www.programcreek.com/2014/05/leetcode-implement-trie-prefix-tree-java/</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        HashMap&lt;Character, TrieNode&gt; children = <span class="keyword">new</span> HashMap&lt;Character, TrieNode&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> isLeaf;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.c = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your Trie object will be instantiated and called as such:</span></span><br><span class="line">    <span class="comment">// Trie trie = new Trie();</span></span><br><span class="line">    <span class="comment">// trie.insert("somestring");</span></span><br><span class="line">    <span class="comment">// trie.search("key");</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            HashMap&lt;Character, TrieNode&gt; children = root.children;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word.length(); i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">                TrieNode t;</span><br><span class="line">                <span class="keyword">if</span>(children.containsKey(c))&#123;</span><br><span class="line">                    t = children.get(c);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    t = <span class="keyword">new</span> TrieNode(c);</span><br><span class="line">                    children.put(c, t);</span><br><span class="line">                &#125;</span><br><span class="line">                children = t.children;</span><br><span class="line">                <span class="comment">//set leaf node</span></span><br><span class="line">                <span class="keyword">if</span>(i==word.length()-<span class="number">1</span>) t.isLeaf = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            TrieNode  t = searchNode(word);</span><br><span class="line">            <span class="keyword">if</span> (t!=<span class="keyword">null</span> &amp;&amp; t.isLeaf) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">        <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(searchNode(prefix) == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> TrieNode <span class="title">searchNode</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">            HashMap&lt;Character, TrieNode&gt; children = root.children;</span><br><span class="line">            TrieNode t = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">                <span class="keyword">if</span>(children.containsKey(c))&#123;</span><br><span class="line">                    t = children.get(c);</span><br><span class="line">                    children = t.children;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Implement_Trie_(Prefix_Tree)_-_Trie树(前缀树)实现">Implement Trie (Prefix Tree) - Trie树(前缀树)实现</h3><p><strong>Description</strong>: Implem]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Course Schedule - 课程调度]]></title>
    <link href="http://eugeneyang.com/2016/04/03/Course%20Schedule%20-%20%E8%AF%BE%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>http://eugeneyang.com/2016/04/03/Course Schedule - 课程调度/</id>
    <published>2016-04-03T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:15.004Z</updated>
    <content type="html"><![CDATA[<h3 id="Course_Schedule_-_课程调度">Course Schedule - 课程调度</h3><p><strong>Description</strong>: There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p> For example:2, [[1,0]]<br> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.<br> 2, [[1,0],[0,1]]</p>
<p> Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices.</p>
<p>思路：有向图BFS(边列表):队列存没有依赖的节点</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/05/leetcode-course-schedule-java/" target="_blank" rel="external">http://www.programcreek.com/2014/05/leetcode-course-schedule-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseSchedule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2014/05/leetcode-course-schedule-java/</span><br><span class="line">     * 有向图BFS(边列表):队列存没有依赖的节点</span><br><span class="line">     * <span class="doctag">@param</span> numCourses</span><br><span class="line">     * <span class="doctag">@param</span> prerequisites</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prerequisites.length;</span><br><span class="line">        <span class="keyword">if</span>(numCourses==<span class="number">0</span> || len==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// counter for number of prerequisites</span></span><br><span class="line">        <span class="keyword">int</span>[] pCount = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) pCount[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">        <span class="comment">//store courses that have no prerequisites</span></span><br><span class="line">        LinkedList&lt;Integer&gt; queueNoPre = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pCount[i]==<span class="number">0</span>) queueNoPre.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// number of courses that have no prerequisites</span></span><br><span class="line">        <span class="keyword">int</span> numNoPre = queueNoPre.size();</span><br><span class="line">        <span class="keyword">while</span>(!queueNoPre.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> top = queueNoPre.remove();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                <span class="comment">// if a course's prerequisite can be satisfied by a course in queue</span></span><br><span class="line">                <span class="keyword">if</span>(prerequisites[i][<span class="number">1</span>]==top)&#123;</span><br><span class="line">                    pCount[prerequisites[i][<span class="number">0</span>]]--;  <span class="comment">//依赖减一</span></span><br><span class="line">                    <span class="keyword">if</span>(pCount[prerequisites[i][<span class="number">0</span>]]==<span class="number">0</span>)&#123; <span class="comment">//若依赖清零了</span></span><br><span class="line">                        numNoPre++;</span><br><span class="line">                        queueNoPre.add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numNoPre == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Course_Schedule_-_课程调度">Course Schedule - 课程调度</h3><p><strong>Description</strong>: There are a total of n courses you have to take,]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ZigZag Conversion - Z字形转换]]></title>
    <link href="http://eugeneyang.com/2016/04/02/ZigZag%20Conversion%20-%20Z%E5%AD%97%E5%BD%A2%E8%BD%AC%E6%8D%A2/"/>
    <id>http://eugeneyang.com/2016/04/02/ZigZag Conversion - Z字形转换/</id>
    <published>2016-04-02T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:15.002Z</updated>
    <content type="html"><![CDATA[<h3 id="ZigZag_Conversion_-_Z字形转换">ZigZag Conversion - Z字形转换</h3><p><strong>Description</strong>: The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<p>原题链接：<a href="https://www.google.com/search?q=ZigZag+Conversion&amp;oq=ZigZag+Conversion&amp;aqs=chrome..69i57j0l5.461j0j1&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="external">https://www.google.com/search?q=ZigZag+Conversion&amp;oq=ZigZag+Conversion&amp;aqs=chrome..69i57j0l5.461j0j1&amp;sourceid=chrome&amp;ie=UTF-8</a></p>
<p>思路：找到数组映射规律。</p>
<p>参考链接：<a href="http://www.cnblogs.com/springfor/p/3889414.html" target="_blank" rel="external">http://www.cnblogs.com/springfor/p/3889414.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZigZagConversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.cnblogs.com/springfor/p/3889414.html</span><br><span class="line">     * 数学规律题(不大可能出现)</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@param</span> nRows</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> nRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span> || nRows&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(nRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">2</span>*nRows-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nRows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();j+=size)&#123;</span><br><span class="line">                res.append(s.charAt(j));</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; i!=nRows-<span class="number">1</span>)&#123;<span class="comment">//except the first row and the last row</span></span><br><span class="line">                    <span class="keyword">int</span> temp = j+size-<span class="number">2</span>*i;</span><br><span class="line">                    <span class="keyword">if</span>(temp&lt;s.length()) res.append(s.charAt(temp));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="ZigZag_Conversion_-_Z字形转换">ZigZag Conversion - Z字形转换</h3><p><strong>Description</strong>: The string “PAYPALISHIRING” is written in ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Reverse Linked List - 逆转链表]]></title>
    <link href="http://eugeneyang.com/2016/04/02/Reverse%20Linked%20List%20-%20%E9%80%86%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://eugeneyang.com/2016/04/02/Reverse Linked List - 逆转链表/</id>
    <published>2016-04-02T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:14.986Z</updated>
    <content type="html"><![CDATA[<h3 id="Reverse_Linked_List_-_逆转链表">Reverse Linked List - 逆转链表</h3><p><strong>Description</strong>: Reverse a singly linked list.<br> Hint: A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<p>思路：递归或迭代。<br>迭代示意图：<a href="http://www.programcreek.com/2013/12/in-place-reorder-a-singly-linked-list-in-java/" target="_blank" rel="external">http://www.programcreek.com/2013/12/in-place-reorder-a-singly-linked-list-in-java/</a><br>递归参考链接：<a href="http://www.programcreek.com/2014/05/leetcode-reverse-linked-list-java/" target="_blank" rel="external">http://www.programcreek.com/2014/05/leetcode-reverse-linked-list-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Definition for singly-linked list.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode second = head.next;    <span class="comment">//pin the second node</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;   <span class="comment">//TODO set first's next to be null</span></span><br><span class="line">        ListNode rest = reverseList(second);</span><br><span class="line">        second.next = head;</span><br><span class="line">        <span class="keyword">return</span> rest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre = head, curr = head.next;</span><br><span class="line">        <span class="keyword">while</span> (curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = curr.next;</span><br><span class="line">            curr.next = pre;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="keyword">null</span>;   <span class="comment">//TODO 易漏</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Reverse_Linked_List_-_逆转链表">Reverse Linked List - 逆转链表</h3><p><strong>Description</strong>: Reverse a singly linked list.<br> Hint: ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Longest Palindromic Substring - 最长回文子串]]></title>
    <link href="http://eugeneyang.com/2016/04/02/Longest%20Palindromic%20Substring%20-%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://eugeneyang.com/2016/04/02/Longest Palindromic Substring - 最长回文子串/</id>
    <published>2016-04-02T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:14.984Z</updated>
    <content type="html"><![CDATA[<h3 id="Longest_Palindromic_Substring_-_最长回文子串">Longest Palindromic Substring - 最长回文子串</h3><p><strong>Description</strong>: Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>
<p>思路：一、DP，但长字符串用例超时；<br>二、中心扩展法。</p>
<p>参考链接：<a href="http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/" target="_blank" rel="external">http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestPalindromicSubstring</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/</span><br><span class="line">     * Time O(n^2), Space O(1)</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        String longest = s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">            String tmp = helper(s, i, i);</span><br><span class="line">            <span class="keyword">if</span> (tmp.length() &gt; longest.length()) longest = tmp;</span><br><span class="line">            tmp = helper(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (tmp.length() &gt; longest.length()) longest = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get longest palindrome with center of (begin,end)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (begin&gt;=<span class="number">0</span> &amp;&amp; end&lt;=s.length()-<span class="number">1</span> &amp;&amp; s.charAt(begin)==s.charAt(end)) &#123;</span><br><span class="line">            begin--;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**TODO 此法对于全是同一个字符的长字符串用例超时</span><br><span class="line">     * http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/</span><br><span class="line">     * Time O(n^2) Space O(n^2)</span><br><span class="line">     * DP: dp[i,j] = 1 if dp[i+1,j-1]==1 &amp;&amp; s[i]==s[j]</span><br><span class="line">     初始条件有: dp[i,i] = 1</span><br><span class="line">     dp[i,i+1] = 1 if s[i]==s[i+1]</span><br><span class="line">     TODO 注意there exists one unique longest palindromic substring</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        String longestStr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;len)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i)==s.charAt(i+<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    longestStr = s.substring(i, i+<span class="number">2</span>);</span><br><span class="line">                    maxLen = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">3</span>; l&lt;=len; l++)&#123; <span class="comment">//最外层要从长度l开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=len-l; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i+l-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (j&lt;len)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i+<span class="number">1</span>][j-<span class="number">1</span>]==<span class="number">1</span> &amp;&amp; s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (l&gt;maxLen) &#123;</span><br><span class="line">                            longestStr = s.substring(i, j+<span class="number">1</span>);</span><br><span class="line">                            maxLen = l;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Longest_Palindromic_Substring_-_最长回文子串">Longest Palindromic Substring - 最长回文子串</h3><p><strong>Description</strong>: Given a string S]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Count Primes - 计算质数个数]]></title>
    <link href="http://eugeneyang.com/2016/04/01/Count%20Primes%20-%20%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/04/01/Count Primes - 计算质数个数/</id>
    <published>2016-04-01T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:14.978Z</updated>
    <content type="html"><![CDATA[<h3 id="Count_Primes_-_计算质数个数">Count Primes - 计算质数个数</h3><p><strong>Description</strong>: Count the number of prime numbers less than a non-negative number, n.</p>
<p>原题链接：<a href="https://leetcode.com/problems/count-primes/" target="_blank" rel="external">https://leetcode.com/problems/count-primes/</a></p>
<p>思路：The Sieve of Eratosthenes uses an extra O(n) memory and<br>     its runtime complexity is O(n log log n). if the current number is p, we can always mark off multiples of p starting at p2, then in increments of p: p2 + p, p2 + 2p, … the terminating loop condition can be p &lt; √n, When the loop terminates, all the numbers in the table that are non-marked are prime.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountPrimes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**https://leetcode.com/problems/count-primes/</span><br><span class="line">     * The Sieve of Eratosthenes uses an extra O(n) memory and</span><br><span class="line">     its runtime complexity is O(n log log n).</span><br><span class="line">     * if the current number is p, we can always mark off multiples of p</span><br><span class="line">     starting at p2, then in increments of p: p2 + p, p2 + 2p, ...</span><br><span class="line">     the terminating loop condition can be p &lt; √n,</span><br><span class="line">     When the loop terminates, all the numbers in the table that are non-marked are prime.</span><br><span class="line">     * <span class="doctag">@param</span> n</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n; i++) isPrime[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i*i&lt;n; i++) &#123; <span class="comment">//TODO i*i&lt;n is cheaper than i&lt;sqrt(n)</span></span><br><span class="line">            <span class="keyword">if</span> (!isPrime[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i*i; j&lt;n; j+=i) isPrime[j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n; i++) <span class="keyword">if</span> (isPrime[i]) count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Count_Primes_-_计算质数个数">Count Primes - 计算质数个数</h3><p><strong>Description</strong>: Count the number of prime numbers less than a non-]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Happy Number - 快乐数]]></title>
    <link href="http://eugeneyang.com/2016/04/01/Happy%20Number%20-%20%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/04/01/Happy Number - 快乐数/</id>
    <published>2016-04-01T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:14.981Z</updated>
    <content type="html"><![CDATA[<h3 id="Happy_Number_-_快乐数">Happy Number - 快乐数</h3><p><strong>Description</strong>: Write an algorithm to determine if a number is “happy”.<br>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>原题链接：<a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="external">https://leetcode.com/problems/happy-number/</a></p>
<p>思路：跳出循环的关键在于记录出现过的数。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HappyNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> HappyNumber().isHappy(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳出循环的关键在于记录出现过的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!set.contains(n)) &#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            n = compute(n);</span><br><span class="line">            <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = String.valueOf(n).toCharArray();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = Integer.valueOf(c-<span class="string">'0'</span>); <span class="comment">//TODO Integer.valueOf(c)将得到ASCII值</span></span><br><span class="line">            sum += i*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Happy_Number_-_快乐数">Happy Number - 快乐数</h3><p><strong>Description</strong>: Write an algorithm to determine if a number is “happy”.<]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Bitwise AND of Numbers Range - 整数区间按位与]]></title>
    <link href="http://eugeneyang.com/2016/03/31/Bitwise%20AND%20of%20Numbers%20Range%20-%20%E6%95%B4%E6%95%B0%E5%8C%BA%E9%97%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/"/>
    <id>http://eugeneyang.com/2016/03/31/Bitwise AND of Numbers Range - 整数区间按位与/</id>
    <published>2016-03-31T12:44:47.000Z</published>
    <updated>2016-04-12T03:04:14.952Z</updated>
    <content type="html"><![CDATA[<h3 id="Bitwise_AND_of_Numbers_Range_-_整数区间按位与">Bitwise AND of Numbers Range - 整数区间按位与</h3><p><strong>Description</strong>: Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.<br> For example, given the range [5, 7], you should return 4.</p>
<p>思路：依次将n最靠右的1置零,直到小于等于m。<br>普通的将每个数按位操作会超时。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitwiseANDOfNumbersRange</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http://www.programcreek.com/2014/04/leetcode-bitwise-and-of-numbers-range-java/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (n&gt;m) n &amp;= n-<span class="number">1</span>;   <span class="comment">//依次将n最靠右的1置零,直到小于等于m</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd1</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=m+<span class="number">1</span>; i&lt;=n; i++) res &amp;= i;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Bitwise_AND_of_Numbers_Range_-_整数区间按位与">Bitwise AND of Numbers Range - 整数区间按位与</h3><p><strong>Description</strong>: Given a range [m]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Number of Islands - 小岛个数]]></title>
    <link href="http://eugeneyang.com/2016/03/30/Number%20of%20Islands%20-%20%E5%B0%8F%E5%B2%9B%E4%B8%AA%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/03/30/Number of Islands - 小岛个数/</id>
    <published>2016-03-30T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:40.011Z</updated>
    <content type="html"><![CDATA[<h3 id="Number_of_Islands_-_小岛个数">Number of Islands - 小岛个数</h3><p><strong>Description</strong>: Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>原题链接：<a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="external">https://leetcode.com/problems/number-of-islands/</a></p>
<p>思路：遍历数组，搜到小岛则按上下左右扩展进行递归搜索，搜过的点标记为’2’。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOfIslands</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="string">'2'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j]==<span class="string">'1'</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    findAnIsland(grid, i, j);</span><br><span class="line">                &#125; <span class="keyword">else</span> grid[i][j] = <span class="string">'2'</span>; <span class="comment">//searched</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findAnIsland</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y]!=<span class="string">'1'</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[x][y] = <span class="string">'2'</span>; <span class="comment">//searched</span></span><br><span class="line">        <span class="keyword">if</span> (x-<span class="number">1</span>&gt;=<span class="number">0</span>) findAnIsland(grid, x-<span class="number">1</span>, y);    <span class="comment">//上</span></span><br><span class="line">        <span class="keyword">if</span> (x+<span class="number">1</span>&lt;grid.length) findAnIsland(grid, x+<span class="number">1</span>, y);    <span class="comment">//下</span></span><br><span class="line">        <span class="keyword">if</span> (y-<span class="number">1</span>&gt;=<span class="number">0</span>) findAnIsland(grid, x, y-<span class="number">1</span>); <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (y+<span class="number">1</span>&lt;grid[<span class="number">0</span>].length) findAnIsland(grid, x, y+<span class="number">1</span>); <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Number_of_Islands_-_小岛个数">Number of Islands - 小岛个数</h3><p><strong>Description</strong>: Given a 2d grid map of ‘1’s (land) and ‘0’s ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binary Tree Right Side View - 二叉树右视图]]></title>
    <link href="http://eugeneyang.com/2016/03/29/Binary%20Tree%20Right%20Side%20View%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>http://eugeneyang.com/2016/03/29/Binary Tree Right Side View - 二叉树右视图/</id>
    <published>2016-03-29T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:40.009Z</updated>
    <content type="html"><![CDATA[<h3 id="Binary_Tree_Right_Side_View_-_二叉树右视图">Binary Tree Right Side View - 二叉树右视图</h3><p><strong>Description</strong>: Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p>原题链接：<a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank" rel="external">https://leetcode.com/problems/binary-tree-right-side-view/</a></p>
<p>思路：层次遍历取最后一个元素。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeRightSideView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; qNext = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            TreeNode n = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (n.left!=<span class="keyword">null</span>) qNext.offer(n.left);</span><br><span class="line">            <span class="keyword">if</span> (n.right!=<span class="keyword">null</span>) qNext.offer(n.right);</span><br><span class="line">            <span class="keyword">if</span> (q.isEmpty())&#123;</span><br><span class="line">                result.add(n.val);</span><br><span class="line">                <span class="keyword">if</span> (!qNext.isEmpty())&#123;</span><br><span class="line">                    q = <span class="keyword">new</span> LinkedList&lt;&gt;(qNext);</span><br><span class="line">                    qNext = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Binary_Tree_Right_Side_View_-_二叉树右视图">Binary Tree Right Side View - 二叉树右视图</h3><p><strong>Description</strong>: Given a binary tree,]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[House Robber - 房屋偷窃]]></title>
    <link href="http://eugeneyang.com/2016/03/28/House%20Robber%20-%20%E6%88%BF%E5%B1%8B%E5%81%B7%E7%AA%83/"/>
    <id>http://eugeneyang.com/2016/03/28/House Robber - 房屋偷窃/</id>
    <published>2016-03-28T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:40.005Z</updated>
    <content type="html"><![CDATA[<h3 id="House_Robber_-_房屋偷窃">House Robber - 房屋偷窃</h3><p><strong>Description</strong>: You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.<br> Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>思路：DP, s(i)=max{s(i-1), s(i-2)+nums(i)}</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobber</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//DP, s(i)=max&#123;s(i-1), s(i-2)+nums(i)&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        s[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        s[<span class="number">1</span>] = Math.max(s[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">2</span>) <span class="keyword">return</span> s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            s[i] = Math.max(s[i-<span class="number">1</span>], s[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="House_Robber_-_房屋偷窃">House Robber - 房屋偷窃</h3><p><strong>Description</strong>: You are a professional robber planning to rob houses a]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Number of 1 Bits - 1位的个数]]></title>
    <link href="http://eugeneyang.com/2016/03/28/Number%20of%201%20Bits%20-%201%E4%BD%8D%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/03/28/Number of 1 Bits - 1位的个数/</id>
    <published>2016-03-28T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:40.007Z</updated>
    <content type="html"><![CDATA[<h3 id="Number_of_1_Bits_-_1位的个数">Number of 1 Bits - 1位的个数</h3><p><strong>Description</strong>: Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).<br> For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOf1Bits</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (((n&gt;&gt;i)&amp;<span class="number">1</span>)==<span class="number">1</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Number_of_1_Bits_-_1位的个数">Number of 1 Bits - 1位的个数</h3><p><strong>Description</strong>: Write a function that takes an unsigned inte]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Eugene's Blog]]></title>
  <subtitle><![CDATA[成长之旅]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://eugeneyang.com/"/>
  <updated>2016-03-15T12:28:06.919Z</updated>
  <id>http://eugeneyang.com/</id>
  
  <author>
    <name><![CDATA[Jian Yang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Find Peak Element - 找峰值]]></title>
    <link href="http://eugeneyang.com/2016/03/15/Find%20Peak%20Element%20-%20%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <id>http://eugeneyang.com/2016/03/15/Find Peak Element - 找峰值/</id>
    <published>2016-03-15T12:44:47.000Z</published>
    <updated>2016-03-15T12:28:06.919Z</updated>
    <content type="html"><![CDATA[<h3 id="Find_Peak_Element_-_找峰值">Find Peak Element - 找峰值</h3><p><strong>Description</strong>: A peak element is an element that is greater than its neighbors.<br> Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.<br> The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.<br> You may imagine that num[-1] = num[n] = -∞.<br> For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>
<p> Note: Your solution should be in logarithmic complexity.</p>
<p>思路：二分法搜索</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindPeakElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分法搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid-<span class="number">1</span>&lt;=-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid]&gt;nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid+<span class="number">1</span>&gt;=nums.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid]&gt;nums[mid-<span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;nums[mid-<span class="number">1</span>] &amp;&amp; nums[mid]&gt;nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;=nums[mid-<span class="number">1</span>]) r = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Find_Peak_Element_-_找峰值">Find Peak Element - 找峰值</h3><p><strong>Description</strong>: A peak element is an element that is greater t]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Intersection of Two Linked Lists - 链表交叉节点]]></title>
    <link href="http://eugeneyang.com/2016/03/14/Intersection%20of%20Two%20Linked%20Lists%20-%20%E9%93%BE%E8%A1%A8%E4%BA%A4%E5%8F%89%E8%8A%82%E7%82%B9/"/>
    <id>http://eugeneyang.com/2016/03/14/Intersection of Two Linked Lists - 链表交叉节点/</id>
    <published>2016-03-14T12:44:47.000Z</published>
    <updated>2016-03-15T12:28:06.917Z</updated>
    <content type="html"><![CDATA[<h3 id="Intersection_of_Two_Linked_Lists_-_链表交叉节点">Intersection of Two Linked Lists - 链表交叉节点</h3><p><strong>Description</strong>: Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>Your code should preferably run in O(n) time and use only O(1) memory.<br> The linked lists must retain their original structure after the function returns.</p>
<p>思路：分别获取两链表长度并求差,长链表先跳过差数个节点,再同时遍历直到找到相同节点.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntersectionOfTwoLinkedLists</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别获取两链表长度并求差,长链表先跳过差数个节点,再同时遍历直到找到相同节点.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA==<span class="keyword">null</span> || headB==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (headA==headB) <span class="keyword">return</span> headA;</span><br><span class="line">        <span class="keyword">int</span> lenA = <span class="number">1</span>, lenB = <span class="number">1</span>;</span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pB.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = lenA-lenB;</span><br><span class="line">        <span class="keyword">int</span> diff = d&gt;=<span class="number">0</span> ? d : -d;</span><br><span class="line">        pA = headA; pB = headB;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (d&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;diff)&#123;</span><br><span class="line">                pA = pA.next;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;diff)&#123;</span><br><span class="line">                pB = pB.next;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pA!=<span class="keyword">null</span> &amp;&amp; pB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pA==pB) <span class="keyword">return</span> pA;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Intersection_of_Two_Linked_Lists_-_链表交叉节点">Intersection of Two Linked Lists - 链表交叉节点</h3><p><strong>Description</strong>: Write a pr]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Min Stack - 最小栈]]></title>
    <link href="http://eugeneyang.com/2016/03/13/Min%20Stack%20-%20%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://eugeneyang.com/2016/03/13/Min Stack - 最小栈/</id>
    <published>2016-03-13T12:44:47.000Z</published>
    <updated>2016-03-15T12:28:06.914Z</updated>
    <content type="html"><![CDATA[<h3 id="Min_Stack_-_最小栈">Min Stack - 最小栈</h3><p><strong>Description</strong>: Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<p> push(x) – Push element x onto stack.<br> pop() – Removes the element on top of the stack.<br> top() – Get the top element.<br> getMin() – Retrieve the minimum element in the stack.</p>
<p>思路：采用单链表，每个节点引入min记录该节点以下的最小值。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//链表节点引入min记录该节点以下的最小值</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(<span class="keyword">int</span> x)&#123;</span><br><span class="line">            value = x;</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node top = <span class="keyword">new</span> Node(x);</span><br><span class="line">        <span class="keyword">if</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            top.next = head;</span><br><span class="line">            <span class="keyword">if</span> (head.min&lt;top.min) top.min = head.min;</span><br><span class="line">        &#125;</span><br><span class="line">        head = top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head!=<span class="keyword">null</span>) head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> head.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> head.min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Min_Stack_-_最小栈">Min Stack - 最小栈</h3><p><strong>Description</strong>: Design a stack that supports push, pop, top, and retrieving th]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Find Minimum in Rotated Sorted Array - 有序倒转数组的最小值]]></title>
    <link href="http://eugeneyang.com/2016/03/12/Find%20Minimum%20in%20Rotated%20Sorted%20Array%20-%20%E6%9C%89%E5%BA%8F%E5%80%92%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>http://eugeneyang.com/2016/03/12/Find Minimum in Rotated Sorted Array - 有序倒转数组的最小值/</id>
    <published>2016-03-12T12:44:47.000Z</published>
    <updated>2016-03-15T12:28:06.908Z</updated>
    <content type="html"><![CDATA[<h3 id="Find_Minimum_in_Rotated_Sorted_Array_-_有序倒转数组的最小值">Find Minimum in Rotated Sorted Array - 有序倒转数组的最小值</h3><p><strong>Description</strong>: Suppose a sorted array is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).<br> Find the minimum element.<br> You may assume no duplicate exists in the array.</p>
<p>思路：二分法。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMinimumInRotatedSortedArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (min&gt;nums[m]) min = nums[m];</span><br><span class="line">            <span class="keyword">if</span> (nums[m]&lt;nums[r]) &#123;</span><br><span class="line">                r = m-<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (min&gt;nums[r]) min = nums[r];</span><br><span class="line">                l = m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Find_Minimum_in_Rotated_Sorted_Array_-_有序倒转数组的最小值">Find Minimum in Rotated Sorted Array - 有序倒转数组的最小值</h3><p><strong>Description</str]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Find Minimum in Rotated Sorted Array II - 有序倒转数组的最小值II]]></title>
    <link href="http://eugeneyang.com/2016/03/12/Find%20Minimum%20in%20Rotated%20Sorted%20Array%20II%20-%20%E6%9C%89%E5%BA%8F%E5%80%92%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/"/>
    <id>http://eugeneyang.com/2016/03/12/Find Minimum in Rotated Sorted Array II - 有序倒转数组的最小值II/</id>
    <published>2016-03-12T12:44:47.000Z</published>
    <updated>2016-03-15T12:28:06.911Z</updated>
    <content type="html"><![CDATA[<h3 id="Find_Minimum_in_Rotated_Sorted_Array_II_-_有序倒转数组的最小值II">Find Minimum in Rotated Sorted Array II - 有序倒转数组的最小值II</h3><p><strong>Description</strong>: Follow up for “Find Minimum in Rotated Sorted Array”:<br> What if duplicates are allowed?<br> Would this affect the run-time complexity? How and why?</p>
<p>思路：二分法。当nums[m] = nums[r]时，无法排除一半的序列，而只能排除掉nums[r],此时只能搜寻nums[l:r-1].</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMinimumInRotatedSortedArrayII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当nums[m] = nums[r]时，无法排除一半的序列，而只能排除掉nums[r],此时只能搜寻nums[l:r-1]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (min&gt;nums[m]) min = nums[m];</span><br><span class="line">            <span class="keyword">if</span> (nums[m]&lt;nums[r]) &#123;</span><br><span class="line">                r = m-<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m]&gt;nums[r])&#123;</span><br><span class="line">                <span class="keyword">if</span> (min&gt;nums[r]) min = nums[r];</span><br><span class="line">                l = m+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">//nums[m] == nums[r]时</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Find_Minimum_in_Rotated_Sorted_Array_II_-_有序倒转数组的最小值II">Find Minimum in Rotated Sorted Array II - 有序倒转数组的最小值II</h3><p><strong>Descri]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maximum Product Subarray - 最大乘积子串]]></title>
    <link href="http://eugeneyang.com/2016/03/11/Maximum%20Product%20Subarray%20-%20%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%E5%AD%90%E4%B8%B2/"/>
    <id>http://eugeneyang.com/2016/03/11/Maximum Product Subarray - 最大乘积子串/</id>
    <published>2016-03-11T12:44:47.000Z</published>
    <updated>2016-03-15T12:28:06.906Z</updated>
    <content type="html"><![CDATA[<h3 id="Maximum_Product_Subarray_-_最大乘积子串">Maximum Product Subarray - 最大乘积子串</h3><p><strong>Description</strong>: Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array [2,3,-2,4],<br> the contiguous subarray [2,3] has the largest product = 6.</p>
<p>思路：一维动态规划，考虑到乘积符号问题，同时记录最大值（正）与最小值（负），采用局部和全局变量追踪局部与最终结果。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumProductSubarray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一维动态规划，考虑到乘积符号问题，同时记录最大值（正）与最小值（负），</span></span><br><span class="line">    <span class="comment">// 采用局部和全局变量追踪局部与最终结果。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> globalMax = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp1 = nums[i]*max;</span><br><span class="line">            <span class="keyword">int</span> temp2 = nums[i]*min;</span><br><span class="line">            max = Math.max(Math.max(temp1, nums[i]), temp2);</span><br><span class="line">            min = Math.min(Math.min(temp1, nums[i]), temp2);</span><br><span class="line">            globalMax = Math.max(globalMax, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> globalMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Maximum_Product_Subarray_-_最大乘积子串">Maximum Product Subarray - 最大乘积子串</h3><p><strong>Description</strong>: Find the contiguous subarr]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Reverse Words in a String - 逆转字符串中的词语]]></title>
    <link href="http://eugeneyang.com/2016/03/10/Reverse%20Words%20in%20a%20String%20-%20%E9%80%86%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E8%AF%8D%E8%AF%AD/"/>
    <id>http://eugeneyang.com/2016/03/10/Reverse Words in a String - 逆转字符串中的词语/</id>
    <published>2016-03-10T12:44:47.000Z</published>
    <updated>2016-03-10T08:49:39.880Z</updated>
    <content type="html"><![CDATA[<h3 id="Reverse_Words_in_a_String_-_逆转字符串中的词语">Reverse Words in a String - 逆转字符串中的词语</h3><p><strong>Description</strong>: Given an input string, reverse the string word by word.</p>
<p>For example,<br> Given s = “the sky is blue”,<br> return “blue is sky the”.</p>
<p>思路：字符串裁剪与分割。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseWordsInString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> ReverseWordsInString().reverseWords(<span class="string">"a"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String trimed = s.trim();</span><br><span class="line">        <span class="keyword">if</span> (trimed.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String[] strings = trimed.split(<span class="string">"\\s+"</span>);</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=strings.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            builder.append(strings[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Reverse_Words_in_a_String_-_逆转字符串中的词语">Reverse Words in a String - 逆转字符串中的词语</h3><p><strong>Description</strong>: Given an input str]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Evaluate Reverse Polish Notation - 计算逆波兰表达式]]></title>
    <link href="http://eugeneyang.com/2016/03/09/Evaluate%20Reverse%20Polish%20Notation%20-%20%E8%AE%A1%E7%AE%97%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://eugeneyang.com/2016/03/09/Evaluate Reverse Polish Notation - 计算逆波兰表达式/</id>
    <published>2016-03-09T12:44:47.000Z</published>
    <updated>2016-03-10T08:49:39.877Z</updated>
    <content type="html"><![CDATA[<h3 id="Evaluate_Reverse_Polish_Notation_-_计算逆波兰表达式">Evaluate Reverse Polish Notation - 计算逆波兰表达式</h3><p><strong>Description</strong>: Evaluate the value of an arithmetic expression in Reverse Polish Notation.<br>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<p>Some examples:<br>  [“2”, “1”, “+”, “3”, “<em>“] -&gt; ((2 + 1) </em> 3) -&gt; 9<br>  [“4”, “13”, “5”, “/“, “+”] -&gt; (4 + (13 / 5)) -&gt; 6</p>
<p>思路：利用栈。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvaluateReversePolishNotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(tokens[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;tokens.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isOperator(tokens[i])) stack.push(tokens[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">char</span> c = tokens[i].charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> y = Integer.valueOf(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> x = Integer.valueOf(stack.pop());</span><br><span class="line">                stack.push(String.valueOf(calculate(x, y, c)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOperator</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'0'</span>&lt;=c &amp;&amp; c&lt;=<span class="string">'9'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>: <span class="keyword">return</span> x+y;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: <span class="keyword">return</span> x-y;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>: <span class="keyword">return</span> x*y;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>: <span class="keyword">return</span> x/y;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Evaluate_Reverse_Polish_Notation_-_计算逆波兰表达式">Evaluate Reverse Polish Notation - 计算逆波兰表达式</h3><p><strong>Description</strong>: Evalua]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Max Points on a Line - 直线上最大点数]]></title>
    <link href="http://eugeneyang.com/2016/03/08/Max%20Points%20on%20a%20Line%20-%20%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/03/08/Max Points on a Line - 直线上最大点数/</id>
    <published>2016-03-08T12:44:47.000Z</published>
    <updated>2016-03-09T05:07:13.979Z</updated>
    <content type="html"><![CDATA[<h3 id="Max_Points_on_a_Line_-_直线上最大点数">Max Points on a Line - 直线上最大点数</h3><p><strong>Description</strong>: Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<p>思路：为每个点计算其与其他点的斜率,斜率相同则在同一直线上.注意额外处理重复点和垂直线的情况.</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/04/leetcode-max-points-on-a-line-java/" target="_blank" rel="external">http://www.programcreek.com/2014/04/leetcode-max-points-on-a-line-java/</a></p>
<p>注意：double slope = (point1.y-point2.y)==0 ? 0.0 : (1.0<em>(point1.y-point2.y))/(point1.x-point2.x);<br>若写成 double slope = (1.0</em>(point1.y-point2.y))/(point1.x-point2.x);<br>在slopeCount.containsKey(slope)判断中会出错，这个细节一定要注意！</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPointsOnLine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        Point() &#123; x = <span class="number">0</span>; y = <span class="number">0</span>; &#125;</span><br><span class="line">        Point(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; x = a; y = b; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2014/04/leetcode-max-points-on-a-line-java/</span><br><span class="line">     * 为每个点计算其与其他点的斜率,斜率相同则在同一直线上.注意额外处理重复点和垂直线的情况.</span><br><span class="line">     * <span class="doctag">@param</span> points</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Double, Integer&gt; slopeCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;points.length; i++)&#123;</span><br><span class="line">            Point point1 = points[i];</span><br><span class="line">            <span class="keyword">int</span> duplicate = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> vertical = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;points.length; j++)&#123;</span><br><span class="line">                Point point2 = points[j];</span><br><span class="line">                <span class="keyword">if</span> (point1.x==point2.x) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (point1.y==point2.y) duplicate++;</span><br><span class="line">                    <span class="keyword">else</span> vertical++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//TODO 错误:double slope = (1.0*(point1.y-point2.y))/(point1.x-point2.x);</span></span><br><span class="line">                    <span class="keyword">double</span> slope = (point1.y-point2.y)==<span class="number">0</span> ? <span class="number">0.0</span> :</span><br><span class="line">                            (<span class="number">1.0</span>*(point1.y-point2.y))/(point1.x-point2.x);</span><br><span class="line">                    <span class="keyword">if</span> (!slopeCount.containsKey(slope)) slopeCount.put(slope, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> slopeCount.put(slope, slopeCount.get(slope)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Integer n : slopeCount.values())&#123;</span><br><span class="line">                <span class="keyword">if</span> (n+duplicate&gt;max) max = n+duplicate;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(vertical+duplicate, max);</span><br><span class="line">            slopeCount.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Max_Points_on_a_Line_-_直线上最大点数">Max Points on a Line - 直线上最大点数</h3><p><strong>Description</strong>: Given n points on a 2D plane, fi]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sort List - 归并排序链表]]></title>
    <link href="http://eugeneyang.com/2016/03/07/Sort%20List%20-%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://eugeneyang.com/2016/03/07/Sort List - 归并排序链表/</id>
    <published>2016-03-07T12:44:47.000Z</published>
    <updated>2016-03-08T07:51:04.059Z</updated>
    <content type="html"><![CDATA[<h3 id="Sort_List_-_归并排序链表">Sort List - 归并排序链表</h3><p><strong>Description</strong>: Sort a linked list in O(nlogn) time using constant space complexity.</p>
<p>思路：O(nlogn)可以采用快速排序/归并排序/堆排序,对于链表用归并排序方便(配合合并两个有序链表).</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * O(nlogn)可以采用快速排序/归并排序/堆排序,对于链表用归并排序方便(配合合并两个有序链表).</span><br><span class="line">     * <span class="doctag">@param</span> head</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeSort</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="comment">//TODO fast.next.next!=null不能漏</span></span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head2 = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode l1 = mergeSort(head);</span><br><span class="line">        ListNode l2 = mergeSort(head2);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoSortedLinkedList(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoSortedLinkedList</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1.val&lt;l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoSortedLinkedList(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoSortedLinkedList(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Sort_List_-_归并排序链表">Sort List - 归并排序链表</h3><p><strong>Description</strong>: Sort a linked list in O(nlogn) time using constant space]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Insertion Sort List - 插入排序链表]]></title>
    <link href="http://eugeneyang.com/2016/03/06/Insertion%20Sort%20List%20-%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://eugeneyang.com/2016/03/06/Insertion Sort List - 插入排序链表/</id>
    <published>2016-03-06T12:44:47.000Z</published>
    <updated>2016-03-08T07:51:04.056Z</updated>
    <content type="html"><![CDATA[<h3 id="Insertion_Sort_List_-_插入排序链表">Insertion Sort List - 插入排序链表</h3><p><strong>Description</strong>: Sort a linked list using insertion sort.</p>
<p>思路：插入排序就是每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSortList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode curr = head.next;</span><br><span class="line">        <span class="keyword">while</span> (curr!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.val&lt;pre.val)&#123;</span><br><span class="line">                pre.next = curr.next;</span><br><span class="line">                ListNode p = dummy;</span><br><span class="line">                ListNode q = dummy.next;</span><br><span class="line">                <span class="keyword">while</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (curr.val&lt;q.val)&#123;</span><br><span class="line">                        p.next = curr;</span><br><span class="line">                        curr.next = q;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = q;</span><br><span class="line">                    q = q.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = pre.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = curr;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Insertion_Sort_List_-_插入排序链表">Insertion Sort List - 插入排序链表</h3><p><strong>Description</strong>: Sort a linked list using insertion s]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LRU Cache - 最近最少访问缓存机制实现]]></title>
    <link href="http://eugeneyang.com/2016/03/05/LRU%20Cache%20-%20%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E8%AE%BF%E9%97%AE%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0/"/>
    <id>http://eugeneyang.com/2016/03/05/LRU Cache - 最近最少访问缓存机制实现/</id>
    <published>2016-03-05T12:44:47.000Z</published>
    <updated>2016-03-08T07:51:04.052Z</updated>
    <content type="html"><![CDATA[<h3 id="LRU_Cache_-_最近最少访问缓存机制实现">LRU Cache - 最近最少访问缓存机制实现</h3><p><strong>Description</strong>: Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.<br>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>思路：如果要O(1)的查找复杂度，肯定要用哈希表.<br>如果要O(1)的cache替换复杂度,可以采用链表,保证从头到尾的顺序就是cache从新到旧的顺序.对于任何一个节点，如果被访问了，那么就将该节点移至头部;如果cache已满，那么就把尾部的删掉，从头部插入新节点。</p>
<p>参考链接：<a href="http://www.programcreek.com/2013/03/leetcode-lru-cache-java/" target="_blank" rel="external">http://www.programcreek.com/2013/03/leetcode-lru-cache-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CacheEntry</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        CacheEntry pre;</span><br><span class="line">        CacheEntry next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CacheEntry</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, CacheEntry&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> CacheEntry head=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> CacheEntry end=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2013/03/leetcode-lru-cache-java/</span><br><span class="line">     * 如果要O(1)的查找复杂度，肯定要用哈希表.</span><br><span class="line">     * 如果要O(1)的cache替换复杂度,可以采用链表,保证从头到尾的顺序就是cache从新到旧的顺序.</span><br><span class="line">     对于任何一个节点，如果被访问了，那么就将该节点移至头部;</span><br><span class="line">     如果cache已满，那么就把尾部的删掉，从头部插入新节点。</span><br><span class="line">     * <span class="doctag">@param</span> capacity</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key))&#123;</span><br><span class="line">            CacheEntry cacheEntry = map.get(key);</span><br><span class="line">            <span class="comment">//对于任何一个节点，如果被访问了，那么就将该节点移至头部</span></span><br><span class="line">            remove(cacheEntry);</span><br><span class="line">            setHead(cacheEntry);</span><br><span class="line">            <span class="keyword">return</span> cacheEntry.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key))&#123;</span><br><span class="line">            CacheEntry old = map.get(key);</span><br><span class="line">            old.value = value;</span><br><span class="line">            <span class="comment">//对于任何一个节点，如果被访问了，那么就将该节点移至头部</span></span><br><span class="line">            remove(old);</span><br><span class="line">            setHead(old);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            CacheEntry newCacheEntry = <span class="keyword">new</span> CacheEntry(key, value);</span><br><span class="line">            <span class="keyword">if</span> (map.size()&gt;=capacity)&#123;</span><br><span class="line">                <span class="comment">//如果cache已满，那么就把尾部的删掉，从头部插入新节点</span></span><br><span class="line">                map.remove(end.key);</span><br><span class="line">                remove(end);</span><br><span class="line">            &#125;</span><br><span class="line">            setHead(newCacheEntry);</span><br><span class="line">            map.put(key, newCacheEntry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(CacheEntry cacheEntry)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheEntry.pre!=<span class="keyword">null</span>) cacheEntry.pre.next = cacheEntry.next;</span><br><span class="line">        <span class="keyword">else</span> head = cacheEntry.next;</span><br><span class="line">        <span class="keyword">if</span> (cacheEntry.next!=<span class="keyword">null</span>) cacheEntry.next.pre = cacheEntry.pre;</span><br><span class="line">        <span class="keyword">else</span> end = cacheEntry.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(CacheEntry cacheEntry)</span></span>&#123;</span><br><span class="line">        cacheEntry.next = head;</span><br><span class="line">        cacheEntry.pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head!=<span class="keyword">null</span>) head.pre = cacheEntry;</span><br><span class="line">        head = cacheEntry;</span><br><span class="line">        <span class="keyword">if</span> (end==<span class="keyword">null</span>) end = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="LRU_Cache_-_最近最少访问缓存机制实现">LRU Cache - 最近最少访问缓存机制实现</h3><p><strong>Description</strong>: Design and implement a data structure for Le]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binary Tree Postorder Traversal- 二叉树后序遍历(迭代)]]></title>
    <link href="http://eugeneyang.com/2016/03/04/Binary%20Tree%20Postorder%20Traversal-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86(%E8%BF%AD%E4%BB%A3)/"/>
    <id>http://eugeneyang.com/2016/03/04/Binary Tree Postorder Traversal- 二叉树后序遍历(迭代)/</id>
    <published>2016-03-04T12:44:47.000Z</published>
    <updated>2016-03-04T10:59:44.692Z</updated>
    <content type="html"><![CDATA[<h3 id="Binary_Tree_Postorder_Traversal-_二叉树后序遍历(迭代)">Binary Tree Postorder Traversal- 二叉树后序遍历(迭代)</h3><p><strong>Description</strong>: Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>思路：<br>一、遍历的同时将访问过的节点的相应左或右孩子指针置空，思路简单。<br>二、后序遍历的情况相对复杂,需要维护当前遍历的cur指针和前一个遍历的pre指针来追溯当前的情况（注意这里是遍历的指针，并不是真正按后序访问顺序的结点）。具体分为几种情况：<br>     （1）如果pre的左孩子或者右孩子是cur，那么说明遍历在往下走，按访问顺序继续，即如果有左孩子，则是左孩子进栈，否则如果有右孩子，则是右孩子进栈，<br>     如果左右孩子都没有，则说明该结点是叶子，可以直接访问并把结点出栈了。<br>     （2）如果反过来，cur的左孩子是pre，则说明已经在回溯往上走了，但是后序遍历要左右孩子走完才可以访问自己，所以这里如果有右孩子还需要把右孩子进栈，否则说明已经到自己了，可以访问并且出栈了。<br>     （3）如果cur的右孩子是pre，那么说明左右孩子都访问结束了，可以轮到自己了，访问并且出栈即可。<br>     与递归法一样,算法时间复杂度也是O(n)，空间复杂度是栈的大小O(logn)。</p>
<p>参考链接：<br><a href="http://www.programcreek.com/2012/12/leetcode-solution-of-iterative-binary-tree-postorder-traversal-in-java/" target="_blank" rel="external">http://www.programcreek.com/2012/12/leetcode-solution-of-iterative-binary-tree-postorder-traversal-in-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 后序遍历的情况相对复杂,需要维护当前遍历的cur指针和前一个遍历的pre指针来追溯当前的情况</span><br><span class="line">     （注意这里是遍历的指针，并不是真正按后序访问顺序的结点）。具体分为几种情况：</span><br><span class="line">     （1）如果pre的左孩子或者右孩子是cur，那么说明遍历在往下走，按访问顺序继续，</span><br><span class="line">     即如果有左孩子，则是左孩子进栈，否则如果有右孩子，则是右孩子进栈，</span><br><span class="line">     如果左右孩子都没有，则说明该结点是叶子，可以直接访问并把结点出栈了。</span><br><span class="line">     （2）如果反过来，cur的左孩子是pre，则说明已经在回溯往上走了，</span><br><span class="line">     但是后序遍历要左右孩子走完才可以访问自己，所以这里如果有右孩子还需要把右孩子进栈，</span><br><span class="line">     否则说明已经到自己了，可以访问并且出栈了。</span><br><span class="line">     （3）如果cur的右孩子是pre，那么说明左右孩子都访问结束了，可以轮到自己了，访问并且出栈即可。</span><br><span class="line">     与递归法一样,算法时间复杂度也是O(n)，空间复杂度是栈的大小O(logn)。</span><br><span class="line">     * http://www.programcreek.com/2012/12/leetcode-solution-of-iterative-binary-tree-postorder-traversal-in-java/</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode curr = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (prev==<span class="keyword">null</span> || prev.left==curr || prev.right==curr)&#123; <span class="comment">//往下走</span></span><br><span class="line">                <span class="keyword">if</span> (curr.left!=<span class="keyword">null</span>) stack.push(curr.left);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (curr.right!=<span class="keyword">null</span>) stack.push(curr.right);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    result.add(curr.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr.left==prev)&#123;    <span class="comment">//从左节点往上走</span></span><br><span class="line">                <span class="keyword">if</span> (curr.right!=<span class="keyword">null</span>) stack.push(curr.right);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    result.add(curr.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr.right==prev)&#123;   <span class="comment">//从右节点往上走</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                result.add(curr.val);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种方法简单,但是会改变原树结构</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (stack.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode top = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (top.left == <span class="keyword">null</span> &amp;&amp; top.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(top.val);</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(top.left);</span><br><span class="line">                top.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(top.right);</span><br><span class="line">                top.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Binary_Tree_Postorder_Traversal-_二叉树后序遍历(迭代)">Binary Tree Postorder Traversal- 二叉树后序遍历(迭代)</h3><p><strong>Description</strong>: Give]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binary Tree Preorder Traversal - 二叉树先序遍历(迭代)]]></title>
    <link href="http://eugeneyang.com/2016/03/03/Binary%20Tree%20Preorder%20Traversal%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86(%E8%BF%AD%E4%BB%A3)/"/>
    <id>http://eugeneyang.com/2016/03/03/Binary Tree Preorder Traversal - 二叉树先序遍历(迭代)/</id>
    <published>2016-03-03T12:44:47.000Z</published>
    <updated>2016-03-04T10:59:44.641Z</updated>
    <content type="html"><![CDATA[<h3 id="Binary_Tree_Preorder_Traversal_-_二叉树先序遍历(迭代)">Binary Tree Preorder Traversal - 二叉树先序遍历(迭代)</h3><p><strong>Description</strong>: Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>思路：迭代法使用栈.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePreorderTraversal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Binary_Tree_Preorder_Traversal_-_二叉树先序遍历(迭代)">Binary Tree Preorder Traversal - 二叉树先序遍历(迭代)</h3><p><strong>Description</strong>: Give]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Reorder List - 重排序链表]]></title>
    <link href="http://eugeneyang.com/2016/03/02/Reorder%20List%20-%20%E9%87%8D%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://eugeneyang.com/2016/03/02/Reorder List - 重排序链表/</id>
    <published>2016-03-02T12:44:47.000Z</published>
    <updated>2016-03-04T10:59:44.639Z</updated>
    <content type="html"><![CDATA[<h3 id="Reorder_List_-_重排序链表">Reorder List - 重排序链表</h3><p><strong>Description</strong>: Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br> reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p> You must do this in-place without altering the nodes’ values.</p>
<p> For example, Given {1,2,3,4}, reorder it to {1,4,2,3}.</p>
<p>思路：使用快慢指针先将链表分成两半,逆转后半段链表,再交叉合并.</p>
<p>参考链接：<br><a href="http://www.programcreek.com/2013/12/in-place-reorder-a-singly-linked-list-in-java/" target="_blank" rel="external">http://www.programcreek.com/2013/12/in-place-reorder-a-singly-linked-list-in-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 使用快慢指针先将链表分成两半,逆转后半段链表,再交叉合并.</span><br><span class="line"> * http://www.programcreek.com/2013/12/in-place-reorder-a-singly-linked-list-in-java/</span><br><span class="line"> * <span class="doctag">@param</span> head</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode l2 = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    l2 = reverse(l2);</span><br><span class="line">    crossMerge(head, l2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode pre = head;</span><br><span class="line">    ListNode curr = head.next;</span><br><span class="line">    <span class="keyword">while</span> (curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        curr.next = pre;</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表l1/l2长度一致,交叉合并</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">crossMerge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    ListNode p1 = l1;</span><br><span class="line">    ListNode p2 = l2;</span><br><span class="line">    <span class="keyword">while</span> (p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp1 = p1.next;</span><br><span class="line">        ListNode temp2 = p2.next;</span><br><span class="line">        p1.next = p2;</span><br><span class="line">        p2.next = temp1;</span><br><span class="line">        p1 = temp1;</span><br><span class="line">        p2 = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode first = head;</span><br><span class="line">    ListNode p = first;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="keyword">null</span> &amp;&amp; p.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.next.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nextFirst = first.next;</span><br><span class="line">            first.next = p.next;</span><br><span class="line">            p.next.next = nextFirst;</span><br><span class="line">            first = nextFirst;</span><br><span class="line">            p.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">int</span> count = (num-<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (count!=<span class="number">0</span>)&#123;</span><br><span class="line">        p = first;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span> &amp;&amp; p.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.next.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                ListNode nextFirst = first.next;</span><br><span class="line">                first.next = p.next;</span><br><span class="line">                p.next.next = nextFirst;</span><br><span class="line">                first = nextFirst;</span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Reorder_List_-_重排序链表">Reorder List - 重排序链表</h3><p><strong>Description</strong>: Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br> r]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linked List Cycle II - 判断链表回环II]]></title>
    <link href="http://eugeneyang.com/2016/03/01/Linked%20List%20Cycle%20II%20-%20%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E5%9B%9E%E7%8E%AFII/"/>
    <id>http://eugeneyang.com/2016/03/01/Linked List Cycle II - 判断链表回环II/</id>
    <published>2016-03-01T12:44:47.000Z</published>
    <updated>2016-03-04T10:59:44.637Z</updated>
    <content type="html"><![CDATA[<h3 id="Linked_List_Cycle_II_-_判断链表回环II">Linked List Cycle II - 判断链表回环II</h3><p><strong>Description</strong>: Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.<br>Follow up: Can you solve it without using extra space?</p>
<p>思路：假设链表有环，环长Y，环以外的长度是X。快慢两指针从起点出发,最后相遇在K处,设环起到到K处长度为K. 有Y-K=X,意思是两指针相遇后再走X就回到了环的起点.</p>
<p>参考链接：<a href="http://fisherlei.blogspot.co.id/2013/11/leetcode-linked-list-cycle-ii-solution.html" target="_blank" rel="external">http://fisherlei.blogspot.co.id/2013/11/leetcode-linked-list-cycle-ii-solution.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListCycleII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://fisherlei.blogspot.co.id/2013/11/leetcode-linked-list-cycle-ii-solution.html</span><br><span class="line">     * 假设链表有环，环长Y，环以外的长度是X。快慢两指针从起点出发,最后相遇在K处,设环起到到K处长度为K.</span><br><span class="line">     有Y-K=X,意思是两指针相遇后再走X就回到了环的起点.</span><br><span class="line">     * <span class="doctag">@param</span> head</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow!=fast)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast==<span class="keyword">null</span> || fast.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head!=slow.next)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Linked_List_Cycle_II_-_判断链表回环II">Linked List Cycle II - 判断链表回环II</h3><p><strong>Description</strong>: Given a linked list, return th]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linked List Cycle- 判断链表回环]]></title>
    <link href="http://eugeneyang.com/2016/02/29/Linked%20List%20Cycle-%20%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E5%9B%9E%E7%8E%AF/"/>
    <id>http://eugeneyang.com/2016/02/29/Linked List Cycle- 判断链表回环/</id>
    <published>2016-02-29T12:44:47.000Z</published>
    <updated>2016-03-04T10:59:44.635Z</updated>
    <content type="html"><![CDATA[<h3 id="Linked_List_Cycle-_判断链表回环">Linked List Cycle- 判断链表回环</h3><p><strong>Description</strong>: Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up: Can you solve it without using extra space?</p>
<p>思路：<br>一、将访问过的节点都指向一个预设的特殊节点,有回环则会访问到此特殊节点。<br>二、使用快慢双指针,有回环则快指针会追上慢指针。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用快慢双指针,有回环则快指针会追上慢指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow==fast) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将访问过的节点都指向一个预设的特殊节点,有回环则会访问到此特殊节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(Integer.MAX_VALUE);</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p==dummy) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            next = p.next;</span><br><span class="line">            p.next = dummy;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Linked_List_Cycle-_判断链表回环">Linked List Cycle- 判断链表回环</h3><p><strong>Description</strong>: Given a linked list, determine if it has a]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Word Break II - 单词划分 II]]></title>
    <link href="http://eugeneyang.com/2016/02/28/Word%20Break%20II%20-%20%E5%8D%95%E8%AF%8D%E5%88%92%E5%88%86%20II/"/>
    <id>http://eugeneyang.com/2016/02/28/Word Break II - 单词划分 II/</id>
    <published>2016-02-28T12:44:47.000Z</published>
    <updated>2016-02-28T07:07:58.879Z</updated>
    <content type="html"><![CDATA[<h3 id="Word_Break_II_-_单词划分_II">Word Break II - 单词划分 II</h3><p><strong>Description</strong>: Given a string s and a dictionary of words dict, add spaces in s<br> to construct a sentence where each word is a valid dictionary word.<br> Return all such possible sentences.</p>
<p> For example, given<br> s = “catsanddog”,<br> dict = [“cat”, “cats”, “and”, “sand”, “dog”].<br> A solution is [“cats and dog”, “cat sand dog”].</p>
<p>思路：<br>一、回溯,但无法过大数据集(可以尝试引入剪枝函数提速)。<br>二、DP+回溯,与Word Break I不同在于用数组记录断词处有哪些单词,而不是简单记录布尔数组.DP之后再回溯得到所有可能的断词方式.</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/03/leetcode-word-break-ii-java/" target="_blank" rel="external">http://www.programcreek.com/2014/03/leetcode-word-break-ii-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordBreakII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * DP+回溯,与Word Break I不同在于用数组记录断词处有哪些单词,而不是简单记录布尔数组.</span><br><span class="line">     DP之后再回溯得到所有可能的断词方式.</span><br><span class="line">     http://www.programcreek.com/2014/03/leetcode-word-break-ii-java/</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@param</span> wordDict</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; dp[] = <span class="keyword">new</span> ArrayList[s.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i]==<span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (String word : wordDict)&#123;</span><br><span class="line">                <span class="keyword">int</span> end = i+word.length();</span><br><span class="line">                <span class="keyword">if</span> (end&gt;s.length()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.substring(i, end).equals(word))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[end]==<span class="keyword">null</span>) dp[end] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    dp[end].add(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[s.length()]==<span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        dfs(dp, s.length(), result, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt;[] dp, <span class="keyword">int</span> end, List&lt;String&gt; result, List&lt;String&gt; tmp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            String path = tmp.get(tmp.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=tmp.size()-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) path += <span class="string">" "</span> + tmp.get(i);</span><br><span class="line">            result.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String str : dp[end])&#123;</span><br><span class="line">            tmp.add(str);</span><br><span class="line">            dfs(dp, end-str.length(), result, tmp);</span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回溯,但无法过大数据集(可以尝试引入剪枝函数提速)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak1</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        wordBreakHelper(s, wordDict, <span class="number">0</span>, result, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wordBreakHelper</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start,</span><br><span class="line">                                 List&lt;String&gt; result, StringBuilder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start==s.length())&#123;</span><br><span class="line">            result.add(builder.toString().trim());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start+<span class="number">1</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            String str = s.substring(start, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(str)) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = builder.length();</span><br><span class="line">                builder.append(<span class="string">" "</span>+str);</span><br><span class="line">                wordBreakHelper(s, wordDict, i+<span class="number">1</span>, result, builder);</span><br><span class="line">                builder.delete(len, len+str.length()+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Word_Break_II_-_单词划分_II">Word Break II - 单词划分 II</h3><p><strong>Description</strong>: Given a string s and a dictionary of words dic]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Word Break - 单词划分]]></title>
    <link href="http://eugeneyang.com/2016/02/27/Word%20Break%20-%20%E5%8D%95%E8%AF%8D%E5%88%92%E5%88%86/"/>
    <id>http://eugeneyang.com/2016/02/27/Word Break - 单词划分/</id>
    <published>2016-02-27T12:44:47.000Z</published>
    <updated>2016-02-28T07:07:58.877Z</updated>
    <content type="html"><![CDATA[<h3 id="Word_Break_-_单词划分">Word Break - 单词划分</h3><p><strong>Description</strong>: Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p> For example, given<br> s = “leetcode”,<br> dict = [“leet”, “code”].<br> Return true because “leetcode” can be segmented as “leet code”.</p>
<p>思路：<br>一、原始办法:回溯,超时。<br>二、看到这题第一反应是DFS枚举查找，直到“探”到string尾部则算成功。但题目并不要求给出是如何break的，而只要判断是否能break。对这类判断“是”与“否”的可以用DFS暴力解决的题，可以尝试用DP做book keeping中间判断状态，避免DFS的反复搜索。<br>定义t[i]为区间[0,i-1]能否被分割,注意初始状态t[0]=True.<br>t[i+1]=True时应满足:1.s[k,i]在字典中,0&lt;=k&lt;=i;2.t[k]==True.</p>
<p>注意：本题边界情况极易出错。</p>
<p>参考链接：<a href="http://www.programcreek.com/2012/12/leetcode-solution-word-break/" target="_blank" rel="external">http://www.programcreek.com/2012/12/leetcode-solution-word-break/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordBreak</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**http://www.programcreek.com/2012/12/leetcode-solution-word-break/</span><br><span class="line">     * 看到这题第一反应是DFS枚举查找，直到“探”到string尾部则算成功。但题目并不要求给出是如何break的，</span><br><span class="line">     而只要判断是否能break。对这类判断“是”与“否”的可以用DFS暴力解决的题，</span><br><span class="line">     可以尝试用DP做book keeping中间判断状态，避免DFS的反复搜索。</span><br><span class="line">     * 定义t[i]为区间[0,i-1]能否被分割,注意初始状态t[0]=True.</span><br><span class="line">     t[i+1]=True时应满足:1.s[k,i]在字典中,0&lt;=k&lt;=i;2.t[k]==True.</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@param</span> wordDict</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] t = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        t[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i; j++)&#123;   <span class="comment">//TODO 边界极易出错</span></span><br><span class="line">                <span class="keyword">if</span> (t[j] &amp;&amp; wordDict.contains(s.substring(j, i+<span class="number">1</span>)))&#123;</span><br><span class="line">                    t[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基于给定字典遍历的DP,注意代码中if (t[end]) continue;部分易错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak1</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] t = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        t[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!t[i]) <span class="keyword">continue</span>;    <span class="comment">//不能分割,跳过</span></span><br><span class="line">            <span class="keyword">for</span> (String word : wordDict)&#123;</span><br><span class="line">                <span class="keyword">int</span> end = i+word.length();</span><br><span class="line">                <span class="keyword">if</span> (end&gt;s.length()) <span class="keyword">continue</span>;   <span class="comment">//超过字符串s长度</span></span><br><span class="line">                <span class="comment">//注意用例"programcreek", ["programcree","program","creek"]</span></span><br><span class="line">                <span class="comment">//下面的语句保证不会停在programcree,而是读完所有programcreek</span></span><br><span class="line">                <span class="keyword">if</span> (t[end]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.substring(i, end).equals(word)) t[end] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原始办法:回溯,超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak2</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wordBreakHelper(s, wordDict, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基于给定字典遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">wordBreakHelper</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start==s.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = word.length();</span><br><span class="line">            <span class="keyword">int</span> end = start+len;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; s.length()) <span class="keyword">continue</span>; <span class="comment">//超过字符串s长度</span></span><br><span class="line">            <span class="keyword">if</span> (s.substring(start, end).equals(word))&#123;</span><br><span class="line">                <span class="keyword">if</span> (wordBreakHelper(s, wordDict, end)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基于给定字符串s遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">wordBreakHelper1</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start==s.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start+<span class="number">1</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            String str = s.substring(start, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!wordDict.contains(str)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (wordBreakHelper(s, wordDict, i+<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Word_Break_-_单词划分">Word Break - 单词划分</h3><p><strong>Description</strong>: Given a string s and a dictionary of words dict, determine]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Copy List with Random Pointer - 复制带随机指针的链表]]></title>
    <link href="http://eugeneyang.com/2016/02/26/Copy%20List%20with%20Random%20Pointer%20-%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://eugeneyang.com/2016/02/26/Copy List with Random Pointer - 复制带随机指针的链表/</id>
    <published>2016-02-26T12:44:47.000Z</published>
    <updated>2016-02-28T07:07:58.874Z</updated>
    <content type="html"><![CDATA[<h3 id="Copy_List_with_Random_Pointer_-_复制带随机指针的链表">Copy List with Random Pointer - 复制带随机指针的链表</h3><p><strong>Description</strong>: A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list.</p>
<p>思路：<br>一、与Clone Graph思路一致,使用队列和哈希表；<br>二、仅使用哈希表和双指针,速度更快。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyListWithRandomPointer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for singly-linked list with a random pointer.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> label;</span><br><span class="line">        RandomListNode next, random;</span><br><span class="line">        RandomListNode(<span class="keyword">int</span> x) &#123; <span class="keyword">this</span>.label = x; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//仅使用哈希表和双指针,速度更快</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        RandomListNode newHead = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">        RandomListNode p = head;</span><br><span class="line">        RandomListNode q = newHead;</span><br><span class="line">        map.put(head, newHead);</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode newNode = <span class="keyword">new</span> RandomListNode(p.label);</span><br><span class="line">            map.put(p, newNode);</span><br><span class="line">            q.next = newNode;</span><br><span class="line">            q = newNode;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        q = newHead;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.random!=<span class="keyword">null</span>) q.random = map.get(p.random);</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与Clone Graph思路一致,使用队列和哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList1</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;RandomListNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(head);</span><br><span class="line">        RandomListNode newHead = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">        map.put(head, newHead);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            RandomListNode curOld = queue.poll();</span><br><span class="line">            RandomListNode[] olds = &#123;curOld.next, curOld.random&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (olds[i]==<span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(olds[i]))&#123;</span><br><span class="line">                    RandomListNode newNode = <span class="keyword">new</span> RandomListNode(olds[i].label);</span><br><span class="line">                    map.put(olds[i], newNode);</span><br><span class="line">                    <span class="keyword">if</span> (i==<span class="number">0</span>) map.get(curOld).next = newNode;</span><br><span class="line">                    <span class="keyword">else</span> map.get(curOld).random = newNode;</span><br><span class="line">                    queue.offer(olds[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==<span class="number">0</span>) map.get(curOld).next = map.get(curOld.next);</span><br><span class="line">                    <span class="keyword">else</span> map.get(curOld).random = map.get(curOld.random);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Copy_List_with_Random_Pointer_-_复制带随机指针的链表">Copy List with Random Pointer - 复制带随机指针的链表</h3><p><strong>Description</strong>: A linked]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Eugene's Blog]]></title>
  <subtitle><![CDATA[成长之旅]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://eugeneyang.com/"/>
  <updated>2016-03-30T05:16:40.011Z</updated>
  <id>http://eugeneyang.com/</id>
  
  <author>
    <name><![CDATA[Jian Yang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Number of Islands - 小岛个数]]></title>
    <link href="http://eugeneyang.com/2016/03/30/Number%20of%20Islands%20-%20%E5%B0%8F%E5%B2%9B%E4%B8%AA%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/03/30/Number of Islands - 小岛个数/</id>
    <published>2016-03-30T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:40.011Z</updated>
    <content type="html"><![CDATA[<h3 id="Number_of_Islands_-_小岛个数">Number of Islands - 小岛个数</h3><p><strong>Description</strong>: Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>原题链接：<a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="external">https://leetcode.com/problems/number-of-islands/</a></p>
<p>思路：遍历数组，搜到小岛则按上下左右扩展进行递归搜索，搜过的点标记为’2’。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOfIslands</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="string">'2'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j]==<span class="string">'1'</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    findAnIsland(grid, i, j);</span><br><span class="line">                &#125; <span class="keyword">else</span> grid[i][j] = <span class="string">'2'</span>; <span class="comment">//searched</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findAnIsland</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y]!=<span class="string">'1'</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[x][y] = <span class="string">'2'</span>; <span class="comment">//searched</span></span><br><span class="line">        <span class="keyword">if</span> (x-<span class="number">1</span>&gt;=<span class="number">0</span>) findAnIsland(grid, x-<span class="number">1</span>, y);    <span class="comment">//上</span></span><br><span class="line">        <span class="keyword">if</span> (x+<span class="number">1</span>&lt;grid.length) findAnIsland(grid, x+<span class="number">1</span>, y);    <span class="comment">//下</span></span><br><span class="line">        <span class="keyword">if</span> (y-<span class="number">1</span>&gt;=<span class="number">0</span>) findAnIsland(grid, x, y-<span class="number">1</span>); <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (y+<span class="number">1</span>&lt;grid[<span class="number">0</span>].length) findAnIsland(grid, x, y+<span class="number">1</span>); <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Number_of_Islands_-_小岛个数">Number of Islands - 小岛个数</h3><p><strong>Description</strong>: Given a 2d grid map of ‘1’s (land) and ‘0’s ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binary Tree Right Side View - 二叉树右视图]]></title>
    <link href="http://eugeneyang.com/2016/03/29/Binary%20Tree%20Right%20Side%20View%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <id>http://eugeneyang.com/2016/03/29/Binary Tree Right Side View - 二叉树右视图/</id>
    <published>2016-03-29T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:40.009Z</updated>
    <content type="html"><![CDATA[<h3 id="Binary_Tree_Right_Side_View_-_二叉树右视图">Binary Tree Right Side View - 二叉树右视图</h3><p><strong>Description</strong>: Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p>原题链接：<a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank" rel="external">https://leetcode.com/problems/binary-tree-right-side-view/</a></p>
<p>思路：层次遍历取最后一个元素。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeRightSideView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; qNext = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            TreeNode n = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (n.left!=<span class="keyword">null</span>) qNext.offer(n.left);</span><br><span class="line">            <span class="keyword">if</span> (n.right!=<span class="keyword">null</span>) qNext.offer(n.right);</span><br><span class="line">            <span class="keyword">if</span> (q.isEmpty())&#123;</span><br><span class="line">                result.add(n.val);</span><br><span class="line">                <span class="keyword">if</span> (!qNext.isEmpty())&#123;</span><br><span class="line">                    q = <span class="keyword">new</span> LinkedList&lt;&gt;(qNext);</span><br><span class="line">                    qNext = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Binary_Tree_Right_Side_View_-_二叉树右视图">Binary Tree Right Side View - 二叉树右视图</h3><p><strong>Description</strong>: Given a binary tree,]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[House Robber - 房屋偷窃]]></title>
    <link href="http://eugeneyang.com/2016/03/28/House%20Robber%20-%20%E6%88%BF%E5%B1%8B%E5%81%B7%E7%AA%83/"/>
    <id>http://eugeneyang.com/2016/03/28/House Robber - 房屋偷窃/</id>
    <published>2016-03-28T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:40.005Z</updated>
    <content type="html"><![CDATA[<h3 id="House_Robber_-_房屋偷窃">House Robber - 房屋偷窃</h3><p><strong>Description</strong>: You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.<br> Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>思路：DP, s(i)=max{s(i-1), s(i-2)+nums(i)}</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobber</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//DP, s(i)=max&#123;s(i-1), s(i-2)+nums(i)&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        s[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        s[<span class="number">1</span>] = Math.max(s[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">2</span>) <span class="keyword">return</span> s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            s[i] = Math.max(s[i-<span class="number">1</span>], s[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="House_Robber_-_房屋偷窃">House Robber - 房屋偷窃</h3><p><strong>Description</strong>: You are a professional robber planning to rob houses a]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Number of 1 Bits - 1位的个数]]></title>
    <link href="http://eugeneyang.com/2016/03/28/Number%20of%201%20Bits%20-%201%E4%BD%8D%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/03/28/Number of 1 Bits - 1位的个数/</id>
    <published>2016-03-28T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:40.007Z</updated>
    <content type="html"><![CDATA[<h3 id="Number_of_1_Bits_-_1位的个数">Number of 1 Bits - 1位的个数</h3><p><strong>Description</strong>: Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).<br> For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOf1Bits</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (((n&gt;&gt;i)&amp;<span class="number">1</span>)==<span class="number">1</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Number_of_1_Bits_-_1位的个数">Number of 1 Bits - 1位的个数</h3><p><strong>Description</strong>: Write a function that takes an unsigned inte]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Reverse Bits - 位逆转]]></title>
    <link href="http://eugeneyang.com/2016/03/27/Reverse%20Bits%20-%20%E4%BD%8D%E9%80%86%E8%BD%AC/"/>
    <id>http://eugeneyang.com/2016/03/27/Reverse Bits - 位逆转/</id>
    <published>2016-03-27T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:40.002Z</updated>
    <content type="html"><![CDATA[<h3 id="Reverse_Bits_-_位逆转">Reverse Bits - 位逆转</h3><p><strong>Description</strong>: Reverse bits of a given 32 bits unsigned integer.<br> For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseBits</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++)</span><br><span class="line">            n = swapBit(n, i, <span class="number">32</span>-i-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">swapBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = (n&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = (n&gt;&gt;j)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((a^b)!=<span class="number">0</span>) <span class="keyword">return</span> n ^= (<span class="number">1</span>&lt;&lt;i)|(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Reverse_Bits_-_位逆转">Reverse Bits - 位逆转</h3><p><strong>Description</strong>: Reverse bits of a given 32 bits unsigned integer.<br> Fo]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rotate Array - 旋转数组]]></title>
    <link href="http://eugeneyang.com/2016/03/26/Rotate%20Array%20-%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://eugeneyang.com/2016/03/26/Rotate Array - 旋转数组/</id>
    <published>2016-03-26T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:39.999Z</updated>
    <content type="html"><![CDATA[<h3 id="Rotate_Array_-_旋转数组">Rotate Array - 旋转数组</h3><p><strong>Description</strong>: Rotate an array of n elements to the right by k steps.<br> For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].<br> Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.<br> Hint: Could you do it in-place with O(1) extra space?</p>
<p>思路：一、O(1) space and in O(n) time.<br>Assuming we are given {1,2,3,4,5,6} and order 2. The basic idea is:</p>
<pre><code><span class="number">1.</span> Divide the <span class="built_in">array</span> two parts: <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> and <span class="number">5</span>, <span class="number">6</span>
<span class="number">2.</span> Rotate first part: <span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>
<span class="number">3.</span> Rotate second part: <span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">5</span>
<span class="number">4.</span> Rotate the whole <span class="built_in">array</span>: <span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>
</code></pre><p>  二、数组复制<br>  三、冒泡法</p>
<p>参考链接：<a href="http://www.programcreek.com/2015/03/rotate-array-in-java/" target="_blank" rel="external">http://www.programcreek.com/2015/03/rotate-array-in-java/</a></p>
<p>完整的java代码如下（法一）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * O(1) space and in O(n) time.</span><br><span class="line">     Assuming we are given &#123;1,2,3,4,5,6&#125; and order 2. The basic idea is:</span><br><span class="line">     1. Divide the array two parts: 1,2,3,4 and 5, 6</span><br><span class="line">     2. Rotate first part: 4,3,2,1,5,6</span><br><span class="line">     3. Rotate second part: 4,3,2,1,6,5</span><br><span class="line">     4. Rotate the whole array: 5,6,1,2,3,4</span><br><span class="line">     http://www.programcreek.com/2015/03/rotate-array-in-java/</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@param</span> k</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k%nums.length;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length-k);</span><br><span class="line">        reverse(nums, nums.length-k, nums.length);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = start+end;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;l/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[l-i-<span class="number">1</span>];</span><br><span class="line">            nums[l-i-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Rotate_Array_-_旋转数组">Rotate Array - 旋转数组</h3><p><strong>Description</strong>: Rotate an array of n elements to the right by k steps.]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock IV - 买卖股票的最佳时机IV]]></title>
    <link href="http://eugeneyang.com/2016/03/25/Best%20Time%20to%20Buy%20and%20Sell%20Stock%20IV%20-%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/"/>
    <id>http://eugeneyang.com/2016/03/25/Best Time to Buy and Sell Stock IV - 买卖股票的最佳时机IV/</id>
    <published>2016-03-25T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:39.995Z</updated>
    <content type="html"><![CDATA[<h3 id="Best_Time_to_Buy_and_Sell_Stock_IV_-_买卖股票的最佳时机IV">Best Time to Buy and Sell Stock IV - 买卖股票的最佳时机IV</h3><p><strong>Description</strong>: Say you have an array for which the ith element is the price of a given stock on day i.<br> Design an algorithm to find the maximum profit. You may complete at most k transactions.<br> Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>思路：二维DP(可简化为一维):<br>     错误的递推式:profit[i][j] = max(profit[i – 1][j], profit[i – 1][j – 1] + diff)<br>     注意两次交易合并的情况,于是引入局部与全局变量,定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润,<br>     其中局部最优值是比较前一天并少交易一次的全局最优加上大于0的差值，和前一天的局部最优加上差值后相比，两者之中取较大值，而全局最优比较局部最优和前一天的全局最优。<br>     local[i][j] = max(global[i-1][j-1] + max(diff,0), local[i-1][j]+diff)<br>     global[i][j] = max(local[i][j], global[i-1][j])<br>     另外,当k大于天数时，其实就退化成Best Time to Buy and Sell Stock II,就不能用DP来做了.</p>
<p>参考链接：<a href="http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html" target="_blank" rel="external">http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimeToBuyAndSellStockIV</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TODO 重温</span></span><br><span class="line">    <span class="comment">/**http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html</span><br><span class="line">     * 二维DP(可简化为一维):</span><br><span class="line">     错误的递推式:profit[i][j] = max(profit[i – 1][j], profit[i – 1][j – 1] + diff)</span><br><span class="line">     注意两次交易合并的情况,于是引入局部与全局变量,定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润,</span><br><span class="line">     其中局部最优值是比较前一天并少交易一次的全局最优加上大于0的差值，和前一天的局部最优加上差值后相比，</span><br><span class="line">     两者之中取较大值，而全局最优比较局部最优和前一天的全局最优。</span><br><span class="line">     local[i][j] = max(global[i-1][j-1] + max(diff,0), local[i-1][j]+diff)</span><br><span class="line">     global[i][j] = max(local[i][j], global[i-1][j])</span><br><span class="line">     另外,当k大于天数时，其实就退化成Best Time to Buy and Sell Stock II,就不能用DP来做了.</span><br><span class="line">     * <span class="doctag">@param</span> k</span><br><span class="line">     * <span class="doctag">@param</span> prices</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> days = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= days) <span class="keyword">return</span> maxProfit(prices);</span><br><span class="line">        <span class="keyword">int</span>[][] local = <span class="keyword">new</span> <span class="keyword">int</span>[days][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] global = <span class="keyword">new</span> <span class="keyword">int</span>[days][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; days ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                local[i][j] = Math.max(global[i-<span class="number">1</span>][j-<span class="number">1</span>]+Math.max(diff, <span class="number">0</span>), local[i-<span class="number">1</span>][j]+diff);</span><br><span class="line">                global[i][j] = Math.max(global[i-<span class="number">1</span>][j], local[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> global[days - <span class="number">1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退化成Best Time to Buy and Sell Stock II</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                maxProfit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Best_Time_to_Buy_and_Sell_Stock_IV_-_买卖股票的最佳时机IV">Best Time to Buy and Sell Stock IV - 买卖股票的最佳时机IV</h3><p><strong>Description</stron]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Repeated DNA Sequences - 重复DNA序列]]></title>
    <link href="http://eugeneyang.com/2016/03/24/Repeated%20DNA%20Sequences%20-%20%E9%87%8D%E5%A4%8DDNA%E5%BA%8F%E5%88%97/"/>
    <id>http://eugeneyang.com/2016/03/24/Repeated DNA Sequences - 重复DNA序列/</id>
    <published>2016-03-24T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:39.993Z</updated>
    <content type="html"><![CDATA[<h3 id="Repeated_DNA_Sequences_-_重复DNA序列">Repeated DNA Sequences - 重复DNA序列</h3><p><strong>Description</strong>: All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.<br> Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.<br> For example, Given s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”,<br> Return: [“AAAAACCCCC”, “CCCCCAAAAA”].</p>
<p>思路：滑动窗口。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatedDNASequences</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s.length()&lt;<span class="number">10</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=s.length()-<span class="number">10</span>; i++)&#123;</span><br><span class="line">            String window = s.substring(i, i+<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(window)) map.put(window, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> c = map.get(window);</span><br><span class="line">                <span class="keyword">if</span> (c==<span class="number">1</span>) result.add(window);</span><br><span class="line">                map.put(window, c+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Repeated_DNA_Sequences_-_重复DNA序列">Repeated DNA Sequences - 重复DNA序列</h3><p><strong>Description</strong>: All DNA is composed of a ser]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Largest Number - 最大数]]></title>
    <link href="http://eugeneyang.com/2016/03/23/Largest%20Number%20-%20%E6%9C%80%E5%A4%A7%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/03/23/Largest Number - 最大数/</id>
    <published>2016-03-23T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:39.990Z</updated>
    <content type="html"><![CDATA[<h3 id="Largest_Number_-_最大数">Largest Number - 最大数</h3><p><strong>Description</strong>: Given a list of non negative integers, arrange them such that they form the largest number.<br> For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.<br> Note: The result may be very large, so you need to return a string instead of an integer.</p>
<p>思路：拼接待比较的两个数o1与o2，s1=o1+o2，s2=o2+o1，从s1、s2的最高位开始比较。<br>注意用例[0, 0]返回“0”，而不是“00”。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargestNumber</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拼接待比较的两个数o1与o2，s1=o1+o2，s2=o2+o1，从s1、s2的最高位开始比较。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">1</span>) <span class="keyword">return</span> String.valueOf(nums[<span class="number">0</span>]);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) list.add(String.valueOf(i));</span><br><span class="line">        list.sort(<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;    <span class="comment">//升序</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">char</span>[] chars1 = (o1+o2).toCharArray();</span><br><span class="line">                <span class="keyword">char</span>[] chars2 = (o2+o1).toCharArray();</span><br><span class="line">                <span class="keyword">int</span> len = chars1.length;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (chars1[i]&gt;chars2[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (chars1[i]&lt;chars2[i]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=list.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) builder.append(list.get(i));   <span class="comment">//降序</span></span><br><span class="line">        String result = builder.toString();</span><br><span class="line">        <span class="keyword">if</span> (result.charAt(<span class="number">0</span>)==<span class="string">'0'</span>) <span class="keyword">return</span> <span class="string">"0"</span>;  <span class="comment">//用例[0, 0]</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Largest_Number_-_最大数">Largest Number - 最大数</h3><p><strong>Description</strong>: Given a list of non negative integers, arrange them ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Dungeon Game - 地牢游戏]]></title>
    <link href="http://eugeneyang.com/2016/03/22/Dungeon%20Game%20-%20%E5%9C%B0%E7%89%A2%E6%B8%B8%E6%88%8F/"/>
    <id>http://eugeneyang.com/2016/03/22/Dungeon Game - 地牢游戏/</id>
    <published>2016-03-22T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:39.988Z</updated>
    <content type="html"><![CDATA[<h3 id="Dungeon_Game_-_地牢游戏">Dungeon Game - 地牢游戏</h3><p><strong>Description</strong>: 原题链接 <a href="https://leetcode.com/problems/dungeon-game/" target="_blank" rel="external">https://leetcode.com/problems/dungeon-game/</a></p>
<p>思路：DP:用hp[i,j]表示进入[i,j]前所需的最小生命值,<br>     有hp[i,j] = min{hp[i+1,j]-dungeon[i,j], hp[i,j+1]-dungeon[i,j]},大括号内的两个值均需不小于零.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DungeonGame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * DP:用hp[i,j]表示进入[i,j]前所需的最小生命值,</span><br><span class="line">     有hp[i,j] = min&#123;hp[i+1,j]-dungeon[i,j], hp[i,j+1]-dungeon[i,j]&#125;,大括号内的两个值均需不小于零.</span><br><span class="line">     * <span class="doctag">@param</span> dungeon</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">//另一种风格</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] hp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        hp[m-<span class="number">1</span>][n-<span class="number">1</span>] = <span class="number">1</span>-dungeon[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (hp[m-<span class="number">1</span>][n-<span class="number">1</span>]&lt;<span class="number">1</span>) hp[m-<span class="number">1</span>][n-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=m-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            hp[i][n-<span class="number">1</span>] = hp[i+<span class="number">1</span>][n-<span class="number">1</span>]-dungeon[i][n-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (hp[i][n-<span class="number">1</span>]&lt;<span class="number">1</span>) hp[i][n-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=n-<span class="number">2</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            hp[m-<span class="number">1</span>][j] = hp[m-<span class="number">1</span>][j+<span class="number">1</span>]-dungeon[m-<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (hp[m-<span class="number">1</span>][j]&lt;<span class="number">1</span>) hp[m-<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=m-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=n-<span class="number">2</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> down = hp[i+<span class="number">1</span>][j]-dungeon[i][j];</span><br><span class="line">                <span class="keyword">if</span> (down&lt;<span class="number">1</span>) down = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = hp[i][j+<span class="number">1</span>]-dungeon[i][j];</span><br><span class="line">                <span class="keyword">if</span> (right&lt;<span class="number">1</span>) right = <span class="number">1</span>;</span><br><span class="line">                hp[i][j] = Math.min(down, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//OJ速度更快</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP1</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] hp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) hp[i][n] = <span class="number">9999</span>;    <span class="comment">//TODO 不能用Integer.MAX,否则溢出为负数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) hp[m][j] = <span class="number">9999</span>;</span><br><span class="line">        hp[m-<span class="number">1</span>][n] = <span class="number">1</span>; hp[m][n-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=m-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=n-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> down = hp[i+<span class="number">1</span>][j]-dungeon[i][j];</span><br><span class="line">                <span class="keyword">if</span> (down&lt;<span class="number">1</span>) down = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = hp[i][j+<span class="number">1</span>]-dungeon[i][j];</span><br><span class="line">                <span class="keyword">if</span> (right&lt;<span class="number">1</span>) right = <span class="number">1</span>;</span><br><span class="line">                hp[i][j] = Math.min(down, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Dungeon_Game_-_地牢游戏">Dungeon Game - 地牢游戏</h3><p><strong>Description</strong>: 原题链接 <a href="https://leetcode.com/problems/dungeon-ga]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binary Search Tree Iterator - 二叉查找树迭代器]]></title>
    <link href="http://eugeneyang.com/2016/03/21/Binary%20Search%20Tree%20Iterator%20-%20%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://eugeneyang.com/2016/03/21/Binary Search Tree Iterator - 二叉查找树迭代器/</id>
    <published>2016-03-21T12:44:47.000Z</published>
    <updated>2016-03-30T05:16:39.986Z</updated>
    <content type="html"><![CDATA[<h3 id="Binary_Search_Tree_Iterator_-_二叉查找树迭代器">Binary Search Tree Iterator - 二叉查找树迭代器</h3><p><strong>Description</strong>: Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.<br> Calling next() will return the next smallest number in the BST.<br> Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p>
<p>思路：从根节点开始入栈，只要存在左节点就一直入栈;不存在左节点就出栈访问节点值，然后继续遍历出栈那个节点的右节点。<br>注意题目要求空间复杂度为O(h)，栈内存的数据随next()调用而发生动态变化。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空间复杂度O(h)</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TreeNode&gt; stack = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//从根节点开始入栈，只要存在左节点就一直入栈;</span></span><br><span class="line">    <span class="comment">//不存在左节点就出栈访问节点值，然后继续遍历出栈那个节点的右节点。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> result = node.val;</span><br><span class="line">        <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">            <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Binary_Search_Tree_Iterator_-_二叉查找树迭代器">Binary Search Tree Iterator - 二叉查找树迭代器</h3><p><strong>Description</strong>: Implement an ite]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Factorial Trailing Zeroes - 阶乘结果末尾为零的个数]]></title>
    <link href="http://eugeneyang.com/2016/03/20/Factorial%20Trailing%20Zeroes%20-%20%E9%98%B6%E4%B9%98%E7%BB%93%E6%9E%9C%E6%9C%AB%E5%B0%BE%E4%B8%BA%E9%9B%B6%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/03/20/Factorial Trailing Zeroes - 阶乘结果末尾为零的个数/</id>
    <published>2016-03-20T12:44:47.000Z</published>
    <updated>2016-03-20T12:19:00.901Z</updated>
    <content type="html"><![CDATA[<h3 id="Factorial_Trailing_Zeroes_-_阶乘结果末尾为零的个数">Factorial Trailing Zeroes - 阶乘结果末尾为零的个数</h3><p><strong>Description</strong>: Given an integer n, return the number of trailing zeroes in n!.<br> Note: Your solution should be in logarithmic time complexity.</p>
<p>思路：1. 先求阶乘再统计末尾为零的个数，但是输入值大的时候会栈溢出。<br>2.需要统计阶乘质因子的(2,5)对的个数，因为2×5=10.很容易观察到质因子中2的个数总是大于等于5的个数,因此只要计数5的个数就可以了。<br>     一个简单的方法是计算floor(n/5)。例如，7!有一个5，10!有两个5。除此之外，还有一件事情要考虑,诸如25，125之类的数字有不止一个5。<br>     解法就是对n/5+n/25+n/125+…进行求和，当n小于分母的时候停止。这样的话在计算5^2 的时候，能被25整除的数里面的两个5，其中一个已经在5^1 中计算过了,所以5^2直接加到count上。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactorialTrailingZeroes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**http://www.danielbit.com/blog/puzzle/leetcode/leetcode-factorial-trailing-zeroes</span><br><span class="line">     * 需要统计阶乘质因子的(2,5)对的个数，因为2×5=10.很容易观察到质因子中2的个数总是大于等于5的个数,因此只要计数5的个数就可以了。</span><br><span class="line">     一个简单的方法是计算floor(n/5)。例如，7!有一个5，10!有两个5。</span><br><span class="line">     除此之外，还有一件事情要考虑,诸如25，125之类的数字有不止一个5。</span><br><span class="line">     解法就是对n/5+n/25+n/125+…进行求和，当n小于分母的时候停止。</span><br><span class="line">     这样的话在计算5^2的时候，能被25整除的数里面的两个5，其中一个已经在5^1中计算过了,所以5^2直接加到count上。</span><br><span class="line">     * <span class="doctag">@param</span> n</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">5</span>; n/i &gt;= <span class="number">1</span>; i *= <span class="number">5</span>) &#123;</span><br><span class="line">            count += n/i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于大的输入值会栈溢出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(factorial(n));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=s.length()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==<span class="string">'0'</span>) count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> factorial(n-<span class="number">1</span>)*n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Factorial_Trailing_Zeroes_-_阶乘结果末尾为零的个数">Factorial Trailing Zeroes - 阶乘结果末尾为零的个数</h3><p><strong>Description</strong>: Given an integ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Excel Sheet Column Title - Excel表单列标题转换]]></title>
    <link href="http://eugeneyang.com/2016/03/19/Excel%20Sheet%20Column%20Title%20-%20Excel%E8%A1%A8%E5%8D%95%E5%88%97%E6%A0%87%E9%A2%98%E8%BD%AC%E6%8D%A2/"/>
    <id>http://eugeneyang.com/2016/03/19/Excel Sheet Column Title - Excel表单列标题转换/</id>
    <published>2016-03-19T12:44:47.000Z</published>
    <updated>2016-03-20T12:19:00.896Z</updated>
    <content type="html"><![CDATA[<h3 id="Excel_Sheet_Column_Title_-_Excel表单列标题转换">Excel Sheet Column Title - Excel表单列标题转换</h3><p><strong>Description</strong>: Given a positive integer, return its corresponding column title as appear in an Excel sheet.<br> For example:<br> 1 -&gt; A<br> 2 -&gt; B<br> 3 -&gt; C<br> …<br> 26 -&gt; Z<br> 27 -&gt; AA<br> 28 -&gt; AB</p>
<p>思路：利用循环求余和商。注意标号从1开始，且结果要逆序。</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/03/leetcode-excel-sheet-column-title-java/" target="_blank" rel="external">http://www.programcreek.com/2014/03/leetcode-excel-sheet-column-title-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelSheetColumnTitle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> ExcelSheetColumnTitle().convertToTitle(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http://www.programcreek.com/2014/03/leetcode-excel-sheet-column-title-java/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n--;    <span class="comment">//TODO 关键点,因为从1开始</span></span><br><span class="line">            <span class="keyword">char</span> ch = (<span class="keyword">char</span>) (n % <span class="number">26</span> + <span class="string">'A'</span>);</span><br><span class="line">            sb.append(ch);</span><br><span class="line">            n /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Excel_Sheet_Column_Title_-_Excel表单列标题转换">Excel Sheet Column Title - Excel表单列标题转换</h3><p><strong>Description</strong>: Given a positi]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Excel Sheet Column Number - Excel表单列序号转换]]></title>
    <link href="http://eugeneyang.com/2016/03/19/Excel%20Sheet%20Column%20Number%20-%20Excel%E8%A1%A8%E5%8D%95%E5%88%97%E5%BA%8F%E5%8F%B7%E8%BD%AC%E6%8D%A2/"/>
    <id>http://eugeneyang.com/2016/03/19/Excel Sheet Column Number - Excel表单列序号转换/</id>
    <published>2016-03-19T12:44:47.000Z</published>
    <updated>2016-03-20T12:19:00.894Z</updated>
    <content type="html"><![CDATA[<h3 id="Excel_Sheet_Column_Number_-_Excel表单列序号转换">Excel Sheet Column Number - Excel表单列序号转换</h3><p><strong>Description</strong>: Related to question Excel Sheet Column Title<br> Given a column title as appear in an Excel sheet, return its corresponding column number.<br> For example:<br> A -&gt; 1<br> B -&gt; 2<br> C -&gt; 3<br> …<br> Z -&gt; 26<br> AA -&gt; 27<br> AB -&gt; 28</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelSheetColumnNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> ExcelSheetColumnNumber().titleToNumber(<span class="string">"AA"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> StringBuilder(s).reverse().toString().toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;chars.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) n += (chars[i]-<span class="string">'A'</span>);</span><br><span class="line">            <span class="keyword">else</span> n += (chars[i]-<span class="string">'A'</span>+<span class="number">1</span>)*Math.pow(<span class="number">26</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Excel_Sheet_Column_Number_-_Excel表单列序号转换">Excel Sheet Column Number - Excel表单列序号转换</h3><p><strong>Description</strong>: Related to q]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Majority Element]]></title>
    <link href="http://eugeneyang.com/2016/03/19/Majority%20Element/"/>
    <id>http://eugeneyang.com/2016/03/19/Majority Element/</id>
    <published>2016-03-19T12:44:47.000Z</published>
    <updated>2016-03-20T12:19:00.899Z</updated>
    <content type="html"><![CDATA[<h3 id="Majority_Element">Majority Element</h3><p><strong>Description</strong>: Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.<br> You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>思路：1.先排序，O(nlog(n))<br>2.使用哈希表，O(n)<br>但是测试用例显示方法1速度更快。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MajorityElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//nlog(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length&lt;=<span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length&lt;=<span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> indice = nums.length/<span class="number">2</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(n)) map.put(n, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = map.get(n);</span><br><span class="line">                <span class="keyword">if</span> (temp+<span class="number">1</span>&gt;indice) <span class="keyword">return</span> n;</span><br><span class="line">                map.put(n, temp+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Majority_Element">Majority Element</h3><p><strong>Description</strong>: Given an array of size n, find the majority element. The maj]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Fraction to Recurring Decimal - 分数表示成循环小数]]></title>
    <link href="http://eugeneyang.com/2016/03/18/Fraction%20to%20Recurring%20Decimal%20-%20%E5%88%86%E6%95%B0%E8%A1%A8%E7%A4%BA%E6%88%90%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/03/18/Fraction to Recurring Decimal - 分数表示成循环小数/</id>
    <published>2016-03-18T12:44:47.000Z</published>
    <updated>2016-03-20T12:19:00.891Z</updated>
    <content type="html"><![CDATA[<h3 id="Fraction_to_Recurring_Decimal_-_分数表示成循环小数">Fraction to Recurring Decimal - 分数表示成循环小数</h3><p><strong>Description</strong>: Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.<br> If the fractional part is repeating, enclose the repeating part in parentheses.<br> For example,<br> Given numerator = 1, denominator = 2, return “0.5”.<br> Given numerator = 2, denominator = 1, return “2”.<br> Given numerator = 2, denominator = 3, return “0.(6)”.</p>
<p>思路：不断求余，利用哈希表找到重复模式。</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/03/leetcode-fraction-to-recurring-decimal-java/" target="_blank" rel="external">http://www.programcreek.com/2014/03/leetcode-fraction-to-recurring-decimal-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FractionToRecurringDecimal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> FractionToRecurringDecimal().fractionToDecimal(<span class="number">13</span>,<span class="number">97</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http://www.programcreek.com/2014/03/leetcode-fraction-to-recurring-decimal-java/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numerator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">if</span> (denominator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> ((numerator &lt; <span class="number">0</span>) ^ (denominator &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            builder.append(<span class="string">"-"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> num = numerator, den = denominator;</span><br><span class="line">        num = Math.abs(num);</span><br><span class="line">        den = Math.abs(den);</span><br><span class="line">        <span class="keyword">long</span> quitient = num / den;   <span class="comment">//商</span></span><br><span class="line">        builder.append(String.valueOf(quitient));</span><br><span class="line">        <span class="keyword">long</span> remainder = (num % den) * <span class="number">10</span>;  <span class="comment">//余数</span></span><br><span class="line">        <span class="keyword">if</span> (remainder == <span class="number">0</span>) <span class="keyword">return</span> builder.toString();</span><br><span class="line">        Map&lt;Long, Integer&gt; remainderToPos = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        builder.append(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">while</span> (remainder!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (remainderToPos.containsKey(remainder))&#123;</span><br><span class="line">                <span class="keyword">int</span> beg = remainderToPos.get(remainder);</span><br><span class="line">                String part1 = builder.substring(<span class="number">0</span>, beg);</span><br><span class="line">                String part2 = builder.substring(beg, builder.length());</span><br><span class="line">                <span class="keyword">return</span> part1 + <span class="string">"("</span> + part2 + <span class="string">")"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            remainderToPos.put(remainder, builder.length());</span><br><span class="line">            quitient = remainder/den;</span><br><span class="line">            builder.append(String.valueOf(quitient));</span><br><span class="line">            remainder = (remainder%den)*<span class="number">10</span>; <span class="comment">//TODO 注意要乘以10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Fraction_to_Recurring_Decimal_-_分数表示成循环小数">Fraction to Recurring Decimal - 分数表示成循环小数</h3><p><strong>Description</strong>: Given two ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Compare Version Numbers - 比较版本号]]></title>
    <link href="http://eugeneyang.com/2016/03/17/Compare%20Version%20Numbers%20-%20%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    <id>http://eugeneyang.com/2016/03/17/Compare Version Numbers - 比较版本号/</id>
    <published>2016-03-17T12:44:47.000Z</published>
    <updated>2016-03-20T12:19:00.889Z</updated>
    <content type="html"><![CDATA[<h3 id="Compare_Version_Numbers_-_比较版本号">Compare Version Numbers - 比较版本号</h3><p><strong>Description</strong>: Compare two version numbers version1 and version2.<br> If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0.<br> You may assume that the version strings are non-empty and contain only digits and the . character.<br> The . character does not represent a decimal point and is used to separate number sequences.<br> Here is an example of version numbers ordering:<br> 0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37</p>
<p>思路：边界条件易出错，注意以下用例：<br>1, 1.0<br>1, 1.0.1</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareVersionNumbers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        String[] ver1s = version1.split(<span class="string">"\\."</span>);</span><br><span class="line">        String[] ver2s = version2.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">int</span> len = Math.min(ver1s.length, ver2s.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = Integer.valueOf(ver1s[i]);</span><br><span class="line">            <span class="keyword">int</span> v2 = Integer.valueOf(ver2s[i]);</span><br><span class="line">            <span class="keyword">if</span> (v1&lt;v2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v1&gt;v2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ver1s.length&gt;ver2s.length) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=ver2s.length; i&lt;ver1s.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Integer.valueOf(ver1s[i])&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ver1s.length&lt;ver2s.length)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=ver1s.length; i&lt;ver2s.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Integer.valueOf(ver2s[i])&gt;<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Compare_Version_Numbers_-_比较版本号">Compare Version Numbers - 比较版本号</h3><p><strong>Description</strong>: Compare two version numbers ve]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maximum Gap - 最大间隔]]></title>
    <link href="http://eugeneyang.com/2016/03/16/Maximum%20Gap%20-%20%E6%9C%80%E5%A4%A7%E9%97%B4%E9%9A%94/"/>
    <id>http://eugeneyang.com/2016/03/16/Maximum Gap - 最大间隔/</id>
    <published>2016-03-16T12:44:47.000Z</published>
    <updated>2016-03-20T12:19:00.886Z</updated>
    <content type="html"><![CDATA[<h3 id="Maximum_Gap_-_最大间隔">Maximum Gap - 最大间隔</h3><p><strong>Description</strong>: Given an unsorted array, find the maximum difference between the successive elements in its sorted form.<br> Try to solve it in linear time/space.<br> Return 0 if the array contains less than 2 elements.<br> You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p>
<p>思路：桶排序:区间计算interval = num.length / (max - min),桶索引0~n。索引计算index = (int) ((nums[i] - min) * interval)。</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/03/leetcode-maximum-gap-java/" target="_blank" rel="external">http://www.programcreek.com/2014/03/leetcode-maximum-gap-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumGap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bucket</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low;</span><br><span class="line">        <span class="keyword">int</span> high;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Bucket</span><span class="params">()</span></span>&#123;</span><br><span class="line">            low = -<span class="number">1</span>;</span><br><span class="line">            high = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**http://www.programcreek.com/2014/03/leetcode-maximum-gap-java/</span><br><span class="line">     * 桶排序:区间计算interval = num.length / (max - min),桶索引0~n.</span><br><span class="line">     索引计算index = (int) ((nums[i] - min) * interval)</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>], max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">            min = Math.min(min, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Bucket[] buckets = <span class="keyword">new</span> Bucket[nums.length+<span class="number">1</span>]; <span class="comment">//project to (0 - n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buckets.length; i++)&#123;</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> Bucket();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> interval = (<span class="keyword">double</span>)nums.length / (max - min);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>) ((nums[i] - min) * interval);</span><br><span class="line">            <span class="keyword">if</span>(buckets[index].low == -<span class="number">1</span>)&#123;</span><br><span class="line">                buckets[index].low = nums[i];</span><br><span class="line">                buckets[index].high = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                buckets[index].low = Math.min(buckets[index].low, nums[i]);</span><br><span class="line">                buckets[index].high = Math.max(buckets[index].high, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxGap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = buckets[<span class="number">0</span>].high;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;buckets.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[i].low != -<span class="number">1</span>)&#123;</span><br><span class="line">                maxGap = Math.max(maxGap, buckets[i].low-prev);</span><br><span class="line">                prev = buckets[i].high;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxGap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Maximum_Gap_-_最大间隔">Maximum Gap - 最大间隔</h3><p><strong>Description</strong>: Given an unsorted array, find the maximum difference bet]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Find Peak Element - 找峰值]]></title>
    <link href="http://eugeneyang.com/2016/03/15/Find%20Peak%20Element%20-%20%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <id>http://eugeneyang.com/2016/03/15/Find Peak Element - 找峰值/</id>
    <published>2016-03-15T12:44:47.000Z</published>
    <updated>2016-03-15T12:28:06.919Z</updated>
    <content type="html"><![CDATA[<h3 id="Find_Peak_Element_-_找峰值">Find Peak Element - 找峰值</h3><p><strong>Description</strong>: A peak element is an element that is greater than its neighbors.<br> Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.<br> The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.<br> You may imagine that num[-1] = num[n] = -∞.<br> For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>
<p> Note: Your solution should be in logarithmic complexity.</p>
<p>思路：二分法搜索</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindPeakElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分法搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid-<span class="number">1</span>&lt;=-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid]&gt;nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid+<span class="number">1</span>&gt;=nums.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid]&gt;nums[mid-<span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;nums[mid-<span class="number">1</span>] &amp;&amp; nums[mid]&gt;nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;=nums[mid-<span class="number">1</span>]) r = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Find_Peak_Element_-_找峰值">Find Peak Element - 找峰值</h3><p><strong>Description</strong>: A peak element is an element that is greater t]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Intersection of Two Linked Lists - 链表交叉节点]]></title>
    <link href="http://eugeneyang.com/2016/03/14/Intersection%20of%20Two%20Linked%20Lists%20-%20%E9%93%BE%E8%A1%A8%E4%BA%A4%E5%8F%89%E8%8A%82%E7%82%B9/"/>
    <id>http://eugeneyang.com/2016/03/14/Intersection of Two Linked Lists - 链表交叉节点/</id>
    <published>2016-03-14T12:44:47.000Z</published>
    <updated>2016-03-15T12:28:06.917Z</updated>
    <content type="html"><![CDATA[<h3 id="Intersection_of_Two_Linked_Lists_-_链表交叉节点">Intersection of Two Linked Lists - 链表交叉节点</h3><p><strong>Description</strong>: Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>Your code should preferably run in O(n) time and use only O(1) memory.<br> The linked lists must retain their original structure after the function returns.</p>
<p>思路：分别获取两链表长度并求差,长链表先跳过差数个节点,再同时遍历直到找到相同节点.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntersectionOfTwoLinkedLists</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别获取两链表长度并求差,长链表先跳过差数个节点,再同时遍历直到找到相同节点.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA==<span class="keyword">null</span> || headB==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (headA==headB) <span class="keyword">return</span> headA;</span><br><span class="line">        <span class="keyword">int</span> lenA = <span class="number">1</span>, lenB = <span class="number">1</span>;</span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pB.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = lenA-lenB;</span><br><span class="line">        <span class="keyword">int</span> diff = d&gt;=<span class="number">0</span> ? d : -d;</span><br><span class="line">        pA = headA; pB = headB;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (d&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;diff)&#123;</span><br><span class="line">                pA = pA.next;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;diff)&#123;</span><br><span class="line">                pB = pB.next;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pA!=<span class="keyword">null</span> &amp;&amp; pB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pA==pB) <span class="keyword">return</span> pA;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Intersection_of_Two_Linked_Lists_-_链表交叉节点">Intersection of Two Linked Lists - 链表交叉节点</h3><p><strong>Description</strong>: Write a pr]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

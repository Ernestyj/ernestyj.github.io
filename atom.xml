<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Eugene's Blog]]></title>
  <subtitle><![CDATA[成长之旅]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://eugeneyang.com/"/>
  <updated>2016-03-20T12:19:00.901Z</updated>
  <id>http://eugeneyang.com/</id>
  
  <author>
    <name><![CDATA[Jian Yang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Factorial Trailing Zeroes - 阶乘结果末尾为零的个数]]></title>
    <link href="http://eugeneyang.com/2016/03/20/Factorial%20Trailing%20Zeroes%20-%20%E9%98%B6%E4%B9%98%E7%BB%93%E6%9E%9C%E6%9C%AB%E5%B0%BE%E4%B8%BA%E9%9B%B6%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/03/20/Factorial Trailing Zeroes - 阶乘结果末尾为零的个数/</id>
    <published>2016-03-20T12:44:47.000Z</published>
    <updated>2016-03-20T12:19:00.901Z</updated>
    <content type="html"><![CDATA[<h3 id="Factorial_Trailing_Zeroes_-_阶乘结果末尾为零的个数">Factorial Trailing Zeroes - 阶乘结果末尾为零的个数</h3><p><strong>Description</strong>: Given an integer n, return the number of trailing zeroes in n!.<br> Note: Your solution should be in logarithmic time complexity.</p>
<p>思路：1. 先求阶乘再统计末尾为零的个数，但是输入值大的时候会栈溢出。<br>2.需要统计阶乘质因子的(2,5)对的个数，因为2×5=10.很容易观察到质因子中2的个数总是大于等于5的个数,因此只要计数5的个数就可以了。<br>     一个简单的方法是计算floor(n/5)。例如，7!有一个5，10!有两个5。除此之外，还有一件事情要考虑,诸如25，125之类的数字有不止一个5。<br>     解法就是对n/5+n/25+n/125+…进行求和，当n小于分母的时候停止。这样的话在计算5^2 的时候，能被25整除的数里面的两个5，其中一个已经在5^1 中计算过了,所以5^2直接加到count上。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactorialTrailingZeroes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**http://www.danielbit.com/blog/puzzle/leetcode/leetcode-factorial-trailing-zeroes</span><br><span class="line">     * 需要统计阶乘质因子的(2,5)对的个数，因为2×5=10.很容易观察到质因子中2的个数总是大于等于5的个数,因此只要计数5的个数就可以了。</span><br><span class="line">     一个简单的方法是计算floor(n/5)。例如，7!有一个5，10!有两个5。</span><br><span class="line">     除此之外，还有一件事情要考虑,诸如25，125之类的数字有不止一个5。</span><br><span class="line">     解法就是对n/5+n/25+n/125+…进行求和，当n小于分母的时候停止。</span><br><span class="line">     这样的话在计算5^2的时候，能被25整除的数里面的两个5，其中一个已经在5^1中计算过了,所以5^2直接加到count上。</span><br><span class="line">     * <span class="doctag">@param</span> n</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">5</span>; n/i &gt;= <span class="number">1</span>; i *= <span class="number">5</span>) &#123;</span><br><span class="line">            count += n/i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于大的输入值会栈溢出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(factorial(n));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=s.length()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==<span class="string">'0'</span>) count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> factorial(n-<span class="number">1</span>)*n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Factorial_Trailing_Zeroes_-_阶乘结果末尾为零的个数">Factorial Trailing Zeroes - 阶乘结果末尾为零的个数</h3><p><strong>Description</strong>: Given an integ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Excel Sheet Column Title - Excel表单列标题转换]]></title>
    <link href="http://eugeneyang.com/2016/03/19/Excel%20Sheet%20Column%20Title%20-%20Excel%E8%A1%A8%E5%8D%95%E5%88%97%E6%A0%87%E9%A2%98%E8%BD%AC%E6%8D%A2/"/>
    <id>http://eugeneyang.com/2016/03/19/Excel Sheet Column Title - Excel表单列标题转换/</id>
    <published>2016-03-19T12:44:47.000Z</published>
    <updated>2016-03-20T12:19:00.896Z</updated>
    <content type="html"><![CDATA[<h3 id="Excel_Sheet_Column_Title_-_Excel表单列标题转换">Excel Sheet Column Title - Excel表单列标题转换</h3><p><strong>Description</strong>: Given a positive integer, return its corresponding column title as appear in an Excel sheet.<br> For example:<br> 1 -&gt; A<br> 2 -&gt; B<br> 3 -&gt; C<br> …<br> 26 -&gt; Z<br> 27 -&gt; AA<br> 28 -&gt; AB</p>
<p>思路：利用循环求余和商。注意标号从1开始，且结果要逆序。</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/03/leetcode-excel-sheet-column-title-java/" target="_blank" rel="external">http://www.programcreek.com/2014/03/leetcode-excel-sheet-column-title-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelSheetColumnTitle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> ExcelSheetColumnTitle().convertToTitle(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http://www.programcreek.com/2014/03/leetcode-excel-sheet-column-title-java/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n--;    <span class="comment">//TODO 关键点,因为从1开始</span></span><br><span class="line">            <span class="keyword">char</span> ch = (<span class="keyword">char</span>) (n % <span class="number">26</span> + <span class="string">'A'</span>);</span><br><span class="line">            sb.append(ch);</span><br><span class="line">            n /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Excel_Sheet_Column_Title_-_Excel表单列标题转换">Excel Sheet Column Title - Excel表单列标题转换</h3><p><strong>Description</strong>: Given a positi]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Majority Element]]></title>
    <link href="http://eugeneyang.com/2016/03/19/Majority%20Element/"/>
    <id>http://eugeneyang.com/2016/03/19/Majority Element/</id>
    <published>2016-03-19T12:44:47.000Z</published>
    <updated>2016-03-20T12:19:00.899Z</updated>
    <content type="html"><![CDATA[<h3 id="Majority_Element">Majority Element</h3><p><strong>Description</strong>: Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.<br> You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>思路：1.先排序，O(nlog(n))<br>2.使用哈希表，O(n)<br>但是测试用例显示方法1速度更快。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MajorityElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//nlog(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length&lt;=<span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length&lt;=<span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> indice = nums.length/<span class="number">2</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(n)) map.put(n, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = map.get(n);</span><br><span class="line">                <span class="keyword">if</span> (temp+<span class="number">1</span>&gt;indice) <span class="keyword">return</span> n;</span><br><span class="line">                map.put(n, temp+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Majority_Element">Majority Element</h3><p><strong>Description</strong>: Given an array of size n, find the majority element. The maj]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Excel Sheet Column Number - Excel表单列序号转换]]></title>
    <link href="http://eugeneyang.com/2016/03/19/Excel%20Sheet%20Column%20Number%20-%20Excel%E8%A1%A8%E5%8D%95%E5%88%97%E5%BA%8F%E5%8F%B7%E8%BD%AC%E6%8D%A2/"/>
    <id>http://eugeneyang.com/2016/03/19/Excel Sheet Column Number - Excel表单列序号转换/</id>
    <published>2016-03-19T12:44:47.000Z</published>
    <updated>2016-03-20T12:19:00.894Z</updated>
    <content type="html"><![CDATA[<h3 id="Excel_Sheet_Column_Number_-_Excel表单列序号转换">Excel Sheet Column Number - Excel表单列序号转换</h3><p><strong>Description</strong>: Related to question Excel Sheet Column Title<br> Given a column title as appear in an Excel sheet, return its corresponding column number.<br> For example:<br> A -&gt; 1<br> B -&gt; 2<br> C -&gt; 3<br> …<br> Z -&gt; 26<br> AA -&gt; 27<br> AB -&gt; 28</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelSheetColumnNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> ExcelSheetColumnNumber().titleToNumber(<span class="string">"AA"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> StringBuilder(s).reverse().toString().toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;chars.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) n += (chars[i]-<span class="string">'A'</span>);</span><br><span class="line">            <span class="keyword">else</span> n += (chars[i]-<span class="string">'A'</span>+<span class="number">1</span>)*Math.pow(<span class="number">26</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Excel_Sheet_Column_Number_-_Excel表单列序号转换">Excel Sheet Column Number - Excel表单列序号转换</h3><p><strong>Description</strong>: Related to q]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Fraction to Recurring Decimal - 分数表示成循环小数]]></title>
    <link href="http://eugeneyang.com/2016/03/18/Fraction%20to%20Recurring%20Decimal%20-%20%E5%88%86%E6%95%B0%E8%A1%A8%E7%A4%BA%E6%88%90%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/03/18/Fraction to Recurring Decimal - 分数表示成循环小数/</id>
    <published>2016-03-18T12:44:47.000Z</published>
    <updated>2016-03-20T12:19:00.891Z</updated>
    <content type="html"><![CDATA[<h3 id="Fraction_to_Recurring_Decimal_-_分数表示成循环小数">Fraction to Recurring Decimal - 分数表示成循环小数</h3><p><strong>Description</strong>: Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.<br> If the fractional part is repeating, enclose the repeating part in parentheses.<br> For example,<br> Given numerator = 1, denominator = 2, return “0.5”.<br> Given numerator = 2, denominator = 1, return “2”.<br> Given numerator = 2, denominator = 3, return “0.(6)”.</p>
<p>思路：不断求余，利用哈希表找到重复模式。</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/03/leetcode-fraction-to-recurring-decimal-java/" target="_blank" rel="external">http://www.programcreek.com/2014/03/leetcode-fraction-to-recurring-decimal-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FractionToRecurringDecimal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> FractionToRecurringDecimal().fractionToDecimal(<span class="number">13</span>,<span class="number">97</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http://www.programcreek.com/2014/03/leetcode-fraction-to-recurring-decimal-java/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numerator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">if</span> (denominator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> ((numerator &lt; <span class="number">0</span>) ^ (denominator &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            builder.append(<span class="string">"-"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> num = numerator, den = denominator;</span><br><span class="line">        num = Math.abs(num);</span><br><span class="line">        den = Math.abs(den);</span><br><span class="line">        <span class="keyword">long</span> quitient = num / den;   <span class="comment">//商</span></span><br><span class="line">        builder.append(String.valueOf(quitient));</span><br><span class="line">        <span class="keyword">long</span> remainder = (num % den) * <span class="number">10</span>;  <span class="comment">//余数</span></span><br><span class="line">        <span class="keyword">if</span> (remainder == <span class="number">0</span>) <span class="keyword">return</span> builder.toString();</span><br><span class="line">        Map&lt;Long, Integer&gt; remainderToPos = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        builder.append(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">while</span> (remainder!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (remainderToPos.containsKey(remainder))&#123;</span><br><span class="line">                <span class="keyword">int</span> beg = remainderToPos.get(remainder);</span><br><span class="line">                String part1 = builder.substring(<span class="number">0</span>, beg);</span><br><span class="line">                String part2 = builder.substring(beg, builder.length());</span><br><span class="line">                <span class="keyword">return</span> part1 + <span class="string">"("</span> + part2 + <span class="string">")"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            remainderToPos.put(remainder, builder.length());</span><br><span class="line">            quitient = remainder/den;</span><br><span class="line">            builder.append(String.valueOf(quitient));</span><br><span class="line">            remainder = (remainder%den)*<span class="number">10</span>; <span class="comment">//TODO 注意要乘以10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Fraction_to_Recurring_Decimal_-_分数表示成循环小数">Fraction to Recurring Decimal - 分数表示成循环小数</h3><p><strong>Description</strong>: Given two ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Compare Version Numbers - 比较版本号]]></title>
    <link href="http://eugeneyang.com/2016/03/17/Compare%20Version%20Numbers%20-%20%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    <id>http://eugeneyang.com/2016/03/17/Compare Version Numbers - 比较版本号/</id>
    <published>2016-03-17T12:44:47.000Z</published>
    <updated>2016-03-20T12:19:00.889Z</updated>
    <content type="html"><![CDATA[<h3 id="Compare_Version_Numbers_-_比较版本号">Compare Version Numbers - 比较版本号</h3><p><strong>Description</strong>: Compare two version numbers version1 and version2.<br> If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0.<br> You may assume that the version strings are non-empty and contain only digits and the . character.<br> The . character does not represent a decimal point and is used to separate number sequences.<br> Here is an example of version numbers ordering:<br> 0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37</p>
<p>思路：边界条件易出错，注意以下用例：<br>1, 1.0<br>1, 1.0.1</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareVersionNumbers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        String[] ver1s = version1.split(<span class="string">"\\."</span>);</span><br><span class="line">        String[] ver2s = version2.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">int</span> len = Math.min(ver1s.length, ver2s.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = Integer.valueOf(ver1s[i]);</span><br><span class="line">            <span class="keyword">int</span> v2 = Integer.valueOf(ver2s[i]);</span><br><span class="line">            <span class="keyword">if</span> (v1&lt;v2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v1&gt;v2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ver1s.length&gt;ver2s.length) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=ver2s.length; i&lt;ver1s.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Integer.valueOf(ver1s[i])&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ver1s.length&lt;ver2s.length)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=ver1s.length; i&lt;ver2s.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Integer.valueOf(ver2s[i])&gt;<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Compare_Version_Numbers_-_比较版本号">Compare Version Numbers - 比较版本号</h3><p><strong>Description</strong>: Compare two version numbers ve]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maximum Gap - 最大间隔]]></title>
    <link href="http://eugeneyang.com/2016/03/16/Maximum%20Gap%20-%20%E6%9C%80%E5%A4%A7%E9%97%B4%E9%9A%94/"/>
    <id>http://eugeneyang.com/2016/03/16/Maximum Gap - 最大间隔/</id>
    <published>2016-03-16T12:44:47.000Z</published>
    <updated>2016-03-20T12:19:00.886Z</updated>
    <content type="html"><![CDATA[<h3 id="Maximum_Gap_-_最大间隔">Maximum Gap - 最大间隔</h3><p><strong>Description</strong>: Given an unsorted array, find the maximum difference between the successive elements in its sorted form.<br> Try to solve it in linear time/space.<br> Return 0 if the array contains less than 2 elements.<br> You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p>
<p>思路：桶排序:区间计算interval = num.length / (max - min),桶索引0~n。索引计算index = (int) ((nums[i] - min) * interval)。</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/03/leetcode-maximum-gap-java/" target="_blank" rel="external">http://www.programcreek.com/2014/03/leetcode-maximum-gap-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumGap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bucket</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low;</span><br><span class="line">        <span class="keyword">int</span> high;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Bucket</span><span class="params">()</span></span>&#123;</span><br><span class="line">            low = -<span class="number">1</span>;</span><br><span class="line">            high = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**http://www.programcreek.com/2014/03/leetcode-maximum-gap-java/</span><br><span class="line">     * 桶排序:区间计算interval = num.length / (max - min),桶索引0~n.</span><br><span class="line">     索引计算index = (int) ((nums[i] - min) * interval)</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>], max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">            min = Math.min(min, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Bucket[] buckets = <span class="keyword">new</span> Bucket[nums.length+<span class="number">1</span>]; <span class="comment">//project to (0 - n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buckets.length; i++)&#123;</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> Bucket();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> interval = (<span class="keyword">double</span>)nums.length / (max - min);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>) ((nums[i] - min) * interval);</span><br><span class="line">            <span class="keyword">if</span>(buckets[index].low == -<span class="number">1</span>)&#123;</span><br><span class="line">                buckets[index].low = nums[i];</span><br><span class="line">                buckets[index].high = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                buckets[index].low = Math.min(buckets[index].low, nums[i]);</span><br><span class="line">                buckets[index].high = Math.max(buckets[index].high, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxGap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = buckets[<span class="number">0</span>].high;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;buckets.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[i].low != -<span class="number">1</span>)&#123;</span><br><span class="line">                maxGap = Math.max(maxGap, buckets[i].low-prev);</span><br><span class="line">                prev = buckets[i].high;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxGap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Maximum_Gap_-_最大间隔">Maximum Gap - 最大间隔</h3><p><strong>Description</strong>: Given an unsorted array, find the maximum difference bet]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Find Peak Element - 找峰值]]></title>
    <link href="http://eugeneyang.com/2016/03/15/Find%20Peak%20Element%20-%20%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <id>http://eugeneyang.com/2016/03/15/Find Peak Element - 找峰值/</id>
    <published>2016-03-15T12:44:47.000Z</published>
    <updated>2016-03-15T12:28:06.919Z</updated>
    <content type="html"><![CDATA[<h3 id="Find_Peak_Element_-_找峰值">Find Peak Element - 找峰值</h3><p><strong>Description</strong>: A peak element is an element that is greater than its neighbors.<br> Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.<br> The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.<br> You may imagine that num[-1] = num[n] = -∞.<br> For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>
<p> Note: Your solution should be in logarithmic complexity.</p>
<p>思路：二分法搜索</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindPeakElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分法搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r) &#123;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid-<span class="number">1</span>&lt;=-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid]&gt;nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid+<span class="number">1</span>&gt;=nums.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid]&gt;nums[mid-<span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;nums[mid-<span class="number">1</span>] &amp;&amp; nums[mid]&gt;nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;=nums[mid-<span class="number">1</span>]) r = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Find_Peak_Element_-_找峰值">Find Peak Element - 找峰值</h3><p><strong>Description</strong>: A peak element is an element that is greater t]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Intersection of Two Linked Lists - 链表交叉节点]]></title>
    <link href="http://eugeneyang.com/2016/03/14/Intersection%20of%20Two%20Linked%20Lists%20-%20%E9%93%BE%E8%A1%A8%E4%BA%A4%E5%8F%89%E8%8A%82%E7%82%B9/"/>
    <id>http://eugeneyang.com/2016/03/14/Intersection of Two Linked Lists - 链表交叉节点/</id>
    <published>2016-03-14T12:44:47.000Z</published>
    <updated>2016-03-15T12:28:06.917Z</updated>
    <content type="html"><![CDATA[<h3 id="Intersection_of_Two_Linked_Lists_-_链表交叉节点">Intersection of Two Linked Lists - 链表交叉节点</h3><p><strong>Description</strong>: Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>Your code should preferably run in O(n) time and use only O(1) memory.<br> The linked lists must retain their original structure after the function returns.</p>
<p>思路：分别获取两链表长度并求差,长链表先跳过差数个节点,再同时遍历直到找到相同节点.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntersectionOfTwoLinkedLists</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别获取两链表长度并求差,长链表先跳过差数个节点,再同时遍历直到找到相同节点.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA==<span class="keyword">null</span> || headB==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (headA==headB) <span class="keyword">return</span> headA;</span><br><span class="line">        <span class="keyword">int</span> lenA = <span class="number">1</span>, lenB = <span class="number">1</span>;</span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pB.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = lenA-lenB;</span><br><span class="line">        <span class="keyword">int</span> diff = d&gt;=<span class="number">0</span> ? d : -d;</span><br><span class="line">        pA = headA; pB = headB;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (d&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;diff)&#123;</span><br><span class="line">                pA = pA.next;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;diff)&#123;</span><br><span class="line">                pB = pB.next;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pA!=<span class="keyword">null</span> &amp;&amp; pB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pA==pB) <span class="keyword">return</span> pA;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">            pB = pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Intersection_of_Two_Linked_Lists_-_链表交叉节点">Intersection of Two Linked Lists - 链表交叉节点</h3><p><strong>Description</strong>: Write a pr]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Min Stack - 最小栈]]></title>
    <link href="http://eugeneyang.com/2016/03/13/Min%20Stack%20-%20%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://eugeneyang.com/2016/03/13/Min Stack - 最小栈/</id>
    <published>2016-03-13T12:44:47.000Z</published>
    <updated>2016-03-15T12:28:06.914Z</updated>
    <content type="html"><![CDATA[<h3 id="Min_Stack_-_最小栈">Min Stack - 最小栈</h3><p><strong>Description</strong>: Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<p> push(x) – Push element x onto stack.<br> pop() – Removes the element on top of the stack.<br> top() – Get the top element.<br> getMin() – Retrieve the minimum element in the stack.</p>
<p>思路：采用单链表，每个节点引入min记录该节点以下的最小值。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//链表节点引入min记录该节点以下的最小值</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(<span class="keyword">int</span> x)&#123;</span><br><span class="line">            value = x;</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node top = <span class="keyword">new</span> Node(x);</span><br><span class="line">        <span class="keyword">if</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            top.next = head;</span><br><span class="line">            <span class="keyword">if</span> (head.min&lt;top.min) top.min = head.min;</span><br><span class="line">        &#125;</span><br><span class="line">        head = top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head!=<span class="keyword">null</span>) head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> head.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> head.min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Min_Stack_-_最小栈">Min Stack - 最小栈</h3><p><strong>Description</strong>: Design a stack that supports push, pop, top, and retrieving th]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Find Minimum in Rotated Sorted Array - 有序倒转数组的最小值]]></title>
    <link href="http://eugeneyang.com/2016/03/12/Find%20Minimum%20in%20Rotated%20Sorted%20Array%20-%20%E6%9C%89%E5%BA%8F%E5%80%92%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>http://eugeneyang.com/2016/03/12/Find Minimum in Rotated Sorted Array - 有序倒转数组的最小值/</id>
    <published>2016-03-12T12:44:47.000Z</published>
    <updated>2016-03-15T12:28:06.908Z</updated>
    <content type="html"><![CDATA[<h3 id="Find_Minimum_in_Rotated_Sorted_Array_-_有序倒转数组的最小值">Find Minimum in Rotated Sorted Array - 有序倒转数组的最小值</h3><p><strong>Description</strong>: Suppose a sorted array is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).<br> Find the minimum element.<br> You may assume no duplicate exists in the array.</p>
<p>思路：二分法。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMinimumInRotatedSortedArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (min&gt;nums[m]) min = nums[m];</span><br><span class="line">            <span class="keyword">if</span> (nums[m]&lt;nums[r]) &#123;</span><br><span class="line">                r = m-<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (min&gt;nums[r]) min = nums[r];</span><br><span class="line">                l = m+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Find_Minimum_in_Rotated_Sorted_Array_-_有序倒转数组的最小值">Find Minimum in Rotated Sorted Array - 有序倒转数组的最小值</h3><p><strong>Description</str]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Find Minimum in Rotated Sorted Array II - 有序倒转数组的最小值II]]></title>
    <link href="http://eugeneyang.com/2016/03/12/Find%20Minimum%20in%20Rotated%20Sorted%20Array%20II%20-%20%E6%9C%89%E5%BA%8F%E5%80%92%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/"/>
    <id>http://eugeneyang.com/2016/03/12/Find Minimum in Rotated Sorted Array II - 有序倒转数组的最小值II/</id>
    <published>2016-03-12T12:44:47.000Z</published>
    <updated>2016-03-15T12:28:06.911Z</updated>
    <content type="html"><![CDATA[<h3 id="Find_Minimum_in_Rotated_Sorted_Array_II_-_有序倒转数组的最小值II">Find Minimum in Rotated Sorted Array II - 有序倒转数组的最小值II</h3><p><strong>Description</strong>: Follow up for “Find Minimum in Rotated Sorted Array”:<br> What if duplicates are allowed?<br> Would this affect the run-time complexity? How and why?</p>
<p>思路：二分法。当nums[m] = nums[r]时，无法排除一半的序列，而只能排除掉nums[r],此时只能搜寻nums[l:r-1].</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMinimumInRotatedSortedArrayII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当nums[m] = nums[r]时，无法排除一半的序列，而只能排除掉nums[r],此时只能搜寻nums[l:r-1]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (min&gt;nums[m]) min = nums[m];</span><br><span class="line">            <span class="keyword">if</span> (nums[m]&lt;nums[r]) &#123;</span><br><span class="line">                r = m-<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m]&gt;nums[r])&#123;</span><br><span class="line">                <span class="keyword">if</span> (min&gt;nums[r]) min = nums[r];</span><br><span class="line">                l = m+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">//nums[m] == nums[r]时</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Find_Minimum_in_Rotated_Sorted_Array_II_-_有序倒转数组的最小值II">Find Minimum in Rotated Sorted Array II - 有序倒转数组的最小值II</h3><p><strong>Descri]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maximum Product Subarray - 最大乘积子串]]></title>
    <link href="http://eugeneyang.com/2016/03/11/Maximum%20Product%20Subarray%20-%20%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%E5%AD%90%E4%B8%B2/"/>
    <id>http://eugeneyang.com/2016/03/11/Maximum Product Subarray - 最大乘积子串/</id>
    <published>2016-03-11T12:44:47.000Z</published>
    <updated>2016-03-15T12:28:06.906Z</updated>
    <content type="html"><![CDATA[<h3 id="Maximum_Product_Subarray_-_最大乘积子串">Maximum Product Subarray - 最大乘积子串</h3><p><strong>Description</strong>: Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array [2,3,-2,4],<br> the contiguous subarray [2,3] has the largest product = 6.</p>
<p>思路：一维动态规划，考虑到乘积符号问题，同时记录最大值（正）与最小值（负），采用局部和全局变量追踪局部与最终结果。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumProductSubarray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一维动态规划，考虑到乘积符号问题，同时记录最大值（正）与最小值（负），</span></span><br><span class="line">    <span class="comment">// 采用局部和全局变量追踪局部与最终结果。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> globalMax = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp1 = nums[i]*max;</span><br><span class="line">            <span class="keyword">int</span> temp2 = nums[i]*min;</span><br><span class="line">            max = Math.max(Math.max(temp1, nums[i]), temp2);</span><br><span class="line">            min = Math.min(Math.min(temp1, nums[i]), temp2);</span><br><span class="line">            globalMax = Math.max(globalMax, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> globalMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Maximum_Product_Subarray_-_最大乘积子串">Maximum Product Subarray - 最大乘积子串</h3><p><strong>Description</strong>: Find the contiguous subarr]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Reverse Words in a String - 逆转字符串中的词语]]></title>
    <link href="http://eugeneyang.com/2016/03/10/Reverse%20Words%20in%20a%20String%20-%20%E9%80%86%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E8%AF%8D%E8%AF%AD/"/>
    <id>http://eugeneyang.com/2016/03/10/Reverse Words in a String - 逆转字符串中的词语/</id>
    <published>2016-03-10T12:44:47.000Z</published>
    <updated>2016-03-10T08:49:39.880Z</updated>
    <content type="html"><![CDATA[<h3 id="Reverse_Words_in_a_String_-_逆转字符串中的词语">Reverse Words in a String - 逆转字符串中的词语</h3><p><strong>Description</strong>: Given an input string, reverse the string word by word.</p>
<p>For example,<br> Given s = “the sky is blue”,<br> return “blue is sky the”.</p>
<p>思路：字符串裁剪与分割。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseWordsInString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> ReverseWordsInString().reverseWords(<span class="string">"a"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String trimed = s.trim();</span><br><span class="line">        <span class="keyword">if</span> (trimed.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String[] strings = trimed.split(<span class="string">"\\s+"</span>);</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=strings.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            builder.append(strings[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Reverse_Words_in_a_String_-_逆转字符串中的词语">Reverse Words in a String - 逆转字符串中的词语</h3><p><strong>Description</strong>: Given an input str]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Evaluate Reverse Polish Notation - 计算逆波兰表达式]]></title>
    <link href="http://eugeneyang.com/2016/03/09/Evaluate%20Reverse%20Polish%20Notation%20-%20%E8%AE%A1%E7%AE%97%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://eugeneyang.com/2016/03/09/Evaluate Reverse Polish Notation - 计算逆波兰表达式/</id>
    <published>2016-03-09T12:44:47.000Z</published>
    <updated>2016-03-10T08:49:39.877Z</updated>
    <content type="html"><![CDATA[<h3 id="Evaluate_Reverse_Polish_Notation_-_计算逆波兰表达式">Evaluate Reverse Polish Notation - 计算逆波兰表达式</h3><p><strong>Description</strong>: Evaluate the value of an arithmetic expression in Reverse Polish Notation.<br>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<p>Some examples:<br>  [“2”, “1”, “+”, “3”, “<em>“] -&gt; ((2 + 1) </em> 3) -&gt; 9<br>  [“4”, “13”, “5”, “/“, “+”] -&gt; (4 + (13 / 5)) -&gt; 6</p>
<p>思路：利用栈。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvaluateReversePolishNotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(tokens[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;tokens.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isOperator(tokens[i])) stack.push(tokens[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">char</span> c = tokens[i].charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> y = Integer.valueOf(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> x = Integer.valueOf(stack.pop());</span><br><span class="line">                stack.push(String.valueOf(calculate(x, y, c)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOperator</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'0'</span>&lt;=c &amp;&amp; c&lt;=<span class="string">'9'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>: <span class="keyword">return</span> x+y;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: <span class="keyword">return</span> x-y;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>: <span class="keyword">return</span> x*y;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>: <span class="keyword">return</span> x/y;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Evaluate_Reverse_Polish_Notation_-_计算逆波兰表达式">Evaluate Reverse Polish Notation - 计算逆波兰表达式</h3><p><strong>Description</strong>: Evalua]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Max Points on a Line - 直线上最大点数]]></title>
    <link href="http://eugeneyang.com/2016/03/08/Max%20Points%20on%20a%20Line%20-%20%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/03/08/Max Points on a Line - 直线上最大点数/</id>
    <published>2016-03-08T12:44:47.000Z</published>
    <updated>2016-03-09T05:07:13.979Z</updated>
    <content type="html"><![CDATA[<h3 id="Max_Points_on_a_Line_-_直线上最大点数">Max Points on a Line - 直线上最大点数</h3><p><strong>Description</strong>: Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<p>思路：为每个点计算其与其他点的斜率,斜率相同则在同一直线上.注意额外处理重复点和垂直线的情况.</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/04/leetcode-max-points-on-a-line-java/" target="_blank" rel="external">http://www.programcreek.com/2014/04/leetcode-max-points-on-a-line-java/</a></p>
<p>注意：double slope = (point1.y-point2.y)==0 ? 0.0 : (1.0<em>(point1.y-point2.y))/(point1.x-point2.x);<br>若写成 double slope = (1.0</em>(point1.y-point2.y))/(point1.x-point2.x);<br>在slopeCount.containsKey(slope)判断中会出错，这个细节一定要注意！</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPointsOnLine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        Point() &#123; x = <span class="number">0</span>; y = <span class="number">0</span>; &#125;</span><br><span class="line">        Point(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; x = a; y = b; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2014/04/leetcode-max-points-on-a-line-java/</span><br><span class="line">     * 为每个点计算其与其他点的斜率,斜率相同则在同一直线上.注意额外处理重复点和垂直线的情况.</span><br><span class="line">     * <span class="doctag">@param</span> points</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Double, Integer&gt; slopeCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;points.length; i++)&#123;</span><br><span class="line">            Point point1 = points[i];</span><br><span class="line">            <span class="keyword">int</span> duplicate = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> vertical = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;points.length; j++)&#123;</span><br><span class="line">                Point point2 = points[j];</span><br><span class="line">                <span class="keyword">if</span> (point1.x==point2.x) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (point1.y==point2.y) duplicate++;</span><br><span class="line">                    <span class="keyword">else</span> vertical++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//TODO 错误:double slope = (1.0*(point1.y-point2.y))/(point1.x-point2.x);</span></span><br><span class="line">                    <span class="keyword">double</span> slope = (point1.y-point2.y)==<span class="number">0</span> ? <span class="number">0.0</span> :</span><br><span class="line">                            (<span class="number">1.0</span>*(point1.y-point2.y))/(point1.x-point2.x);</span><br><span class="line">                    <span class="keyword">if</span> (!slopeCount.containsKey(slope)) slopeCount.put(slope, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> slopeCount.put(slope, slopeCount.get(slope)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Integer n : slopeCount.values())&#123;</span><br><span class="line">                <span class="keyword">if</span> (n+duplicate&gt;max) max = n+duplicate;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(vertical+duplicate, max);</span><br><span class="line">            slopeCount.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Max_Points_on_a_Line_-_直线上最大点数">Max Points on a Line - 直线上最大点数</h3><p><strong>Description</strong>: Given n points on a 2D plane, fi]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sort List - 归并排序链表]]></title>
    <link href="http://eugeneyang.com/2016/03/07/Sort%20List%20-%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://eugeneyang.com/2016/03/07/Sort List - 归并排序链表/</id>
    <published>2016-03-07T12:44:47.000Z</published>
    <updated>2016-03-08T07:51:04.059Z</updated>
    <content type="html"><![CDATA[<h3 id="Sort_List_-_归并排序链表">Sort List - 归并排序链表</h3><p><strong>Description</strong>: Sort a linked list in O(nlogn) time using constant space complexity.</p>
<p>思路：O(nlogn)可以采用快速排序/归并排序/堆排序,对于链表用归并排序方便(配合合并两个有序链表).</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * O(nlogn)可以采用快速排序/归并排序/堆排序,对于链表用归并排序方便(配合合并两个有序链表).</span><br><span class="line">     * <span class="doctag">@param</span> head</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeSort</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="comment">//TODO fast.next.next!=null不能漏</span></span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head2 = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode l1 = mergeSort(head);</span><br><span class="line">        ListNode l2 = mergeSort(head2);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoSortedLinkedList(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoSortedLinkedList</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1.val&lt;l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoSortedLinkedList(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoSortedLinkedList(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Sort_List_-_归并排序链表">Sort List - 归并排序链表</h3><p><strong>Description</strong>: Sort a linked list in O(nlogn) time using constant space]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Insertion Sort List - 插入排序链表]]></title>
    <link href="http://eugeneyang.com/2016/03/06/Insertion%20Sort%20List%20-%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://eugeneyang.com/2016/03/06/Insertion Sort List - 插入排序链表/</id>
    <published>2016-03-06T12:44:47.000Z</published>
    <updated>2016-03-08T07:51:04.056Z</updated>
    <content type="html"><![CDATA[<h3 id="Insertion_Sort_List_-_插入排序链表">Insertion Sort List - 插入排序链表</h3><p><strong>Description</strong>: Sort a linked list using insertion sort.</p>
<p>思路：插入排序就是每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSortList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode curr = head.next;</span><br><span class="line">        <span class="keyword">while</span> (curr!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.val&lt;pre.val)&#123;</span><br><span class="line">                pre.next = curr.next;</span><br><span class="line">                ListNode p = dummy;</span><br><span class="line">                ListNode q = dummy.next;</span><br><span class="line">                <span class="keyword">while</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (curr.val&lt;q.val)&#123;</span><br><span class="line">                        p.next = curr;</span><br><span class="line">                        curr.next = q;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = q;</span><br><span class="line">                    q = q.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = pre.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = curr;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Insertion_Sort_List_-_插入排序链表">Insertion Sort List - 插入排序链表</h3><p><strong>Description</strong>: Sort a linked list using insertion s]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LRU Cache - 最近最少访问缓存机制实现]]></title>
    <link href="http://eugeneyang.com/2016/03/05/LRU%20Cache%20-%20%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E8%AE%BF%E9%97%AE%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0/"/>
    <id>http://eugeneyang.com/2016/03/05/LRU Cache - 最近最少访问缓存机制实现/</id>
    <published>2016-03-05T12:44:47.000Z</published>
    <updated>2016-03-08T07:51:04.052Z</updated>
    <content type="html"><![CDATA[<h3 id="LRU_Cache_-_最近最少访问缓存机制实现">LRU Cache - 最近最少访问缓存机制实现</h3><p><strong>Description</strong>: Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.<br>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>思路：如果要O(1)的查找复杂度，肯定要用哈希表.<br>如果要O(1)的cache替换复杂度,可以采用链表,保证从头到尾的顺序就是cache从新到旧的顺序.对于任何一个节点，如果被访问了，那么就将该节点移至头部;如果cache已满，那么就把尾部的删掉，从头部插入新节点。</p>
<p>参考链接：<a href="http://www.programcreek.com/2013/03/leetcode-lru-cache-java/" target="_blank" rel="external">http://www.programcreek.com/2013/03/leetcode-lru-cache-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CacheEntry</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        CacheEntry pre;</span><br><span class="line">        CacheEntry next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CacheEntry</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, CacheEntry&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> CacheEntry head=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> CacheEntry end=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2013/03/leetcode-lru-cache-java/</span><br><span class="line">     * 如果要O(1)的查找复杂度，肯定要用哈希表.</span><br><span class="line">     * 如果要O(1)的cache替换复杂度,可以采用链表,保证从头到尾的顺序就是cache从新到旧的顺序.</span><br><span class="line">     对于任何一个节点，如果被访问了，那么就将该节点移至头部;</span><br><span class="line">     如果cache已满，那么就把尾部的删掉，从头部插入新节点。</span><br><span class="line">     * <span class="doctag">@param</span> capacity</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key))&#123;</span><br><span class="line">            CacheEntry cacheEntry = map.get(key);</span><br><span class="line">            <span class="comment">//对于任何一个节点，如果被访问了，那么就将该节点移至头部</span></span><br><span class="line">            remove(cacheEntry);</span><br><span class="line">            setHead(cacheEntry);</span><br><span class="line">            <span class="keyword">return</span> cacheEntry.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key))&#123;</span><br><span class="line">            CacheEntry old = map.get(key);</span><br><span class="line">            old.value = value;</span><br><span class="line">            <span class="comment">//对于任何一个节点，如果被访问了，那么就将该节点移至头部</span></span><br><span class="line">            remove(old);</span><br><span class="line">            setHead(old);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            CacheEntry newCacheEntry = <span class="keyword">new</span> CacheEntry(key, value);</span><br><span class="line">            <span class="keyword">if</span> (map.size()&gt;=capacity)&#123;</span><br><span class="line">                <span class="comment">//如果cache已满，那么就把尾部的删掉，从头部插入新节点</span></span><br><span class="line">                map.remove(end.key);</span><br><span class="line">                remove(end);</span><br><span class="line">            &#125;</span><br><span class="line">            setHead(newCacheEntry);</span><br><span class="line">            map.put(key, newCacheEntry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(CacheEntry cacheEntry)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheEntry.pre!=<span class="keyword">null</span>) cacheEntry.pre.next = cacheEntry.next;</span><br><span class="line">        <span class="keyword">else</span> head = cacheEntry.next;</span><br><span class="line">        <span class="keyword">if</span> (cacheEntry.next!=<span class="keyword">null</span>) cacheEntry.next.pre = cacheEntry.pre;</span><br><span class="line">        <span class="keyword">else</span> end = cacheEntry.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(CacheEntry cacheEntry)</span></span>&#123;</span><br><span class="line">        cacheEntry.next = head;</span><br><span class="line">        cacheEntry.pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head!=<span class="keyword">null</span>) head.pre = cacheEntry;</span><br><span class="line">        head = cacheEntry;</span><br><span class="line">        <span class="keyword">if</span> (end==<span class="keyword">null</span>) end = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="LRU_Cache_-_最近最少访问缓存机制实现">LRU Cache - 最近最少访问缓存机制实现</h3><p><strong>Description</strong>: Design and implement a data structure for Le]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binary Tree Postorder Traversal- 二叉树后序遍历(迭代)]]></title>
    <link href="http://eugeneyang.com/2016/03/04/Binary%20Tree%20Postorder%20Traversal-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86(%E8%BF%AD%E4%BB%A3)/"/>
    <id>http://eugeneyang.com/2016/03/04/Binary Tree Postorder Traversal- 二叉树后序遍历(迭代)/</id>
    <published>2016-03-04T12:44:47.000Z</published>
    <updated>2016-03-04T10:59:44.692Z</updated>
    <content type="html"><![CDATA[<h3 id="Binary_Tree_Postorder_Traversal-_二叉树后序遍历(迭代)">Binary Tree Postorder Traversal- 二叉树后序遍历(迭代)</h3><p><strong>Description</strong>: Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>思路：<br>一、遍历的同时将访问过的节点的相应左或右孩子指针置空，思路简单。<br>二、后序遍历的情况相对复杂,需要维护当前遍历的cur指针和前一个遍历的pre指针来追溯当前的情况（注意这里是遍历的指针，并不是真正按后序访问顺序的结点）。具体分为几种情况：<br>     （1）如果pre的左孩子或者右孩子是cur，那么说明遍历在往下走，按访问顺序继续，即如果有左孩子，则是左孩子进栈，否则如果有右孩子，则是右孩子进栈，<br>     如果左右孩子都没有，则说明该结点是叶子，可以直接访问并把结点出栈了。<br>     （2）如果反过来，cur的左孩子是pre，则说明已经在回溯往上走了，但是后序遍历要左右孩子走完才可以访问自己，所以这里如果有右孩子还需要把右孩子进栈，否则说明已经到自己了，可以访问并且出栈了。<br>     （3）如果cur的右孩子是pre，那么说明左右孩子都访问结束了，可以轮到自己了，访问并且出栈即可。<br>     与递归法一样,算法时间复杂度也是O(n)，空间复杂度是栈的大小O(logn)。</p>
<p>参考链接：<br><a href="http://www.programcreek.com/2012/12/leetcode-solution-of-iterative-binary-tree-postorder-traversal-in-java/" target="_blank" rel="external">http://www.programcreek.com/2012/12/leetcode-solution-of-iterative-binary-tree-postorder-traversal-in-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 后序遍历的情况相对复杂,需要维护当前遍历的cur指针和前一个遍历的pre指针来追溯当前的情况</span><br><span class="line">     （注意这里是遍历的指针，并不是真正按后序访问顺序的结点）。具体分为几种情况：</span><br><span class="line">     （1）如果pre的左孩子或者右孩子是cur，那么说明遍历在往下走，按访问顺序继续，</span><br><span class="line">     即如果有左孩子，则是左孩子进栈，否则如果有右孩子，则是右孩子进栈，</span><br><span class="line">     如果左右孩子都没有，则说明该结点是叶子，可以直接访问并把结点出栈了。</span><br><span class="line">     （2）如果反过来，cur的左孩子是pre，则说明已经在回溯往上走了，</span><br><span class="line">     但是后序遍历要左右孩子走完才可以访问自己，所以这里如果有右孩子还需要把右孩子进栈，</span><br><span class="line">     否则说明已经到自己了，可以访问并且出栈了。</span><br><span class="line">     （3）如果cur的右孩子是pre，那么说明左右孩子都访问结束了，可以轮到自己了，访问并且出栈即可。</span><br><span class="line">     与递归法一样,算法时间复杂度也是O(n)，空间复杂度是栈的大小O(logn)。</span><br><span class="line">     * http://www.programcreek.com/2012/12/leetcode-solution-of-iterative-binary-tree-postorder-traversal-in-java/</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode curr = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (prev==<span class="keyword">null</span> || prev.left==curr || prev.right==curr)&#123; <span class="comment">//往下走</span></span><br><span class="line">                <span class="keyword">if</span> (curr.left!=<span class="keyword">null</span>) stack.push(curr.left);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (curr.right!=<span class="keyword">null</span>) stack.push(curr.right);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    result.add(curr.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr.left==prev)&#123;    <span class="comment">//从左节点往上走</span></span><br><span class="line">                <span class="keyword">if</span> (curr.right!=<span class="keyword">null</span>) stack.push(curr.right);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    result.add(curr.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr.right==prev)&#123;   <span class="comment">//从右节点往上走</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                result.add(curr.val);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种方法简单,但是会改变原树结构</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (stack.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode top = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (top.left == <span class="keyword">null</span> &amp;&amp; top.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(top.val);</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(top.left);</span><br><span class="line">                top.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(top.right);</span><br><span class="line">                top.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Binary_Tree_Postorder_Traversal-_二叉树后序遍历(迭代)">Binary Tree Postorder Traversal- 二叉树后序遍历(迭代)</h3><p><strong>Description</strong>: Give]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

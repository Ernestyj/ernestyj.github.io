<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hexo]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://ernestyj.github.io/"/>
  <updated>2015-12-06T01:56:26.600Z</updated>
  <id>http://ernestyj.github.io/</id>
  
  <author>
    <name><![CDATA[Jian Yang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[N Queens - 皇后问题]]></title>
    <link href="http://ernestyj.github.io/2015/12/04/N%20Queens%20-%20%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>http://ernestyj.github.io/2015/12/04/N Queens - 皇后问题/</id>
    <published>2015-12-04T12:44:47.000Z</published>
    <updated>2015-12-06T01:56:26.600Z</updated>
    <content type="html"><![CDATA[<h3 id="N_Queens_-_皇后问题">N Queens - 皇后问题</h3><p><strong>Description</strong>: Given an integer n, return all distinct solutions to the n-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>
<p>皇后问题：每一个的横竖斜都没有其他皇后。</p>
<p>思路：回溯法。<br>关键：每一行只能有一个皇后，用一维数组存每行皇后所在列。用一维数组则在回溯的时候不需进行remove重置操作，因为回溯正好就回到上一行，可以接着找下一个合法列坐标。走完最后一行，坐标（row，colVal[row]）即皇后坐标。<br>参考：<a href="http://www.cnblogs.com/springfor/p/3870944.html" target="_blank" rel="external">http://www.cnblogs.com/springfor/p/3870944.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NQueens</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.cnblogs.com/springfor/p/3870944.html</span><br><span class="line">     * 回溯法</span><br><span class="line">     * 关键：每一行只能有一个皇后，用一维数组存每行皇后所在列。</span><br><span class="line">     * 用一维数组则在回溯的时候不需进行remove重置操作，因为回溯正好就回到上一行，可以接着找下一个合法列坐标。</span><br><span class="line">     * 走完最后一行，坐标（row，colVal[row]）即皇后坐标。</span><br><span class="line">     * <span class="doctag">@param</span> n</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> [] colVal = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dfsHelper(n, res, <span class="number">0</span>, colVal);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsHelper</span><span class="params">(<span class="keyword">int</span> n, List&lt;List&lt;String&gt;&gt; res, <span class="keyword">int</span> row, <span class="keyword">int</span>[] colVal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            List&lt;String&gt; aSolution = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == colVal[i]) s.append(<span class="string">"Q"</span>);</span><br><span class="line">                    <span class="keyword">else</span> s.append(<span class="string">"."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                aSolution.add(s.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(aSolution);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                colVal[row] = i;    <span class="comment">//(row,i)</span></span><br><span class="line">                <span class="keyword">if</span>(isValid(row, colVal)) dfsHelper(n, res, row + <span class="number">1</span>, colVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对角线的判断就是两点行差值和列差值是否相同</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> [] colVal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(colVal[row] == colVal[i] || Math.abs(colVal[row] - colVal[i]) == Math.abs(row - i))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="N_Queens_-_皇后问题">N Queens - 皇后问题</h3><p><strong>Description</strong>: Given an integer n, return all distinct solutions to the n-que]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pow(x, n) - 求指数]]></title>
    <link href="http://ernestyj.github.io/2015/12/03/Pow(x,%20n)%20-%20%E6%B1%82%E6%8C%87%E6%95%B0/"/>
    <id>http://ernestyj.github.io/2015/12/03/Pow(x, n) - 求指数/</id>
    <published>2015-12-03T12:44:47.000Z</published>
    <updated>2015-12-03T09:49:19.319Z</updated>
    <content type="html"><![CDATA[<h3 id="Pow(x,_n)_-_求指数">Pow(x, n) - 求指数</h3><p><strong>Description</strong>: Implement pow(x, n).</p>
<p>思路：二分法（递归）。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Pow().myPow(<span class="number">0.00001</span>, <span class="number">2147483647</span>));</span><br><span class="line"><span class="comment">//        System.out.println(new Pow().myPow(2, 5));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分法（递归）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / power(x, -n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> power(x, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> v = power(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> v * v;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v * v * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Pow(x,_n)_-_求指数">Pow(x, n) - 求指数</h3><p><strong>Description</strong>: Implement pow(x, n).</p>
<p>思路：二分法（递归）。</p>
<p>完整的java代码如下：</p]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Group Anagrams - 易位构词分组]]></title>
    <link href="http://ernestyj.github.io/2015/12/02/Group%20Anagrams%20-%20%E6%98%93%E4%BD%8D%E6%9E%84%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <id>http://ernestyj.github.io/2015/12/02/Group Anagrams - 易位构词分组/</id>
    <published>2015-12-02T12:44:47.000Z</published>
    <updated>2015-12-03T08:24:00.954Z</updated>
    <content type="html"><![CDATA[<h3 id="Group_Anagrams_-_易位构词分组">Group Anagrams - 易位构词分组</h3><p><strong>Description</strong>: Given an array of strings, group anagrams together.</p>
<p> For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br> Return:<br> [<br> [“ate”, “eat”,”tea”],<br> [“nat”,”tan”],<br> [“bat”]<br> ]<br> Note:<br> For the return value, each inner list’s elements must follow the lexicographic order. All inputs will be in lower-case.</p>
<p>思路：易位构词的排序结果是一样的。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupAnagrams</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strs = &#123; <span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span> &#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> GroupAnagrams().groupAnagrams(strs);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; list : result)&#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : list)&#123;</span><br><span class="line">                System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//易位构词的排序结果是一样的</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; books = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">char</span>[] chars;</span><br><span class="line">        List&lt;String&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++)&#123;</span><br><span class="line">            chars = strs[i].toCharArray();</span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line">            s = String.valueOf(chars);</span><br><span class="line">            <span class="keyword">if</span> (books.containsKey(s))&#123;</span><br><span class="line">                books.get(s).add(strs[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                temp.add(strs[i]);</span><br><span class="line">                books.put(s, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(books.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 超时</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams1(String[] strs) &#123;</span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">        List&lt;String&gt; temp;</span><br><span class="line">        HashMap&lt;HashMap&lt;Character, Integer&gt;, List&lt;String&gt;&gt; books = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; book;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++)&#123;</span><br><span class="line">            book = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">//获取小字典</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : strs[i].toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span> (book.containsKey(c)) book.put(c, book.get(c) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> book.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//大字典中找小字典</span></span><br><span class="line">            <span class="keyword">if</span> (books.containsKey(book)) &#123;</span><br><span class="line">                temp = books.get(book);</span><br><span class="line">                temp.add(strs[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                temp.add(strs[i]);</span><br><span class="line">                books.put(book, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(books.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Group_Anagrams_-_易位构词分组">Group Anagrams - 易位构词分组</h3><p><strong>Description</strong>: Given an array of strings, group anagrams toge]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rotate Image - 图像旋转]]></title>
    <link href="http://ernestyj.github.io/2015/12/01/Rotate%20Image%20-%20%E5%9B%BE%E5%83%8F%E6%97%8B%E8%BD%AC/"/>
    <id>http://ernestyj.github.io/2015/12/01/Rotate Image - 图像旋转/</id>
    <published>2015-12-01T12:44:47.000Z</published>
    <updated>2015-12-01T07:27:39.232Z</updated>
    <content type="html"><![CDATA[<h3 id="Rotate_Image_-_图像旋转">Rotate Image - 图像旋转</h3><p><strong>Description</strong>: You are given an n x n 2D matrix representing an image.<br> Rotate the image by 90 degrees (clockwise).</p>
<p> Follow up: Could you do this in-place?</p>
<p>思路：先转置再行逆转。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateImage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = matrix.length;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">new</span> RotateImage().rotate(matrix);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">                System.out.print(matrix[i][j] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先转置再行逆转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                reverseSwap(matrix, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len / <span class="number">2</span>; j++)&#123;</span><br><span class="line">                colSwap(matrix, i, j, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseSwap</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">        matrix[i][j] = matrix[j][i];</span><br><span class="line">        matrix[j][i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">colSwap</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">        matrix[i][j] = matrix[i][len - j - <span class="number">1</span>];</span><br><span class="line">        matrix[i][len - j - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Rotate_Image_-_图像旋转">Rotate Image - 图像旋转</h3><p><strong>Description</strong>: You are given an n x n 2D matrix representing an image]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Permutations II - 含重复元素的全排列]]></title>
    <link href="http://ernestyj.github.io/2015/11/30/Permutations%20II%20-%20%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://ernestyj.github.io/2015/11/30/Permutations II - 含重复元素的全排列/</id>
    <published>2015-11-30T12:44:47.000Z</published>
    <updated>2015-11-30T13:01:51.808Z</updated>
    <content type="html"><![CDATA[<h3 id="Permutations_II_-_含重复元素的全排列">Permutations II - 含重复元素的全排列</h3><p><strong>Description</strong>: Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p> For example,<br> [1,1,2] have the following unique permutations:<br> [1,1,2], [1,2,1], and [2,1,1].</p>
<p>此题与Permutations（无重复元素）思路一致，如下。<br>回溯法：从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理。<br>时间复杂度：n! 空间复杂度：（in place置换）</p>
<p>以abc为例子：</p>
<ol>
<li>a和a交换(固定a), 求后面bc的全排列： abc, acb。 求完后，a 和 b交换； 得到bac,开始第二轮</li>
<li>b和b交换(固定b), 求后面ac的全排列： bac, bca。 求完后，b 和 c交换； 得到cab,开始第三轮</li>
<li>c和c交换(固定c), 求后面ba的全排列： cab, cba.</li>
</ol>
<p>分析图：<a href="http://segmentfault.com/a/1190000002710424" target="_blank" rel="external">http://segmentfault.com/a/1190000002710424</a></p>
<p>注意：此题与Permutations（无重复元素）的不同在于输入集合含有重复元素。注意在回溯中添加跳过重复的判断（若不加则用例{1,-1,1,2,-1,2,2,-1}不通过）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; len &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">continue</span>;    <span class="comment">//跳过重复</span></span><br></pre></td></tr></table></figure></p>
<p>此外，若算法过程中用List存储元素，再通过判同过滤元素将无法通过用例{2,2,-1,2,3}，而算法过程中用Set则可以通过。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermutationsII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums[] = &#123; <span class="number">2</span>,<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">        <span class="keyword">new</span> PermutationsII().permuteUnique(nums);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : result)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : list) System.out.print(i);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Set&lt;List&lt;Integer&gt;&gt; resultSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; temp;</span><br><span class="line">    <span class="comment">/**注意：用例&#123;1,-1,1,2,-1,2,2,-1&#125;&#123;2,2,-1,2,3&#125;容易超时，注意添加跳过重复的逻辑判断</span><br><span class="line">     * 回溯法：从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理。</span><br><span class="line">     * 时间复杂度：n! 空间复杂度：（in place置换）</span><br><span class="line">     * 以abc为例子：</span><br><span class="line">     1. a和a交换(固定a), 求后面bc的全排列： abc, acb。 求完后，a 和 b交换； 得到bac,开始第二轮</span><br><span class="line">     2. b和b交换(固定b), 求后面ac的全排列： bac, bca。 求完后，b 和 c交换； 得到cab,开始第三轮</span><br><span class="line">     3. c和c交换(固定c), 求后面ba的全排列： cab, cba.</span><br><span class="line">     * http://blog.csdn.net/randyjiawenjie/article/details/6313729</span><br><span class="line">     * 分析图：http://segmentfault.com/a/1190000002710424</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        permutation(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;&gt;(resultSet);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == len - <span class="number">1</span>) &#123;</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">                temp.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            resultSet.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; len &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">continue</span>;    <span class="comment">//跳过重复</span></span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">                permutation(nums, start + <span class="number">1</span>, len);</span><br><span class="line">                swap(nums, start, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Permutations_II_-_含重复元素的全排列">Permutations II - 含重复元素的全排列</h3><p><strong>Description</strong>: Given a collection of numbers that mig]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Permutations - 全排列]]></title>
    <link href="http://ernestyj.github.io/2015/11/29/Permutations%20-%20%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://ernestyj.github.io/2015/11/29/Permutations - 全排列/</id>
    <published>2015-11-29T12:44:47.000Z</published>
    <updated>2015-11-29T14:47:44.790Z</updated>
    <content type="html"><![CDATA[<h3 id="Permutations_-_全排列">Permutations - 全排列</h3><p><strong>Description</strong>: Given a collection of numbers, return all possible permutations.</p>
<p> For example,<br> [1,2,3] have the following permutations:<br> [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].</p>
<p>回溯法：从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理。<br>时间复杂度：n! 空间复杂度：（in place置换）</p>
<p>以abc为例子：</p>
<ol>
<li>a和a交换(固定a), 求后面bc的全排列： abc, acb。 求完后，a 和 b交换； 得到bac,开始第二轮</li>
<li>b和b交换(固定b), 求后面ac的全排列： bac, bca。 求完后，b 和 c交换； 得到cab,开始第三轮</li>
<li>c和c交换(固定c), 求后面ba的全排列： cab, cba.</li>
</ol>
<p>分析图：<a href="http://segmentfault.com/a/1190000002710424" target="_blank" rel="external">http://segmentfault.com/a/1190000002710424</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutations</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span> &#125;;</span><br><span class="line">        <span class="keyword">new</span> Permutations().permute(nums);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; temp;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 回溯法：从集合依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理。</span><br><span class="line">     * 时间复杂度：n! 空间复杂度：（in place置换）</span><br><span class="line">     * 以abc为例子：</span><br><span class="line">     1. a和a交换(固定a), 求后面bc的全排列： abc, acb。 求完后，a 和 b交换； 得到bac,开始第二轮</span><br><span class="line">     2. b和b交换(固定b), 求后面ac的全排列： bac, bca。 求完后，b 和 c交换； 得到cab,开始第三轮</span><br><span class="line">     3. c和c交换(固定c), 求后面ba的全排列： cab, cba.</span><br><span class="line">     * http://blog.csdn.net/randyjiawenjie/article/details/6313729</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        permutation(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span>[] str, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == len - <span class="number">1</span>) &#123;</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">                temp.add(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; i ++) &#123;</span><br><span class="line">                swap(str, start, i);</span><br><span class="line">                permutation(str, start + <span class="number">1</span>, len);</span><br><span class="line">                swap(str, start, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Permutations_-_全排列">Permutations - 全排列</h3><p><strong>Description</strong>: Given a collection of numbers, return all possible permu]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Jump Game II - 跳数游戏]]></title>
    <link href="http://ernestyj.github.io/2015/11/28/Jump%20Game%20II%20-%20%E8%B7%B3%E6%95%B0%E6%B8%B8%E6%88%8F/"/>
    <id>http://ernestyj.github.io/2015/11/28/Jump Game II - 跳数游戏/</id>
    <published>2015-11-28T12:44:47.000Z</published>
    <updated>2015-11-28T12:45:24.707Z</updated>
    <content type="html"><![CDATA[<h3 id="Jump_Game_II_-_跳数游戏">Jump Game II - 跳数游戏</h3><p><strong>Description</strong>: Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p> Each element in the array represents your maximum jump length at that position.</p>
<p> Your goal is to reach the last index in the minimum number of jumps.</p>
<p> For example:<br> Given array A = [2,3,1,1,4]<br> The minimum number of jumps to reach the last index is 2.<br> (Jump 1 step from index 0 to 1, then 3 steps to the last index.)</p>
<p>首先明白，这个题只要我们求跳数，怎么跳、最后距离是多少都没让求，不要做无必要的计算。</p>
<p>贪心思路：<br>last:用最小跳数jumps可达的最大距离；<br>curr:用jumps + 1跳可达的最大距离；（贪心值）<br>有curr = max(i+nums[i]), 0 &lt;= i &lt;= last</p>
<p>分析图：<br><a href="http://www.cnblogs.com/lichen782/p/leetcode_Jump_Game_II.html" target="_blank" rel="external">http://www.cnblogs.com/lichen782/p/leetcode_Jump_Game_II.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpGame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> JumpGame().jump(nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 首先明白，这个题只要我们求跳数，怎么跳、最后距离是多少都没让求，不要做无必要的计算。</span><br><span class="line">     * 分析图：http://www.cnblogs.com/lichen782/p/leetcode_Jump_Game_II.html</span><br><span class="line">     * 贪心：</span><br><span class="line">     * last:用最小跳数jumps可达的最大距离；</span><br><span class="line">     * curr:用jumps + 1跳可达的最大距离；（贪心值）</span><br><span class="line">     * 有curr = max(i+nums[i]), 0 &lt;= i &lt;= last</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jumps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; last) &#123;</span><br><span class="line">                ++jumps;</span><br><span class="line">                last = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = Math.max(curr, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jumps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Jump_Game_II_-_跳数游戏">Jump Game II - 跳数游戏</h3><p><strong>Description</strong>: Given an array of non-negative integers, you are initi]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Multiply Strings - 大整数乘法]]></title>
    <link href="http://ernestyj.github.io/2015/11/26/Multiply%20Strings%20-%20%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/"/>
    <id>http://ernestyj.github.io/2015/11/26/Multiply Strings - 大整数乘法/</id>
    <published>2015-11-26T12:44:47.000Z</published>
    <updated>2015-11-26T12:05:20.649Z</updated>
    <content type="html"><![CDATA[<h3 id="Multiply_Strings_-_大整数乘法">Multiply Strings - 大整数乘法</h3><p><strong>Description</strong>: Given two numbers represented as strings, return multiplication of the numbers as a string.<br>Note: The numbers can be arbitrarily large and are non-negative.</p>
<p>思路：首先我们把每一位相乘，得到一个没有进位的临时结果，然后把临时结果从低位起依次进位。对于一个m位整数乘以n位整数的结果，最多只有m+n位。<br>要点：1. 字符串逆转问题；2. 进位（开辟m+n长度数组足以存储所有进位）；3. 结果最高位为0的情况。<br>参考图：<a href="http://www.cnblogs.com/TenosDoIt/p/3735309.html" target="_blank" rel="external">http://www.cnblogs.com/TenosDoIt/p/3735309.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * http://www.cnblogs.com/TenosDoIt/p/3735309.html</span><br><span class="line">    * 首先我们把每一位相乘，得到一个没有进位的临时结果，然后把临时结果从低位起依次进位。</span><br><span class="line">    * 对于一个m位整数乘以n位整数的结果，最多只有m+n位。</span><br><span class="line">    * <span class="doctag">@param</span> num1</span><br><span class="line">    * <span class="doctag">@param</span> num2</span><br><span class="line">    * <span class="doctag">@return</span></span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>)) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">       <span class="keyword">char</span>[] l = <span class="keyword">new</span> StringBuilder(num1).reverse().toString().toCharArray();</span><br><span class="line">       <span class="keyword">char</span>[] r = <span class="keyword">new</span> StringBuilder(num2).reverse().toString().toCharArray();</span><br><span class="line">       <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[num1. length() + num2.length()];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num1.length(); i++)&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num2.length(); j++)&#123;</span><br><span class="line">               ints[i + j] += (l[i] - <span class="string">'0'</span>) * (r[j] - <span class="string">'0'</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ints.length; i++)&#123;</span><br><span class="line">           builder.append(ints[i] % <span class="number">10</span>);</span><br><span class="line">           <span class="keyword">if</span> (i + <span class="number">1</span> &lt; ints.length) ints[i + <span class="number">1</span>] += ints[i] / <span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (builder.charAt(ints.length - <span class="number">1</span>) == <span class="string">'0'</span>) builder.deleteCharAt(ints.length - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> builder.reverse().toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Multiply_Strings_-_大整数乘法">Multiply Strings - 大整数乘法</h3><p><strong>Description</strong>: Given two numbers represented as strings, re]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Trapping Rain Water]]></title>
    <link href="http://ernestyj.github.io/2015/11/25/Trapping%20Rain%20Water/"/>
    <id>http://ernestyj.github.io/2015/11/25/Trapping Rain Water/</id>
    <published>2015-11-25T12:44:47.000Z</published>
    <updated>2015-11-25T05:19:38.057Z</updated>
    <content type="html"><![CDATA[<h3 id="Trapping_Rain_Water">Trapping Rain Water</h3><p><strong>Description</strong>: Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example,<br> Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.<br> Ref: <a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="external">https://leetcode.com/problems/trapping-rain-water/</a></p>
<p>思路：对某个值A[i]来说，能trapped的最多的water取决于在i之前最高的值leftMostHeight[i]和在i右边的最高的值rightMostHeight[i]（均不包含自身）。如果min(left,right) &gt; A[i]，那么在i这个位置上能trapped的water就是min(left,right) – A[i]。<br>第一遍从左到右计算数组leftMostHeight，第二遍从右到左计算rightMostHeight，在第二遍的同时就可以计算出i位置的结果了，而且并不需要开空间来存放rightMostHeight数组。<br>时间复杂度是O(n)，只扫了两遍。<br>参考：<br><a href="http://blog.unieagle.net/2012/10/31/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Atrapping-rain-water/" target="_blank" rel="external">http://blog.unieagle.net/2012/10/31/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Atrapping-rain-water/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrappingRainWater</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] height = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">int</span> trapped = <span class="keyword">new</span> TrappingRainWater().trap(height);</span><br><span class="line">        System.out.println(trapped);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** http://blog.unieagle.net/2012/10/31/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Atrapping-rain-water/</span><br><span class="line">     * 思路：对某个值A[i]来说，能trapped的最多的water取决于在i之前最高的值leftMostHeight[i]</span><br><span class="line">     和在i右边的最高的值rightMostHeight[i]（均不包含自身）。</span><br><span class="line">     如果min(left,right) &gt; A[i]，那么在i这个位置上能trapped的water就是min(left,right) – A[i]。</span><br><span class="line">     * 第一遍从左到右计算数组leftMostHeight，第二遍从右到左计算rightMostHeight，</span><br><span class="line">     在第二遍的同时就可以计算出i位置的结果了，而且并不需要开空间来存放rightMostHeight数组。</span><br><span class="line">     * 时间复杂度是O(n)，只扫了两遍。</span><br><span class="line">     * <span class="doctag">@param</span> height</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leftMostHeight = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">int</span> max = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> trapped = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;    <span class="comment">//left -&gt; right</span></span><br><span class="line">            leftMostHeight[i] = max;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt; max) max = height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        max = height[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;    <span class="comment">//right -&gt; left</span></span><br><span class="line">            <span class="keyword">if</span> (Math.min(leftMostHeight[i], max) &gt; height[i])&#123;</span><br><span class="line">                trapped += Math.min(leftMostHeight[i], max) - height[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt; max) max = height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> trapped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Trapping_Rain_Water">Trapping Rain Water</h3><p><strong>Description</strong>: Given n non-negative integers representing an elevatio]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[First Missing Positive - 第一个缺失的正整数]]></title>
    <link href="http://ernestyj.github.io/2015/11/24/First%20Missing%20Positive%20-%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0/"/>
    <id>http://ernestyj.github.io/2015/11/24/First Missing Positive - 第一个缺失的正整数/</id>
    <published>2015-11-24T12:44:47.000Z</published>
    <updated>2015-11-24T11:26:41.537Z</updated>
    <content type="html"><![CDATA[<h3 id="First_Missing_Positive_-_第一个缺失的正整数">First Missing Positive - 第一个缺失的正整数</h3><p><strong>Description</strong>: Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,<br> Given [1,2,0] return 3,<br> and [3,4,-1,1] return 2.</p>
<p> Your algorithm should run in O(n) time and uses constant space.</p>
<p>思路：交换数组元素，使得数组中第i位存放数值(i+1)。最后遍历数组，寻找第一个不符合此要求的元素，返回这个元素。整个过程需要遍历两次数组，复杂度为O(n)。<br>参考图：<br><a href="http://www.cnblogs.com/AnnieKim/archive/2013/04/21/3034631.html" target="_blank" rel="external">http://www.cnblogs.com/AnnieKim/archive/2013/04/21/3034631.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstMissingPositive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>,-<span class="number">1</span>,<span class="number">23</span>,<span class="number">7</span>,<span class="number">21</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">18</span>,<span class="number">21</span>,-<span class="number">1</span>,<span class="number">16</span>,<span class="number">1</span>,<span class="number">13</span>,-<span class="number">3</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,-<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">new</span> FirstMissingPositive().firstMissingPositive(nums);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 交换数组元素，使得数组中第i位存放数值(i+1)。最后遍历数组，寻找第一个不符合此要求的元素，</span><br><span class="line">     * 返回这个元素。整个过程需要遍历两次数组，复杂度为O(n)。</span><br><span class="line">     * 参考图：http://www.cnblogs.com/AnnieKim/archive/2013/04/21/3034631.html</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length)&#123;    <span class="comment">//这里不使用for循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; nums.length &amp;&amp; nums[i] != i + <span class="number">1</span> &amp;&amp;</span><br><span class="line">                    nums[nums[i] - <span class="number">1</span>] != nums[i])&#123; <span class="comment">//TODO 此条件易漏，否则进入无限循环</span></span><br><span class="line">                swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="First_Missing_Positive_-_第一个缺失的正整数">First Missing Positive - 第一个缺失的正整数</h3><p><strong>Description</strong>: Given an unsorted intege]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Combination Sum II (unique) - 组合数求和 II]]></title>
    <link href="http://ernestyj.github.io/2015/11/23/Combination%20Sum%20II%20(unique)%20-%20%E7%BB%84%E5%90%88%E6%95%B0%E6%B1%82%E5%92%8C%20II/"/>
    <id>http://ernestyj.github.io/2015/11/23/Combination Sum II (unique) - 组合数求和 II/</id>
    <published>2015-11-23T12:44:47.000Z</published>
    <updated>2015-11-23T10:57:28.751Z</updated>
    <content type="html"><![CDATA[<h3 id="Combination_Sum_II_(unique)_-_组合数求和_II">Combination Sum II (unique) - 组合数求和 II</h3><p><strong>Description</strong>: Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination.</p>
<p> Note: All numbers (including target) will be positive integers.<br> Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).<br> The solution set must not contain duplicate combinations.</p>
<p> For example, given candidate set 10,1,2,7,6,1,5 and target 8,<br> A solution set is:<br> [1, 7]<br> [1, 2, 5]<br> [2, 6]<br> [1, 1, 6] </p>
<p>思路：回溯法（与Combination Sum I的思路基本一致）。此题是典型的回溯法类型，注意元素不可以重复。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSumUnique</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        CombinationSumUnique instance = <span class="keyword">new</span> CombinationSumUnique();</span><br><span class="line">        instance.combinationSum2(nums, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; ints : instance.result)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : ints) System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTrack(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入参candidates增序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!result.contains(temp)) <span class="comment">//可能有重复结果</span></span><br><span class="line">                result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[i]) <span class="keyword">return</span>;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            backTrack(nums, target - nums[i], i + <span class="number">1</span>);   <span class="comment">//传入i + 1而非i表明不可以重复</span></span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Combination_Sum_II_(unique)_-_组合数求和_II">Combination Sum II (unique) - 组合数求和 II</h3><p><strong>Description</strong>: Given a collecti]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Combination Sum - 组合数求和]]></title>
    <link href="http://ernestyj.github.io/2015/11/22/Combination%20Sum%20-%20%E7%BB%84%E5%90%88%E6%95%B0%E6%B1%82%E5%92%8C/"/>
    <id>http://ernestyj.github.io/2015/11/22/Combination Sum - 组合数求和/</id>
    <published>2015-11-22T12:44:47.000Z</published>
    <updated>2015-11-22T06:54:25.315Z</updated>
    <content type="html"><![CDATA[<h3 id="Combination_Sum_-_组合数求和">Combination Sum - 组合数求和</h3><p><strong>Description</strong>: Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.<br> The same repeated number may be chosen from C unlimited number of times.</p>
<p> Note:</p>
<ol>
<li>All numbers (including target) will be positive temp.</li>
<li>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</li>
<li><p>The solution set must not contain duplicate combinations.</p>
<p>For example, given candidate set 2,3,6,7 and target 7,<br>A solution set is:<br>[7]<br>[2, 2, 3]</p>
</li>
</ol>
<p>思路：回溯法。此题是典型的回溯法类型，注意元素可以重复。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        CombinationSum instance = <span class="keyword">new</span> CombinationSum();</span><br><span class="line">        instance.combinationSum(nums, <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; ints : instance.result)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : ints) System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTrack(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入参candidates增序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[i]) <span class="keyword">return</span>;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            backTrack(nums, target - nums[i], i);   <span class="comment">//传入i而非i + 1表明可以重复</span></span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Combination_Sum_-_组合数求和">Combination Sum - 组合数求和</h3><p><strong>Description</strong>: Given a set of candidate numbers (C) and a tar]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Longest Substring Without Repeating Characters - 最长无重复子串]]></title>
    <link href="http://ernestyj.github.io/2015/11/21/Longest%20Substring%20Without%20Repeating%20Characters%20-%20%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/"/>
    <id>http://ernestyj.github.io/2015/11/21/Longest Substring Without Repeating Characters - 最长无重复子串/</id>
    <published>2015-11-21T12:44:47.000Z</published>
    <updated>2015-11-22T08:37:17.041Z</updated>
    <content type="html"><![CDATA[<h3 id="Longest_Substring_Without_Repeating_Characters_-_最长无重复子串">Longest Substring Without Repeating Characters - 最长无重复子串</h3><p><strong>Description</strong>: Given a string, find the length of the longest substring without repeating characters.</p>
<p>For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.</p>
<p>思路：</p>
<ol>
<li>滑动窗口法：维护一个窗口，每次关注窗口中的字符串，在每次判断中，左窗口和右窗口选择其一向前移动。同样是维护一个HashSet，①正常情况下移动右窗口，如果没有出现重复则继续移动右窗口；②如果发现重复字符，则说明当前窗口中的串已经不满足要求，继续移动右窗口不可能得到更好的结果，此时移动左窗口，直到不再有重复字符为止，中间跳过的这些串中不会有更好的结果，因为他们不是重复就是更短。<br>复杂度：因为左窗口和右窗口都只向前，所以两个窗口都对每个元素访问不超过一遍，因此时间复杂度为O(2*n)=O(n),是线性算法。空间复杂度为HashSet的size,也是O(n)。<br>参考：<a href="http://blog.csdn.net/linhuanmars/article/details/19949159" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/19949159</a></li>
<li>每次定一个起点pre，然后从起点走到有重复字符位置，过程用一个HashSet维护当前字符集，认为是constant操作，这样算法要进行两层循环，复杂度是O(n^2)。<br>参考：<a href="http://blog.csdn.net/likecool21/article/details/10858799" target="_blank" rel="external">http://blog.csdn.net/likecool21/article/details/10858799</a> 中的解析图</li>
</ol>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestSubstringWithoutRepeatingCharacters</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"bbbbb"</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">new</span> LongestSubstringWithoutRepeatingCharacters().lengthOfLongestSubstring(s);</span><br><span class="line"><span class="comment">//        int x = lengthOfLongestSubstring1(s);</span></span><br><span class="line">        System.out.print(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 滑动窗口法 TODO</span><br><span class="line">     * 思路：维护一个窗口，每次关注窗口中的字符串，在每次判断中，左窗口和右窗口选择其一向前移动。</span><br><span class="line">     * 同样是维护一个HashSet,①正常情况下移动右窗口，如果没有出现重复则继续移动右窗口；</span><br><span class="line">     * ②如果发现重复字符，则说明当前窗口中的串已经不满足要求，继续移动右窗口不可能得到更好的结果，</span><br><span class="line">     * 此时移动左窗口，直到不再有重复字符为止，中间跳过的这些串中不会有更好的结果，</span><br><span class="line">     * 因为他们不是重复就是更短。</span><br><span class="line">     *</span><br><span class="line">     * 复杂度：因为左窗口和右窗口都只向前，所以两个窗口都对每个元素访问不超过一遍，</span><br><span class="line">     * 因此时间复杂度为O(2*n)=O(n),是线性算法。空间复杂度为HashSet的size,也是O(n)。</span><br><span class="line">     * http://blog.csdn.net/linhuanmars/article/details/19949159</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; chars.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(chars[r])) set.add(chars[r]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (max &lt; r - l) max = r - l;</span><br><span class="line">                <span class="keyword">while</span> (chars[r] != chars[l])&#123;</span><br><span class="line">                    set.remove(chars[l]);</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(max, r - l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 此算法利于理解</span><br><span class="line">     * 思路：每次定一个起点pre，然后从起点走到有重复字符位置，过程用一个HashSet维护当前字符集，</span><br><span class="line">     * 认为是constant操作，这样算法要进行两层循环，复杂度是O(n^2)</span><br><span class="line">     * 参考http://blog.csdn.net/likecool21/article/details/10858799中的图</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(arr[i])) &#123;</span><br><span class="line">                map.put(arr[i], i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = Math.max(pre, map.size());</span><br><span class="line">                i = map.get(arr[i]);</span><br><span class="line">                map.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(pre, map.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Longest_Substring_Without_Repeating_Characters_-_最长无重复子串">Longest Substring Without Repeating Characters - 最长无重复子串</h3><p><strong>De]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sudoku Solver]]></title>
    <link href="http://ernestyj.github.io/2015/11/20/Sudoku%20Solver/"/>
    <id>http://ernestyj.github.io/2015/11/20/Sudoku Solver/</id>
    <published>2015-11-20T12:44:47.000Z</published>
    <updated>2015-11-20T04:26:11.046Z</updated>
    <content type="html"><![CDATA[<h3 id="Sudoku_Solver">Sudoku Solver</h3><p><strong>Description</strong>: Write a program to solve a Sudoku puzzle by filling the empty cells.<br>Empty cells are indicated by the character ‘.’. You may assume that there will be only one unique solution.</p>
<p>思路：回溯法。和Valid Sudoku这题相比，此题中的输入保证是有效的。这样用回溯法我们只要检查新加入的值能否在行、列以及小方块里有效即可，没有必要检查整个矩阵。<br>参考：<br><a href="http://www.cnblogs.com/panda_lin/archive/2013/11/04/sudoku_solver.html" target="_blank" rel="external">http://www.cnblogs.com/panda_lin/archive/2013/11/04/sudoku_solver.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SudokuSolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] input = &#123;<span class="string">"..9748..."</span>,<span class="string">"7........"</span>,<span class="string">".2.1.9..."</span>,<span class="string">"..7...24."</span>,<span class="string">".64.1.59."</span>,<span class="string">".98...3.."</span>,<span class="string">"...8.3.2."</span>,<span class="string">"........6"</span>,<span class="string">"...2759.."</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[][] in = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) in[i] = input[i].toCharArray();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">new</span> SudokuSolver().solveSudoku(in);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; ++row) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; ++col) System.out.print(in[row][col] + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 回溯法</span><br><span class="line">     * 和Valid Sudoku这题相比，此题中的输入保证是有效的。这样用回溯法我们只要检查新加入的值</span><br><span class="line">     * 能否在行、列以及小方块里有效即可，没有必要检查整个矩阵。</span><br><span class="line">     * http://www.cnblogs.com/panda_lin/archive/2013/11/04/sudoku_solver.html</span><br><span class="line">     * <span class="doctag">@param</span> board</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        backTrackSolveSudoku(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backTrackSolveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; ++row) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; ++col) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (board[row][col] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'1'</span>; c &lt;= <span class="string">'9'</span>; c++)&#123;</span><br><span class="line">                        board[row][col] = c;</span><br><span class="line">                        <span class="keyword">if</span> (isValidSudoku(board, row, col))&#123;    <span class="comment">//限制条件</span></span><br><span class="line">                            <span class="keyword">if</span> (backTrackSolveSudoku(board)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只要检查新加入的值能否在行、列以及小方块里有效即可，没有必要检查整个矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;   <span class="comment">//x,y为坐标</span></span><br><span class="line">        <span class="keyword">int</span> row, col;</span><br><span class="line">        <span class="comment">// Same value in the same column?</span></span><br><span class="line">        <span class="keyword">for</span> (row = <span class="number">0</span>; row &lt; <span class="number">9</span>; ++row) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((x != row) &amp;&amp; (board[row][y] == board[x][y])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Same value in the same row?</span></span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">0</span>; col &lt; <span class="number">9</span>; ++col) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((y != col) &amp;&amp; (board[x][col] == board[x][y])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Same value in the 3 * 3 block it belong to?</span></span><br><span class="line">        <span class="keyword">for</span> (row = (x / <span class="number">3</span>) * <span class="number">3</span>; row &lt; (x / <span class="number">3</span> + <span class="number">1</span>) * <span class="number">3</span>; ++row) &#123;</span><br><span class="line">            <span class="keyword">for</span> (col = (y / <span class="number">3</span>) * <span class="number">3</span>; col &lt; (y / <span class="number">3</span> + <span class="number">1</span>) * <span class="number">3</span>; ++col) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((x != row) &amp;&amp; (y != col) &amp;&amp; (board[row][col] == board[x][y])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Sudoku_Solver">Sudoku Solver</h3><p><strong>Description</strong>: Write a program to solve a Sudoku puzzle by filling the empty cell]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Valid Sudoku]]></title>
    <link href="http://ernestyj.github.io/2015/11/19/Valid%20Sudoku/"/>
    <id>http://ernestyj.github.io/2015/11/19/Valid Sudoku/</id>
    <published>2015-11-19T12:44:47.000Z</published>
    <updated>2015-11-20T04:24:13.082Z</updated>
    <content type="html"><![CDATA[<h3 id="Valid_Sudoku">Valid Sudoku</h3><p><strong>Description</strong>: Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.<br>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p>
<p>思路：Brute force，对每个九宫格，行号起始block/3<em>3，列号起始block%3</em>3。另一种思路，如果把九宫格按照行从0开始标号，那么数字board[i][j]位于第 i/3<em>3+j/3 个九宫格内。<br>时间复杂度：O(3</em>n^2), n=9</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidSudoku</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] input = &#123;<span class="string">".87654321"</span>,<span class="string">"2........"</span>,<span class="string">"3........"</span>,<span class="string">"4........"</span>,<span class="string">"5........"</span>,<span class="string">"6........"</span>,<span class="string">"7........"</span>,</span><br><span class="line">                <span class="string">"8........"</span>,<span class="string">"9........"</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[][] in = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) in[i] = input[i].toCharArray();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">new</span> ValidSudoku().isValidSudoku(in);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Brute force，对每个九宫格，行号起始block/3*3，列号起始block%3*3</span></span><br><span class="line">    <span class="comment">// 如果把九宫格按照行从0开始标号，那么数字board[i][j]位于第 i/3*3+j/3 个九宫格内</span></span><br><span class="line">    <span class="comment">// 时间复杂度：O(3*n^2), n=9</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = board[<span class="number">0</span>].length;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map, book = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'1'</span>; c &lt;= <span class="string">'9'</span>; c++) book.put(c, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (book.containsKey(board[i][j]) &amp;&amp; !map.containsKey(board[i][j]))</span><br><span class="line">                    map.put(board[i][j], <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (board[j][i] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (book.containsKey(board[j][i]) &amp;&amp; !map.containsKey(board[j][i]))</span><br><span class="line">                    map.put(board[j][i], <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> block = <span class="number">0</span>; block &lt; <span class="number">9</span>; block++)&#123;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = block/<span class="number">3</span>*<span class="number">3</span>; i &lt; block/<span class="number">3</span>*<span class="number">3</span> + <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = block%<span class="number">3</span>*<span class="number">3</span>; j &lt; block%<span class="number">3</span>*<span class="number">3</span> + <span class="number">3</span>; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (book.containsKey(board[i][j]) &amp;&amp; !map.containsKey(board[i][j]))</span><br><span class="line">                        map.put(board[i][j], <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Valid_Sudoku">Valid Sudoku</h3><p><strong>Description</strong>: Determine if a Sudoku is valid, according to: Sudoku Puzzles - The R]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Search Insert Position]]></title>
    <link href="http://ernestyj.github.io/2015/11/18/Search%20Insert%20Position/"/>
    <id>http://ernestyj.github.io/2015/11/18/Search Insert Position/</id>
    <published>2015-11-18T12:44:47.000Z</published>
    <updated>2015-11-18T14:02:31.322Z</updated>
    <content type="html"><![CDATA[<h3 id="Search_Insert_Position">Search Insert Position</h3><p><strong>Description</strong>: Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.</p>
<p> Here are few examples.<br> [1,3,5,6], 5 → 2<br> [1,3,5,6], 2 → 1<br> [1,3,5,6], 7 → 4<br> [1,3,5,6], 0 → 0</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchInsertPosition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">new</span> SearchInsertPosition().searchInsert(nums, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[m])&#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt; target)&#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有找到目标元素，那么l一定停在恰好比target大的index上</span></span><br><span class="line">        <span class="comment">// r一定停在恰好比target小的index上</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Search_Insert_Position">Search Insert Position</h3><p><strong>Description</strong>: Given a sorted array and a target value, return ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Search for a Range]]></title>
    <link href="http://ernestyj.github.io/2015/11/17/Search%20for%20a%20Range/"/>
    <id>http://ernestyj.github.io/2015/11/17/Search for a Range/</id>
    <published>2015-11-17T12:44:47.000Z</published>
    <updated>2015-11-18T14:02:39.182Z</updated>
    <content type="html"><![CDATA[<h3 id="Search_for_a_Range">Search for a Range</h3><p><strong>Description</strong>: Given a sorted array of integers, find the starting and ending position of a given target value.<br> Your algorithm’s runtime complexity must be in the order of O(log n).<br> If the target is not found in the array, return [-1, -1].</p>
<p> For example,<br> Given [5, 7, 7, 8, 8, 10] and target value 8,<br> return [3, 4].</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchForARange</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] range = <span class="keyword">new</span> SearchForARange().searchRange(nums, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(range[<span class="number">0</span>] + <span class="string">", "</span> + range[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] range = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> range;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[m]) r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt; target) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= r; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] == target) range[<span class="number">1</span>] = i;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= l; j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] == target) range[<span class="number">0</span>] = j;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> range;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> range;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Search_for_a_Range">Search for a Range</h3><p><strong>Description</strong>: Given a sorted array of integers, find the starting and ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Search In Rotated Sorted Array]]></title>
    <link href="http://ernestyj.github.io/2015/11/15/Search%20In%20Rotated%20Sorted%20Array%20-%20Copy/"/>
    <id>http://ernestyj.github.io/2015/11/15/Search In Rotated Sorted Array - Copy/</id>
    <published>2015-11-15T12:44:47.000Z</published>
    <updated>2015-11-18T14:02:45.411Z</updated>
    <content type="html"><![CDATA[<h3 id="Search_In_Rotated_Sorted_Array">Search In Rotated Sorted Array</h3><p><strong>Description</strong>: Suppose a sorted array is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array.</p>
<p>假设数组是A，每次左边缘为l，右边缘为r，还有中间位置是m。在每次迭代中，分三种情况：<br>（1）如果target==A[m]，那么m就是我们要的结果，直接返回；<br>（2）如果A[m]<a[r]，那么说明从m到r一定是有序的（没有受到rotate的影响），那么我们只需要判断target是不是在m到r之间，如果是则把左边缘移到m+1，否则就target在另一半，即把右边缘移到m-1。 （3）如果a[m]="">=A[r]，那么说明从l到m一定是有序的，同样只需要判断target是否在这个范围内，相应的移动边缘即可。</a[r]，那么说明从m到r一定是有序的（没有受到rotate的影响），那么我们只需要判断target是不是在m到r之间，如果是则把左边缘移到m+1，否则就target在另一半，即把右边缘移到m-1。></p>
<p>根据以上方法，每次我们都可以切掉一半的数据，所以算法的时间复杂度是O(logn)，空间复杂度是O(1)。</p>
<p>参考：<a href="http://blog.csdn.net/linhuanmars/article/details/20525681" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/20525681</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchInRotatedSortedArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">new</span> SearchInRotatedSortedArray().search(nums, <span class="number">0</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://blog.csdn.net/linhuanmars/article/details/20525681</span><br><span class="line">     * 假设数组是A，每次左边缘为l，右边缘为r，还有中间位置是m。在每次迭代中，分三种情况：</span><br><span class="line">     （1）如果target==A[m]，那么m就是我们要的结果，直接返回；</span><br><span class="line">     （2）如果A[m]&lt;A[r]，那么说明从m到r一定是有序的（没有受到rotate的影响），</span><br><span class="line">     那么我们只需要判断target是不是在m到r之间，如果是则把左边缘移到m+1，</span><br><span class="line">     否则就target在另一半，即把右边缘移到m-1。</span><br><span class="line">     （3）如果A[m]&gt;=A[r]，那么说明从l到m一定是有序的，同样只需要判断target是否在这个范围内，</span><br><span class="line">     相应的移动边缘即可。</span><br><span class="line">     * 根据以上方法，每次我们都可以切掉一半的数据，所以算法的时间复杂度是O(logn)，空间复杂度是O(1)。</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@param</span> target</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[m]) <span class="keyword">return</span> m;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt; nums[r]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[m] &lt; target &amp;&amp; target &lt;= nums[r]) l = m + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[m]) r = m - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Search_In_Rotated_Sorted_Array">Search In Rotated Sorted Array</h3><p><strong>Description</strong>: Suppose a sorted array is rotate]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Next Permutation]]></title>
    <link href="http://ernestyj.github.io/2015/11/14/Next%20Permutation/"/>
    <id>http://ernestyj.github.io/2015/11/14/Next Permutation/</id>
    <published>2015-11-14T12:44:47.000Z</published>
    <updated>2015-11-14T08:37:58.504Z</updated>
    <content type="html"><![CDATA[<h3 id="Next_Permutation">Next Permutation</h3><p><strong>Description</strong>: Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p> If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p> The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br> 1,2,3 → 1,3,2<br> 3,2,1 → 1,2,3<br> 1,1,5 → 1,5,1</p>
<p>对序列大小的比较做出定义：两个长度相同的序列，从两者的第一个元素开始向后比较，直到出现一个不同元素（也可能就是第它们的第一个元素），该元素较大的序列为大，反之序列为小；若一直到最后一个元素都相同，那么两个序列相等。对于一个任意序列，最小的序列是增序，最大的序列为减序。</p>
<p>思路：假设一个有m个元素的序列pn，其下一个较大序列为pn+1。<br>1) 若pn最右端的2个元素构成一个增序子序列，那么直接反转这2个元素使该子序列成为减序，即可得到pn+1。<br>2) 若pn最右端一共有连续的s个元素构成一个减序子序列，令i = m - s，则有pn(i) &lt; pn(i+1)，其中pn(i)表示排列pn的第i个元素。因此若将pn(i)和其右边的子集s{pn(i+1), pn(i+2), …, pn(m)}中任意一个元素调换必能得到一个较大的序列（不一定是下一个）。要保证是下一个较大的序列，必须保持pn(i)左边的元素不动，并在子集s{pn(i+1), pn(i+2), …, pn(m)}中找出所有比pn(i)大的元素中最小的一个pn(j)，然后将二者调换位置。现在只要使新子集{pn(i+1), pn(i+2), …, pn(i), …,pn(m)}成为最小序列即得到pn+1。然而新子集仍保持减序，那么此时直接将其反转即可得到pn+1 {pn(1), pn(2), …, pn(j), pn(m), pn(m-1), …, pn(i), …, pn(i+2), pn(i+1)}。<br>参考：<a href="http://blog.csdn.net/jeasn168/article/details/39047685" target="_blank" rel="external">http://blog.csdn.net/jeasn168/article/details/39047685</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextPermutation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//        reverse(nums1, 0, 4);</span></span><br><span class="line"><span class="comment">//        for (int i : nums1) System.out.print(i + " ");</span></span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        nextPermutation(nums1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1) System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 假设一个有m个元素的序列pn，其下一个较大序列为pn+1。</span><br><span class="line">     * 1) 若pn最右端的2个元素构成一个增序子序列，那么直接反转这2个元素使该子序列成为减序，即可得到pn+1。</span><br><span class="line">     * 2) 若pn最右端一共有连续的s个元素构成一个减序子序列，令i = m - s，则有pn(i) &lt; pn(i+1)，</span><br><span class="line">        其中pn(i)表示排列pn的第i个元素。因此若将pn(i)和其右边的子集s&#123;pn(i+1), pn(i+2), ..., pn(m)&#125;</span><br><span class="line">        中任意一个元素调换必能得到一个较大的序列（不一定是下一个）。</span><br><span class="line">        要保证是下一个较大的序列，必须保持pn(i)左边的元素不动，并在子集s&#123;pn(i+1), pn(i+2), ..., pn(m)&#125;</span><br><span class="line">        中找出所有比pn(i)大的元素中最小的一个pn(j)，然后将二者调换位置。</span><br><span class="line">        现在只要使新子集&#123;pn(i+1), pn(i+2), ..., pn(i), ...,pn(m)&#125;成为最小序列即得到pn+1。</span><br><span class="line">        然而新子集仍保持减序，那么此时直接将其反转即可得到</span><br><span class="line">        pn+1 &#123;pn(1), pn(2), ..., pn(j), pn(m), pn(m-1), ..., pn(i), ..., pn(i+2), pn(i+1)&#125;。</span><br><span class="line">     ex. 3 6 4 2</span><br><span class="line">         4 6 3 2</span><br><span class="line">         4 2 3 6</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> || len == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//pn最右端的2个元素构成一个增序子序列</span></span><br><span class="line">        <span class="keyword">if</span> (nums[len - <span class="number">1</span>] &gt; nums[len - <span class="number">2</span>])&#123;</span><br><span class="line">            swap(nums, len - <span class="number">1</span>, len - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pn最右端一共有连续的s个元素构成一个减序子序列</span></span><br><span class="line">        <span class="keyword">for</span> (i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//pn是一个非递增序列</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>] &gt;= nums[<span class="number">1</span>])&#123;</span><br><span class="line">                reverse(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> theI = i;</span><br><span class="line">        <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt; theI; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[theI] &lt; nums[i]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, theI, i);</span><br><span class="line"><span class="comment">//        System.out.println((theI + 1) + " " + (len - 1));</span></span><br><span class="line">        reverse(nums, theI + <span class="number">1</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> count = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= mid; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) swap(nums, i, i + (mid - i) * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> swap(nums, i, i + (mid - i) * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Next_Permutation">Next Permutation</h3><p><strong>Description</strong>: Implement next permutation, which rearranges numbers into th]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Substring with Concatenation of All Words - 在字符串中查找指定字符串组合]]></title>
    <link href="http://ernestyj.github.io/2015/11/13/Substring%20with%20Concatenation%20of%20All%20Words%20-%20%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84%E5%90%88%20-%20Copy/"/>
    <id>http://ernestyj.github.io/2015/11/13/Substring with Concatenation of All Words - 在字符串中查找指定字符串组合 - Copy/</id>
    <published>2015-11-13T12:44:47.000Z</published>
    <updated>2015-11-13T13:01:05.238Z</updated>
    <content type="html"><![CDATA[<h3 id="Substring_with_Concatenation_of_All_Words_-_在字符串中查找指定字符串组合">Substring with Concatenation of All Words - 在字符串中查找指定字符串组合</h3><p><strong>Description</strong>: You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.<br>注意：words中的word可以重复<br>For example, given:<br> s: “barfoothefoobarman”<br> words: [“foo”, “bar”]<br> You should return the indices: [0,9]. (order does not matter).</p>
<p>方法1：全排列words再匹配，超时；<br>方法2：普通方法，即遍历给定字符串逐个检查，超时；<br>方法3：滑动窗口法，通过测试用例。<br>参考：<a href="http://segmentfault.com/a/1190000002625580" target="_blank" rel="external">http://segmentfault.com/a/1190000002625580</a></p>
<p>方法3首先是要明确用滑块的概念来解决，始终保持L集合中的字符串在滑块中都只出现了一次，当然设置一个总计数count，当count等于L集合长度时，即使找了一段符合要求的字符串。</p>
<p>需要用到的内存空间：</p>
<pre><code><span class="number">1.</span> 两张哈希表，一张保存L集合中的单词，一张用来保存当前滑块中的单词，key为单词，value为出现次数
<span class="number">2.</span> count计数，保存当前滑块中的单词总数
<span class="number">3.</span> left标记，记录滑块左起点
</code></pre><p>思路：</p>
<pre><code><span class="number">1.</span> 遍历一遍单词数组L集合，构造总单词表
<span class="number">2.</span> 以单词长度为步长，遍历目标字符串，如果当前单词在总单词表内，则进入步骤<span class="number">3</span>；反之，则清空当前滑块单词表，将<span class="built_in">cout</span>置零，将left移动到下一位置
<span class="number">3.</span> 当前滑块档次表中的相应单词计数加<span class="number">1</span>，检查该单词的计数是否小于等于总单词表中该单词的总数，如果是，则将count计数加<span class="number">1</span>，进入步骤<span class="number">5</span>；反之，进入步骤<span class="number">4</span>
<span class="number">4.</span> 根据左起点left收缩滑块，直到收缩到与当前单词相同的字符串片段，将其剔除之后，滑块的收缩工作完成。（收缩滑块，这是因为当前滑块中有单词的出现次数超过了额定的出现次数，那么就是需要收缩滑块来剔除这个单词，相当于是从滑块的左起点开始寻找该单词，找到之后，将该单词的右端点作为滑块新的左起点，这样就保证了滑块中所有单词都是小于等于额定出现次数，这样也保证了count计数的有效性）
<span class="number">5.</span> 如果当前count计数等于单词集合长度，记录下left左起点的位置后，将left右移，当前滑块中相应单词计数减<span class="number">1</span>，总计数减<span class="number">1</span>，继续循环。
</code></pre><p>复杂度：因为每次扫描的时间复杂度是O(2<em>n/l)，(每个单词不会被访问多于两次，一次是窗口右端，一次是窗口左端)，总共扫描l次（i=0, …, l-1)，所以总复杂度是O(2</em>n/l<em>l)=O(n)，是一个线性算法。空间复杂度是字典的大小，即O(m</em>l)，其中m是字典的单词数量。</p>
<p>代码中给出了易超时的测试用例。<br>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubstringWithConcatenationOfAllWords</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        String s = "barfoothefoobarman";</span></span><br><span class="line"><span class="comment">//        String[] words = &#123;"foo", "bar"&#125;;</span></span><br><span class="line"><span class="comment">//        String s = "pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefgvimwbxcbzvaibspdjnrpqtyeilkcspknyylbwndvkffmzuriilxagyerjptbgeqgebiaqnvdubrtxibhvakcyotkfonmseszhczapxdlauexehhaireihxsplgdgmxfvaevrbadbwjbdrkfbbjjkgcztkcbwagtcnrtqryuqixtzhaakjlurnumzyovawrcjiwabuwretmdamfkxrgqgcdgbrdbnugzecbgyxxdqmisaqcyjkqrntxqmdrczxbebemcblftxplafnyoxqimkhcykwamvdsxjezkpgdpvopddptdfbprjustquhlazkjfluxrzopqdstulybnqvyknrchbphcarknnhhovweaqawdyxsqsqahkepluypwrzjegqtdoxfgzdkydeoxvrfhxusrujnmjzqrrlxglcmkiykldbiasnhrjbjekystzilrwkzhontwmehrfsrzfaqrbbxncphbzuuxeteshyrveamjsfiaharkcqxefghgceeixkdgkuboupxnwhnfigpkwnqdvzlydpidcljmflbccarbiegsmweklwngvygbqpescpeichmfidgsjmkvkofvkuehsmkkbocgejoiqcnafvuokelwuqsgkyoekaroptuvekfvmtxtqshcwsztkrzwrpabqrrhnlerxjojemcxel";</span></span><br><span class="line"><span class="comment">//        String[] words = &#123;"dhvf","sind","ffsl","yekr","zwzq","kpeo","cila","tfty","modg","ztjg","ybty","heqg","cpwo","gdcj","lnle","sefg","vimw","bxcb"&#125;;</span></span><br><span class="line"><span class="comment">//        String s = "wordgoodgoodgoodbestword";</span></span><br><span class="line"><span class="comment">//        String[] words = &#123;"word","good","best","good"&#125;;</span></span><br><span class="line">        <span class="comment">//TODO 下面这组答案输出[]，但易超时</span></span><br><span class="line">        String s =</span><br><span class="line">                <span class="string">"abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababab"</span>;</span><br><span class="line">        String[] words = &#123;<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,</span><br><span class="line">                <span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,</span><br><span class="line">                <span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ab"</span>,<span class="string">"ba"</span>&#125;</span><br><span class="line">;       System.out.println(<span class="string">"s.length():"</span> + s.length());</span><br><span class="line">;       System.out.println(<span class="string">"words.length:"</span> + words.length);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        List&lt;Integer&gt; indexes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        indexes = <span class="keyword">new</span> SubstringWithConcatenationOfAllWords().findSubstring(s, words);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : indexes) System.out.print(i + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">//        for (char[] chars : permutatedList)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(String.valueOf(chars));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** TODO</span><br><span class="line">     * http://segmentfault.com/a/1190000002625580</span><br><span class="line">     * 首先是要明确用滑块的概念来解决，始终保持L集合中的字符串在滑块中都只出现了一次，</span><br><span class="line">     * 当然设置一个总计数count，当cout等于L集合长度时，即使找了一段符合要求的字符串。</span><br><span class="line">     * 需要用到的内存空间：</span><br><span class="line">     1. 两张哈希表，一张保存L集合中的单词，一张用来保存当前滑块中的单词，key为单词，value为出现次数</span><br><span class="line">     2. count计数，保存当前滑块中的单词总数</span><br><span class="line">     3. left标记，记录滑块左起点</span><br><span class="line">     * 思路：</span><br><span class="line">     1. 遍历一遍单词数组L集合，构造总单词表</span><br><span class="line">     2. 以单词长度为步长，遍历目标字符串，如果当前单词在总单词表内，则进入步骤3；</span><br><span class="line">        反之，则清空当前滑块单词表，将cout置零，将left移动到下一位置</span><br><span class="line">     3. 当前滑块档次表中的相应单词计数加1，检查该单词的计数是否小于等于总单词表中该单词的总数，</span><br><span class="line">        如果是，则将count计数加1，进入步骤5；反之，进入步骤4</span><br><span class="line">     4. 根据左起点left收缩滑块，直到收缩到与当前单词相同的字符串片段，将其剔除之后，滑块的收缩工作完成。</span><br><span class="line">        （收缩滑块，这是因为当前滑块中有单词的出现次数超过了额定的出现次数，</span><br><span class="line">        那么就是需要收缩滑块来剔除这个单词，相当于是从滑块的左起点开始寻找该单词，找到之后，</span><br><span class="line">        将该单词的右端点作为滑块新的左起点，这样就保证了滑块中所有单词都是小于等于额定出现次数，</span><br><span class="line">        这样也保证了count计数的有效性）</span><br><span class="line">     5. 如果当前count计数等于单词集合长度，记录下left左起点的位置后，将left右移，</span><br><span class="line">        当前滑块中相应单词计数减1，总计数减1，继续循环。</span><br><span class="line">     *</span><br><span class="line">     * 复杂度：因为每次扫描的时间复杂度是O(2*n/l)</span><br><span class="line">     * (每个单词不会被访问多于两次，一次是窗口右端，一次是窗口左端)，总共扫描l次（i=0, ..., l-1)，</span><br><span class="line">     * 所以总复杂度是O(2*n/l*l)=O(n)，是一个线性算法。</span><br><span class="line">     * 空间复杂度是字典的大小，即O(m*l)，其中m是字典的单词数量。</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@param</span> words</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; indexes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || words == <span class="keyword">null</span> || words.length == <span class="number">0</span>) <span class="keyword">return</span> indexes;</span><br><span class="line">        HashMap&lt;String,Integer&gt; book = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; words.length; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (book.containsKey(words[k])) book.put(words[k], book.get(words[k]) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> book.put(words[k], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words[<span class="number">0</span>].length(); i++) &#123;</span><br><span class="line">            HashMap&lt;String,Integer&gt; curMap = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> left = i;   <span class="comment">//left标记，记录滑块左起点</span></span><br><span class="line">            <span class="comment">//以单词长度为步长，遍历目标字符串</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= s.length() - words[<span class="number">0</span>].length(); j += words[<span class="number">0</span>].length()) &#123;</span><br><span class="line">                String str = s.substring(j, j + words[<span class="number">0</span>].length());</span><br><span class="line">                <span class="keyword">if</span>(book.containsKey(str)) &#123; <span class="comment">//当前单词在总单词表内</span></span><br><span class="line">                    <span class="keyword">if</span>(curMap.containsKey(str)) curMap.put(str, curMap.get(str) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> curMap.put(str, <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//该单词的计数 &lt;= 单词表中该单词的总数</span></span><br><span class="line">                    <span class="keyword">if</span>(curMap.get(str) &lt;= book.get(str)) count++;</span><br><span class="line">                    <span class="comment">//该单词的计数 &gt; 单词表中该单词的总数</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span>(curMap.get(str) &gt; book.get(str)) &#123;</span><br><span class="line">                            <span class="comment">//根据左起点left收缩滑块</span></span><br><span class="line">                            String temp = s.substring(left, left + words[<span class="number">0</span>].length());</span><br><span class="line">                            <span class="comment">//直到收缩到与当前单词相同的字符串片段</span></span><br><span class="line">                            <span class="keyword">if</span>(curMap.containsKey(temp)) &#123;</span><br><span class="line">                                <span class="comment">//将其剔除之后，滑块的收缩工作完成</span></span><br><span class="line">                                curMap.put(temp, curMap.get(temp) - <span class="number">1</span>);</span><br><span class="line">                                <span class="keyword">if</span>(curMap.get(temp) &lt; book.get(temp)) count--;</span><br><span class="line">                            &#125;</span><br><span class="line">                            left += words[<span class="number">0</span>].length();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果当前count计数等于单词集合长度</span></span><br><span class="line">                    <span class="keyword">if</span>(count == words.length) &#123;</span><br><span class="line">                        <span class="comment">//记录下left左起点的位置</span></span><br><span class="line">                        indexes.add(left);</span><br><span class="line">                        <span class="comment">//将left右移</span></span><br><span class="line">                        String temp = s.substring(left, left + words[<span class="number">0</span>].length());</span><br><span class="line">                        <span class="comment">//当前滑块中相应单词计数减1</span></span><br><span class="line">                        <span class="keyword">if</span>(curMap.containsKey(temp)) curMap.put(temp, curMap.get(temp) - <span class="number">1</span>);</span><br><span class="line">                        <span class="comment">//总计数减1</span></span><br><span class="line">                        count--;</span><br><span class="line">                        left += words[<span class="number">0</span>].length();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//当前单词不在总单词表内</span></span><br><span class="line">                    curMap.clear();</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    left = j + words[<span class="number">0</span>].length();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * TODO 没有采用窗口方法，超时</span><br><span class="line">     * 超时用例：</span><br><span class="line">     * "ababababababababababa..."</span><br><span class="line">     * &#123;"ab","ba","ab","ba", ...&#125;</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@param</span> words</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring1</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; indexes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || words == <span class="keyword">null</span> || words.length == <span class="number">0</span>) <span class="keyword">return</span> indexes;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length() - words.length * words[<span class="number">0</span>].length(); i++)&#123;<span class="comment">//TODO 注意取等</span></span><br><span class="line">            <span class="comment">//也可以采用HashMap.clone()进行浅拷贝（针对基本类型和String类型可以说是“深拷贝”）</span></span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; words.length; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(words[k]) != <span class="keyword">null</span>) map.put(words[k], map.get(words[k]) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> map.put(words[k], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> headIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.length(); j += words[<span class="number">0</span>].length())&#123; <span class="comment">//匹配内的循环，步长为一个word长度</span></span><br><span class="line">                String temp = s.substring(j, j + words[<span class="number">0</span>].length());</span><br><span class="line">                <span class="keyword">if</span> (map.get(temp) != <span class="keyword">null</span> &amp;&amp; map.get(temp) &gt; <span class="number">0</span>)&#123;    <span class="comment">//匹配words中存在的字</span></span><br><span class="line">                    map.put(temp, map.get(temp) - <span class="number">1</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">1</span>)&#123;    <span class="comment">//标记匹配的头索引</span></span><br><span class="line">                        headIndex = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (count == words.length)&#123; <span class="comment">//全匹配</span></span><br><span class="line">                        indexes.add(headIndex);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  <span class="comment">//不匹配则跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * TODO 全排列words再匹配，超时</span><br><span class="line">     * 超时用例：</span><br><span class="line">     * "pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefgvimwbxcbzvaibspdjnrpqtyeilkcspknyylbwndvkffmzuriilxagyerjptbgeqgebiaqnvdubrtxibhvakcyotkfonmseszhczapxdlauexehhaireihxsplgdgmxfvaevrbadbwjbdrkfbbjjkgcztkcbwagtcnrtqryuqixtzhaakjlurnumzyovawrcjiwabuwretmdamfkxrgqgcdgbrdbnugzecbgyxxdqmisaqcyjkqrntxqmdrczxbebemcblftxplafnyoxqimkhcykwamvdsxjezkpgdpvopddptdfbprjustquhlazkjfluxrzopqdstulybnqvyknrchbphcarknnhhovweaqawdyxsqsqahkepluypwrzjegqtdoxfgzdkydeoxvrfhxusrujnmjzqrrlxglcmkiykldbiasnhrjbjekystzilrwkzhontwmehrfsrzfaqrbbxncphbzuuxeteshyrveamjsfiaharkcqxefghgceeixkdgkuboupxnwhnfigpkwnqdvzlydpidcljmflbccarbiegsmweklwngvygbqpescpeichmfidgsjmkvkofvkuehsmkkbocgejoiqcnafvuokelwuqsgkyoekaroptuvekfvmtxtqshcwsztkrzwrpabqrrhnlerxjojemcxel"</span><br><span class="line">     ["dhvf","sind","ffsl","yekr","zwzq","kpeo","cila","tfty","modg","ztjg","ybty","heqg","cpwo","gdcj","lnle","sefg","vimw","bxcb"]</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;<span class="keyword">char</span>[]&gt; permutatedList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring2</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; indexes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || words == <span class="keyword">null</span> || words.length == <span class="number">0</span>) <span class="keyword">return</span> indexes;</span><br><span class="line"></span><br><span class="line">        permutation(words, <span class="number">0</span>, words.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span>[] tempCombinedArray : permutatedList)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i + tempCombinedArray.length &lt; s.length())&#123;</span><br><span class="line">                    String temp = s.substring(i, i + tempCombinedArray.length);</span><br><span class="line">                    <span class="keyword">if</span> (temp.equals(String.valueOf(tempCombinedArray))) indexes.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder builder;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(String[] str, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == len - <span class="number">1</span>) &#123;</span><br><span class="line">            builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">                builder.append(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            permutatedList.add(builder.toString().toCharArray());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; len; i ++) &#123;</span><br><span class="line">                swap(str, start, i);</span><br><span class="line">                permutation(str, start + <span class="number">1</span>, len);</span><br><span class="line">                swap(str, start, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        String temp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Substring_with_Concatenation_of_All_Words_-_在字符串中查找指定字符串组合">Substring with Concatenation of All Words - 在字符串中查找指定字符串组合</h3><p><stron]]>
    </summary>
    
      <category term="LeetCode" scheme="http://ernestyj.github.io/tags/LeetCode/"/>
    
      <category term="java" scheme="http://ernestyj.github.io/tags/java/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://ernestyj.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

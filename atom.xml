<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Eugene's Blog]]></title>
  <subtitle><![CDATA[成长之旅]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://eugeneyang.com/"/>
  <updated>2016-01-12T08:15:05.752Z</updated>
  <id>http://eugeneyang.com/</id>
  
  <author>
    <name><![CDATA[Jian Yang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Decode Ways - 解码方式]]></title>
    <link href="http://eugeneyang.com/2016/01/12/Decode%20Ways%20-%20%E8%A7%A3%E7%A0%81%E6%96%B9%E5%BC%8F/"/>
    <id>http://eugeneyang.com/2016/01/12/Decode Ways - 解码方式/</id>
    <published>2016-01-12T12:44:47.000Z</published>
    <updated>2016-01-12T08:15:05.752Z</updated>
    <content type="html"><![CDATA[<h3 id="Decode_Ways_-_解码方式">Decode Ways - 解码方式</h3><p><strong>Description</strong>: A message containing letters from A-Z is being encoded to numbers using the following mapping:<br> ‘A’ -&gt; 1 ‘B’ -&gt; 2 … ‘Z’ -&gt; 26<br>Given an encoded message containing digits, determine the total number of ways to decode it.</p>
<p>For example,<br> Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12).<br> The number of ways decoding “12” is 2.</p>
<p>思路：动态规划（类似Climbing Stairs问题，注意题目的输入是合法的encode，无需考虑不合法编码）：<br>对于当前位i(number数组头部额外分配一个)，考察前两位i-1, i-2：<br>递推式number[i] = number[i-1] + number[i-2]，但有以下限制：</p>
<ol>
<li>s[i-1]!=0，否则number[i]=number[i-2]；</li>
<li>在s[i-1]!=0基础上，s[i-2]!=0 &amp;&amp; (1&lt;=s[i-2,i-1]&lt;=26)，否则number[i]=number[i-1]。</li>
</ol>
<p>参考：<a href="http://blog.csdn.net/worldwindjp/article/details/19938131" target="_blank" rel="external">http://blog.csdn.net/worldwindjp/article/details/19938131</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeWays</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 动态规划（类似Climbing Stairs问题，注意题目的输入是合法的encode，无需考虑不合法编码）：</span><br><span class="line">     * 对于当前位i(number数组头部额外分配一个)，考察前两位i-1, i-2：</span><br><span class="line">       递推式number[i] = number[i-1] + number[i-2]，但有以下限制：</span><br><span class="line">       1. s[i-1]!=0，否则number[i]=number[i-2]；</span><br><span class="line">       2. 在s[i-1]!=0基础上，s[i-2]!=0 &amp;&amp; (1&lt;=s[i-2,i-1]&lt;=26)，否则number[i]=number[i-1]。</span><br><span class="line">     * 参考：http://blog.csdn.net/worldwindjp/article/details/19938131</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span> || s.charAt(<span class="number">0</span>)==<span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>];   <span class="comment">//额外分配一个</span></span><br><span class="line">        number[<span class="number">0</span>] = number[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">//额外分配的number[0]存初始值，i从1开始</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=s.length(); i++)&#123;</span><br><span class="line">            temp = Integer.parseInt(s.substring(i-<span class="number">1</span>, i));</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="number">0</span>) number[i] = number[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i-<span class="number">2</span>) != <span class="string">'0'</span>) &#123;</span><br><span class="line">                temp = Integer.parseInt(s.substring(i-<span class="number">2</span>, i));</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span>&lt;=temp &amp;&amp; temp&lt;=<span class="number">26</span>) number[i] += number[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Decode_Ways_-_解码方式">Decode Ways - 解码方式</h3><p><strong>Description</strong>: A message containing letters from A-Z is being encoded t]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Subsets II - 求子集 II]]></title>
    <link href="http://eugeneyang.com/2016/01/11/Subsets%20II%20-%20%E6%B1%82%E5%AD%90%E9%9B%86%20II/"/>
    <id>http://eugeneyang.com/2016/01/11/Subsets II - 求子集 II/</id>
    <published>2016-01-11T12:44:47.000Z</published>
    <updated>2016-01-11T11:00:40.174Z</updated>
    <content type="html"><![CDATA[<h3 id="Subsets_II_-_求子集_II">Subsets II - 求子集 II</h3><p><strong>Description</strong>: Given a collection of integers that might contain duplicates, nums, return all possible subsets.</p>
<p>Note:<br> Elements in a subset must be in non-descending order.<br> The solution set must not contain duplicate subsets.</p>
<p> For example,<br> If nums = [1,2,2], a solution is:<br> [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</p>
<p>方法一：位图法，与Subsets位图法思路一致，再添加判重部分即可。</p>
<p>方法二：回溯法，与Subsets回溯法思路一致，回溯时跳过重复数字即可。效率最高。<br>参考：<a href="http://bangbingsyb.blogspot.com/2014/11/leetcode-subsets-i-ii.html" target="_blank" rel="external">http://bangbingsyb.blogspot.com/2014/11/leetcode-subsets-i-ii.html</a></p>
<p>方法三：在原集合上添加数字构建子集的方法，与Subsets这种思路也一致，多了判重部分。效率次高。<br>参考：<a href="http://www.programcreek.com/2013/01/leetcode-subsets-ii-java/" target="_blank" rel="external">http://www.programcreek.com/2013/01/leetcode-subsets-ii-java/</a></p>
<p>完整的java代码如下（含三种方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubsetsII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="comment">//法一</span></span><br><span class="line"><span class="comment">//        List&lt;List&lt;Integer&gt;&gt; res = new SubsetsII().subsetsWithDup(nums);</span></span><br><span class="line">        <span class="comment">//法二</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> SubsetsII().subsetsWithDup1(nums);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; ints : res)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : ints) System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位图法：与Subsets位图法思路一致，再添加判重部分即可</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span> &lt;&lt; len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//查看第一层循环任意一种取值中哪一位是1；如果是1，对应的字符就存在</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=len; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span> ( (i&amp;(<span class="number">1</span> &lt;&lt; k-<span class="number">1</span>)) != <span class="number">0</span> ) temp.add(nums[k-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!result.contains(temp)) <span class="comment">//判重</span></span><br><span class="line">                result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 回溯法</span><br><span class="line">     * 参考：http://bangbingsyb.blogspot.com/2014/11/leetcode-subsets-i-ii.html</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup1(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; sol = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(sol));   <span class="comment">//额外添加空集</span></span><br><span class="line">        backTrack(nums, <span class="number">0</span>, result, sol);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; sol)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;start &amp;&amp; nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;    <span class="comment">//跳过再次重复的数字</span></span><br><span class="line">            sol.add(nums[i]);</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(sol));</span><br><span class="line">            backTrack(nums, i+<span class="number">1</span>, result, sol);</span><br><span class="line">            sol.remove(sol.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在原集合上添加数字构建子集的方法，参考http://www.programcreek.com/2013/01/leetcode-subsets-ii-java/</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup2(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; prev = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//get existing sets</span></span><br><span class="line">            <span class="keyword">if</span> (i == nums.length - <span class="number">1</span> || nums[i] != nums[i + <span class="number">1</span>] || prev.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                prev = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; result.size(); j++) &#123;</span><br><span class="line">                    prev.add(<span class="keyword">new</span> ArrayList&lt;&gt;(result.get(j)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//add current number to each element of the set</span></span><br><span class="line">            <span class="keyword">for</span> (List&lt;Integer&gt; temp : prev) &#123;</span><br><span class="line">                temp.add(<span class="number">0</span>, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//add each single number as a set, only if current element is different with previous</span></span><br><span class="line">            <span class="keyword">if</span> (i == nums.length - <span class="number">1</span> || nums[i] != nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                temp.add(nums[i]);</span><br><span class="line">                prev.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//add all set created in this iteration</span></span><br><span class="line">            <span class="keyword">for</span> (List&lt;Integer&gt; temp : prev) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//add empty set</span></span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Subsets_II_-_求子集_II">Subsets II - 求子集 II</h3><p><strong>Description</strong>: Given a collection of integers that might contain dupl]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gray Code - 格雷码]]></title>
    <link href="http://eugeneyang.com/2016/01/10/Gray%20Code%20-%20%E6%A0%BC%E9%9B%B7%E7%A0%81/"/>
    <id>http://eugeneyang.com/2016/01/10/Gray Code - 格雷码/</id>
    <published>2016-01-10T12:44:47.000Z</published>
    <updated>2016-01-10T11:00:09.363Z</updated>
    <content type="html"><![CDATA[<h3 id="Gray_Code_-_格雷码">Gray Code - 格雷码</h3><p><strong>Description</strong>: The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p> For example, given n = 2, return [0,1,3,2].</p>
<p>注意：格雷码是唯一的（如果每次只是与上一个数有一个位不同的话，则会有很多种组合结果）。因此另一种解法是数学解：第i个数可以由如下公式产生，(i&gt;&gt;1)^i。</p>
<p>这里主要讨论递归法。<br>规律：n位格雷码的前一半是：n-1位的所有格雷码；而后一半是：前一半逆序后，均加上2^(n-1)。<br>示例：n=3: 000, 001, 011, 010 | 110, 111, 101, 100 (0, 1, 3, 2 | 6, 7, 5, 4)</p>
<p>参考：<a href="http://fisherlei.blogspot.com/2012/12/leetcode-gray-code.html" target="_blank" rel="external">http://fisherlei.blogspot.com/2012/12/leetcode-gray-code.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrayCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** http://fisherlei.blogspot.com/2012/12/leetcode-gray-code.html</span><br><span class="line">     * 注意：格雷码是唯一的（如果每次只是与上一个数有一个位不同的话，则会有很多种组合结果）。</span><br><span class="line">     因此另一种解法是数学解：第i个数可以由如下公式产生，(i&gt;&gt;1)^i。</span><br><span class="line">     * 递归法：</span><br><span class="line">     * 规律：n位格雷码的前一半是：n-1位的所有格雷码；而后一半是：前一半逆序后，均加上2^(n-1)。</span><br><span class="line">     * 示例：n=3: 000, 001, 011, 010 | 110, 111, 101, 100 (0, 1, 3, 2 | 6, 7, 5, 4)</span><br><span class="line">     * <span class="doctag">@param</span> n</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        result = grayCode(n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> adds = <span class="number">1</span> &lt;&lt; (n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> size = result.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=size-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            result.add(result.get(i) + adds);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Gray_Code_-_格雷码">Gray Code - 格雷码</h3><p><strong>Description</strong>: The gray code is a binary numeral system where two successive ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Merge Sorted Array - 合并有序数组]]></title>
    <link href="http://eugeneyang.com/2016/01/09/Merge%20Sorted%20Array%20-%20%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://eugeneyang.com/2016/01/09/Merge Sorted Array - 合并有序数组/</id>
    <published>2016-01-09T12:44:47.000Z</published>
    <updated>2016-01-09T07:09:39.332Z</updated>
    <content type="html"><![CDATA[<h3 id="Merge_Sorted_Array_-_合并有序数组">Merge Sorted Array - 合并有序数组</h3><p><strong>Description</strong>: Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.</p>
<p>思路：双指针遍历。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortedArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] num1Copy = Arrays.copyOf(nums1, m);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (num1Copy[i] &lt; nums2[j])&#123;</span><br><span class="line">                nums1[i+j] = num1Copy[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[i+j] = nums2[j];</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span> (!(j&lt;n)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;m)&#123;</span><br><span class="line">            nums1[i+j] = num1Copy[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j&lt;n)&#123;</span><br><span class="line">            nums1[i+j] = nums2[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Merge_Sorted_Array_-_合并有序数组">Merge Sorted Array - 合并有序数组</h3><p><strong>Description</strong>: Given two sorted integer arrays nums1 ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scramble String - 字符串重组]]></title>
    <link href="http://eugeneyang.com/2016/01/08/Scramble%20String%20-%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8D%E7%BB%84/"/>
    <id>http://eugeneyang.com/2016/01/08/Scramble String - 字符串重组/</id>
    <published>2016-01-08T12:44:47.000Z</published>
    <updated>2016-01-08T07:05:21.834Z</updated>
    <content type="html"><![CDATA[<h3 id="Scramble_String_-_字符串重组">Scramble String - 字符串重组</h3><p><strong>Description</strong>: Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.</p>
<p>原题链接：<a href="https://leetcode.com/problems/scramble-string/" target="_blank" rel="external">https://leetcode.com/problems/scramble-string/</a></p>
<p>题解：<br>方法一：递归解法：时间复杂度最差为O(3^n)，要通过OJ需要加上剪枝条件：把两个字符串的字符排序后，然后比较是否相同。</p>
<p>方法二：三维动态规划解法：提出维护量res[i][j][n]，其中i是s1的起始字符，j是s2的起始字符，而n是当前的字符串长度，res[i][j][len]表示的是以i和j分别为s1和s2起点的长度为len的字符串是不是互为scramble。</p>
<p>递推式：首先是把当前s1[i…i+len-1]字符串劈一刀分成两部分，然后分两种情况：<br>第一种是左边和s2[j…j+len-1]左边部分是不是scramble，以及右边和s2[j…j+len-1]右边部分是不是scramble；<br>第二种情况是左边和s2[j…j+len-1]右边部分是不是scramble，以及右边和s2[j…j+len-1]左边部分是不是scramble。<br>如果以上两种情况有一种成立，说明s1[i…i+len-1]和s2[j…j+len-1]是scramble的。<br>上面说的是劈一刀的情况，对于s1[i…i+len-1]我们有len-1种劈法，在这些劈法中只要有一种成立，那么两个串就是scramble的。</p>
<p>总结：res[i][j][len] |= (res[i][j][k]&amp;&amp;res[i+k][j+k][len-k] || res[i][j+len-k][k]&amp;&amp;res[i+k][j][len-k]),1&lt;=k&lt;len，也就是对于所有len-1种劈法的结果求或运算。</p>
<p>复杂度：因为信息都是计算过的，对于每种劈法只需要常量操作，因此求解递推式需要线性时间（因为len-1种劈法）。如此总时间复杂度因为是三维动态规划需要三层循环，加上每一步需要线行时间求解递推式，所以是O(n\^4)。空间复杂度是O(n\^3)。</p>
<p>参考：<a href="http://blog.csdn.net/fightforyourdream/article/details/17707187" target="_blank" rel="external">http://blog.csdn.net/fightforyourdream/article/details/17707187</a></p>
<p>完整的java代码如下（不包括方法一）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScrambleString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://blog.csdn.net/fightforyourdream/article/details/17707187</span><br><span class="line">     * 递归解法：时间复杂度最差为O(3^n)，要通过OJ需要加上剪枝条件：把两个字符串的字符排序后，然后比较是否相同。</span><br><span class="line">     * 三维动态规划解法：提出维护量res[i][j][n]，其中i是s1的起始字符，j是s2的起始字符，而n是当前的字符串长度，</span><br><span class="line">      res[i][j][len]表示的是以i和j分别为s1和s2起点的长度为len的字符串是不是互为scramble。</span><br><span class="line">     * 递推式：首先是把当前s1[i...i+len-1]字符串劈一刀分成两部分，然后分两种情况：</span><br><span class="line">      第一种是左边和s2[j...j+len-1]左边部分是不是scramble，以及右边和s2[j...j+len-1]右边部分是不是scramble；</span><br><span class="line">      第二种情况是左边和s2[j...j+len-1]右边部分是不是scramble，以及右边和s2[j...j+len-1]左边部分是不是scramble。</span><br><span class="line">      如果以上两种情况有一种成立，说明s1[i...i+len-1]和s2[j...j+len-1]是scramble的。</span><br><span class="line">     上面说的是劈一刀的情况，对于s1[i...i+len-1]我们有len-1种劈法，在这些劈法中只要有一种成立，那么两个串就是scramble的。</span><br><span class="line">     总结：res[i][j][len] |= (res[i][j][k]&amp;&amp;res[i+k][j+k][len-k] || res[i][j+len-k][k]&amp;&amp;res[i+k][j][len-k]),1&lt;=k&lt;len，</span><br><span class="line">     也就是对于所有len-1种劈法的结果求或运算。</span><br><span class="line">     * 复杂度：因为信息都是计算过的，对于每种劈法只需要常量操作，因此求解递推式需要线性时间（因为len-1种劈法）。</span><br><span class="line">     如此总时间复杂度因为是三维动态规划需要三层循环，加上每一步需要线行时间求解递推式，所以是O(n^4)。空间复杂度是O(n^3)。</span><br><span class="line">     * <span class="doctag">@param</span> s1</span><br><span class="line">     * <span class="doctag">@param</span> s2</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s1.length();</span><br><span class="line">        <span class="keyword">if</span>(len != s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][][] canScramble = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len][len+<span class="number">1</span>];   <span class="comment">// i,j with sub length</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;  <span class="comment">// subLen=1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len; j++) &#123;</span><br><span class="line">                <span class="comment">// substring start from i with length 1, compared with substring start from j with length 1</span></span><br><span class="line">                canScramble[i][j][<span class="number">1</span>] = s1.charAt(i) == s2.charAt(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> subLen=<span class="number">2</span>; subLen&lt;=len; subLen++) &#123;</span><br><span class="line">            <span class="comment">// (end_pos=i+subLen-1) &lt;= len-1, so i &lt;= len-subLen</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=len-subLen; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=len-subLen; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>; p&lt;subLen; p++) &#123;   <span class="comment">// split position</span></span><br><span class="line">                        canScramble[i][j][subLen] |= (canScramble[i][j][p] &amp;&amp; canScramble[i+p][j+p][subLen-p]) ||</span><br><span class="line">                                (canScramble[i][j+subLen-p][p] &amp;&amp; canScramble[i+p][j][subLen-p]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> canScramble[<span class="number">0</span>][<span class="number">0</span>][len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Scramble_String_-_字符串重组">Scramble String - 字符串重组</h3><p><strong>Description</strong>: Given a string s1, we may represent it as a bi]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Partition List - 划分链表]]></title>
    <link href="http://eugeneyang.com/2016/01/07/Partition%20List%20-%20%E5%88%92%E5%88%86%E9%93%BE%E8%A1%A8/"/>
    <id>http://eugeneyang.com/2016/01/07/Partition List - 划分链表/</id>
    <published>2016-01-07T12:44:47.000Z</published>
    <updated>2016-01-07T03:48:11.949Z</updated>
    <content type="html"><![CDATA[<h3 id="Partition_List_-_划分链表">Partition List - 划分链表</h3><p><strong>Description</strong>: Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p> You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p> For example,<br> Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br> return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
<p>思路：</p>
<ol>
<li>从左往右扫描，找到第一个大于x的节点，然后再在该节点左边不断插入小于x的元素。</li>
<li>由于不要求sort，只要求partition。可以建立一个新的链表l2。遍历原链表l1的每个节点p。<br>  p-&gt;val &lt; x，保留。<br>  p-&gt;val &gt;= x，从l1中移出并插入l2。<br>可以参考：<a href="http://bangbingsyb.blogspot.com/2014/11/leetcode-partition-list.html" target="_blank" rel="external">http://bangbingsyb.blogspot.com/2014/11/leetcode-partition-list.html</a></li>
</ol>
<p>完整的java代码如下（不包括方法2）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Definition for singly-linked list.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从左往右扫描，找到第一个大于x的节点，然后再在该节点左边不断插入小于x的元素。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition1</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode p = dummy;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">boolean</span> foundBound = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span> &amp;&amp; p.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.next.val &gt;= x) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!foundBound) &#123;</span><br><span class="line">                    cur = p;</span><br><span class="line">                    foundBound = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.next.val &lt; x)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!foundBound)&#123;</span><br><span class="line">                    p = p.next; <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode moveNode = p.next;</span><br><span class="line">                p.next = moveNode.next;</span><br><span class="line"></span><br><span class="line">                moveNode.next = cur.next;</span><br><span class="line">                cur.next = moveNode;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Partition_List_-_划分链表">Partition List - 划分链表</h3><p><strong>Description</strong>: Given a linked list and a value x, partition it su]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maximal Rectangle - 矩阵中的最大矩形]]></title>
    <link href="http://eugeneyang.com/2016/01/06/Maximal%20Rectangle%20-%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <id>http://eugeneyang.com/2016/01/06/Maximal Rectangle - 矩阵中的最大矩形/</id>
    <published>2016-01-06T12:44:47.000Z</published>
    <updated>2016-01-06T08:17:40.079Z</updated>
    <content type="html"><![CDATA[<h3 id="Maximal_Rectangle_-_矩阵中的最大矩形">Maximal Rectangle - 矩阵中的最大矩形</h3><p><strong>Description</strong>: Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area.</p>
<p>思路：<a href="http://www.cnblogs.com/lichen782/p/leetcode_maximal_rectangle.html" target="_blank" rel="external">http://www.cnblogs.com/lichen782/p/leetcode_maximal_rectangle.html</a> 中给出了O(n^3)的普通方法（但会大数据超时）。高效的方法：转化为Largest Rectangle in Histogram的问题，时间复杂为O(n^2).</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximalRectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.cnblogs.com/lichen782/p/leetcode_maximal_rectangle.html 中给出了O(n^3)的普通方法（会大数据超时）。</span><br><span class="line">     * 高效的方法：转化为Largest Rectangle in Histogram的问题，时间复杂为O(n^2).</span><br><span class="line">     * <span class="doctag">@param</span> matrix</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//实际上height可以分配一维数组存储</span></span><br><span class="line">        <span class="keyword">int</span>[][] height = <span class="keyword">new</span> <span class="keyword">int</span>[m][n + <span class="number">1</span>]; <span class="comment">//末尾多加一个dummy元素0</span></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//矩阵按行转化为柱状图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                    height[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    height[i][j] = (i == <span class="number">0</span>) ? <span class="number">1</span> : height[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算每个柱状图的最大矩形面积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> area = maxAreaInHist(height[i]);</span><br><span class="line">            <span class="keyword">if</span> (area &gt; maxArea) &#123;</span><br><span class="line">                maxArea = area;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Largest Rectangle in Histogram算法，传入的height数组最后一个元素是多加的dummy元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxAreaInHist</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; height.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() || height[stack.peek()] &lt;= height[i]) &#123;</span><br><span class="line">                stack.push(i++);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> t = stack.pop();</span><br><span class="line">                maxArea = Math.max(maxArea, height[t] * (stack.isEmpty() ? i : i - stack.peek() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Maximal_Rectangle_-_矩阵中的最大矩形">Maximal Rectangle - 矩阵中的最大矩形</h3><p><strong>Description</strong>: Given a 2D binary matrix filled with]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Largest Rectangle In Histogram - 柱状图中的最大长方形]]></title>
    <link href="http://eugeneyang.com/2016/01/05/Largest%20Rectangle%20In%20Histogram%20-%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E6%96%B9%E5%BD%A2/"/>
    <id>http://eugeneyang.com/2016/01/05/Largest Rectangle In Histogram - 柱状图中的最大长方形/</id>
    <published>2016-01-05T12:44:47.000Z</published>
    <updated>2016-01-05T05:45:41.925Z</updated>
    <content type="html"><![CDATA[<h3 id="Largest_Rectangle_In_Histogram_-_柱状图中的最大长方形">Largest Rectangle In Histogram - 柱状图中的最大长方形</h3><p><strong>Description</strong>: Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p> For example,<br> Given height = [2,1,5,6,2,3],<br> return 10.</p>
<p>方法1：维护一个栈，栈内只存高度递增的条形索引。这个动态栈的特点是：栈内元素一定比当前i指向的元素小。另一个关键点是弹栈过程中面积的计算（高<em>宽）：h[t] </em> (stack.isEmpty() ? i : i - stack.peek() - 1)。时间复杂度：O(n)。</p>
<p>方法2：从左往右扫描，对合适的右边界（此条形大于其右边条形），再往左遍历面积。时间复杂度：O(n*n)。</p>
<p>参考：<a href="http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html" target="_blank" rel="external">http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargestRectangleInHistogram</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 参考：http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html</span><br><span class="line">     * 方法1：维护一个栈，栈内只存高度递增的条形索引。这个动态栈的特点是：栈内元素一定比当前i指向的元素小。</span><br><span class="line">     * 另一个关键点是弹栈过程中面积的计算（高*宽）：h[t] * (stack.isEmpty() ? i : i - stack.peek() - 1)。</span><br><span class="line">     * 时间复杂度：O(n)。</span><br><span class="line">     * 方法2：从左往右扫描，对合适的右边界（此条形大于其右边条形），再往左遍历面积。时间复杂度：O(n*n)。</span><br><span class="line">     * <span class="doctag">@param</span> height</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] h = Arrays.copyOf(height, height.length + <span class="number">1</span>); <span class="comment">//末尾添加dummy元素0</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; h.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty() || h[stack.peek()] &lt;= h[i])&#123; <span class="comment">//维护高度递增条形索引栈</span></span><br><span class="line">                stack.push(i++);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//当前元素小于栈顶元素</span></span><br><span class="line">                <span class="keyword">int</span> p = stack.pop();</span><br><span class="line">                <span class="comment">//高h[p]，宽stack.isEmpty() ? i : i - stack.peek() - 1</span></span><br><span class="line">                maxArea = Math.max(maxArea, h[p] * (stack.isEmpty() ? i : i - stack.peek() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Largest_Rectangle_In_Histogram_-_柱状图中的最大长方形">Largest Rectangle In Histogram - 柱状图中的最大长方形</h3><p><strong>Description</strong>: Given ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Remove Duplicates from Sorted List - 移除有序链表中的重复元素]]></title>
    <link href="http://eugeneyang.com/2016/01/04/Remove%20Duplicates%20from%20Sorted%20List%20-%20%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://eugeneyang.com/2016/01/04/Remove Duplicates from Sorted List - 移除有序链表中的重复元素/</id>
    <published>2016-01-04T12:44:47.000Z</published>
    <updated>2016-01-04T05:28:30.613Z</updated>
    <content type="html"><![CDATA[<h3 id="Remove_Duplicates_from_Sorted_List_-_移除有序链表中的重复元素">Remove Duplicates from Sorted List - 移除有序链表中的重复元素</h3><p><strong>Description</strong>: Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p> For example,<br> Given 1-&gt;1-&gt;2, return 1-&gt;2.<br> Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>
<p>思路：直接往后遍历，根据前后节点值是否相等做相应处理。或者用Remove Duplicates from Sorted List II 的思路，遍历中探测当前节点的下两个节点。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesFromSortedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Definition for singly-linked list.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val == p.next.val)&#123;</span><br><span class="line">                p.next = p.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p.next; <span class="comment">//TODO 只有值不同时才往下走</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用RemoveDuplicatesFromSortedListII思路</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="keyword">null</span> &amp;&amp; p.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next.val == p.next.next.val)&#123;</span><br><span class="line">                <span class="keyword">int</span> dup = p.next.val;</span><br><span class="line">                p = p.next; <span class="comment">//与RemoveDuplicatesFromSortedListII的唯一区别，多了此语句，来存储重复节点一次</span></span><br><span class="line">                <span class="keyword">while</span>(p.next!=<span class="keyword">null</span> &amp;&amp; p.next.val==dup)&#123;</span><br><span class="line">                    p.next = p.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Remove_Duplicates_from_Sorted_List_-_移除有序链表中的重复元素">Remove Duplicates from Sorted List - 移除有序链表中的重复元素</h3><p><strong>Description</str]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Remove Duplicates from Sorted List II - 移除有序链表中的重复元素II]]></title>
    <link href="http://eugeneyang.com/2016/01/03/Remove%20Duplicates%20from%20Sorted%20List%20II%20-%20%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <id>http://eugeneyang.com/2016/01/03/Remove Duplicates from Sorted List II - 移除有序链表中的重复元素II/</id>
    <published>2016-01-03T12:44:47.000Z</published>
    <updated>2016-01-04T05:23:45.155Z</updated>
    <content type="html"><![CDATA[<h3 id="Remove_Duplicates_from_Sorted_List_II_-_移除有序链表中的重复元素II">Remove Duplicates from Sorted List II - 移除有序链表中的重复元素II</h3><p><strong>Description</strong>: Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p> For example,<br> Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br> Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p>
<p>思路：遍历中探测当前节点的下两个节点。<br>心得：这道题刚做的时候，思路非常不清晰，导致写到后面节点间关系理不清，算法无法写下去。对于链表类型的题目，要格外注意节点间关系，引入头节点前的dummy节点是很常用的技巧。</p>
<p>参考：<a href="http://www.programcreek.com/2014/06/leetcode-remove-duplicates-from-sorted-list-ii-java/。" target="_blank" rel="external">http://www.programcreek.com/2014/06/leetcode-remove-duplicates-from-sorted-list-ii-java/。</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesFromSortedListII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Definition for singly-linked list.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 遍历中探测当前节点的下两个节点</span><br><span class="line">     * http://www.programcreek.com/2014/06/leetcode-remove-duplicates-from-sorted-list-ii-java/</span><br><span class="line">     * <span class="doctag">@param</span> head</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="keyword">null</span> &amp;&amp; p.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next.val == p.next.next.val)&#123;</span><br><span class="line">                <span class="keyword">int</span> dup = p.next.val;</span><br><span class="line">                <span class="keyword">while</span>(p.next!=<span class="keyword">null</span> &amp;&amp; p.next.val==dup)&#123;</span><br><span class="line">                    p.next = p.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Remove_Duplicates_from_Sorted_List_II_-_移除有序链表中的重复元素II">Remove Duplicates from Sorted List II - 移除有序链表中的重复元素II</h3><p><strong>Descri]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Search In Rotated Sorted Array II]]></title>
    <link href="http://eugeneyang.com/2016/01/02/Search%20In%20Rotated%20Sorted%20Array%20II/"/>
    <id>http://eugeneyang.com/2016/01/02/Search In Rotated Sorted Array II/</id>
    <published>2016-01-02T12:44:47.000Z</published>
    <updated>2016-01-02T10:49:03.084Z</updated>
    <content type="html"><![CDATA[<h3 id="Search_In_Rotated_Sorted_Array_II">Search In Rotated Sorted Array II</h3><p><strong>Description</strong>: Follow up for “Search in Rotated Sorted Array”:<br> What if duplicates are allowed?<br> Would this affect the run-time complexity? How and why?<br> Write a function to determine if a given target is in the array.</p>
<p>思路：与Search In Rotated Sorted Array一致，只是当有重复数字，会存在A[m] = A[r]的情况。此时右半序列可能是sorted，也可能并没有sorted，如下例子。<br>     3 1 2 3 3 3 3<br>     3 3 3 3 1 2 3<br>     所以当A[m] = A[r] != target时，无法排除一半的序列，而只能排除掉A[r]，此时只能搜寻A[l : r-1]。<br>     正因为这个变化，在最坏情况下，算法的复杂度从O(logn)退化成了O(n)：例如序列 2 2 2 2 2 2 2 中寻找target = 1。</p>
<p>参考：<a href="http://bangbingsyb.blogspot.com/2014/11/leetcode-search-in-rotated-sorted-array.html。" target="_blank" rel="external">http://bangbingsyb.blogspot.com/2014/11/leetcode-search-in-rotated-sorted-array.html。</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchInRotatedSortedArrayII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> isFound = <span class="keyword">new</span> SearchInRotatedSortedArrayII().search(nums, <span class="number">0</span>);</span><br><span class="line">        System.out.println(isFound);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 当有重复数字，会存在A[m] = A[r]的情况。此时右半序列可能是sorted，也可能并没有sorted，如下例子。</span><br><span class="line">     3 1 2 3 3 3 3</span><br><span class="line">     3 3 3 3 1 2 3</span><br><span class="line">     所以当A[m] = A[r] != target时，无法排除一半的序列，而只能排除掉A[r]，此时只能搜寻A[l : r-1]</span><br><span class="line">     正因为这个变化，在最坏情况下，算法的复杂度从O(logn)退化成了O(n)：例如序列 2 2 2 2 2 2 2 中寻找target = 1。</span><br><span class="line">     参考：http://bangbingsyb.blogspot.com/2014/11/leetcode-search-in-rotated-sorted-array.html</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@param</span> target</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[m]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt; nums[r]) &#123;    <span class="comment">//m~r有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[m] &lt; target &amp;&amp; target &lt;= nums[r]) l = m + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; nums[r])&#123;  <span class="comment">//l~m有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[m]) r = m - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">//nums[m] == nums[r]时</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Search_In_Rotated_Sorted_Array_II">Search In Rotated Sorted Array II</h3><p><strong>Description</strong>: Follow up for “Search in R]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Remove Duplicates from Sorted Array II - 从有序数组中移除重复元素II]]></title>
    <link href="http://eugeneyang.com/2016/01/01/Remove%20Duplicates%20from%20Sorted%20Array%20II%20-%20%E4%BB%8E%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <id>http://eugeneyang.com/2016/01/01/Remove Duplicates from Sorted Array II - 从有序数组中移除重复元素II/</id>
    <published>2016-01-01T12:44:47.000Z</published>
    <updated>2016-01-01T11:18:04.047Z</updated>
    <content type="html"><![CDATA[<h3 id="Remove_Duplicates_from_Sorted_Array_II_-_从有序数组中移除重复元素II">Remove Duplicates from Sorted Array II - 从有序数组中移除重复元素II</h3><p><strong>Description</strong>: Follow up for “Remove Duplicates”: What if duplicates are allowed at most twice?</p>
<p> Note: Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p> For example,<br> Given sorted array nums = [1,1,1,2,2,3],<br> Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length.</p>
<p>今天是2016.1.1元旦节，新年快乐！<br><img src="/images/2016.png" alt="2016"></p>
<p>思路：与Remove Duplicates from Sorted Array一致，用index存不同数字的个数(可以含两次重复的数字)，遍历数组判断当前值是否和前一个值不一样。如果不一样，就是一个新的值，更新数组并对index加1。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesFromSortedArrayII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//        int[] nums = &#123;1&#125;;</span></span><br><span class="line">        System.out.println(<span class="string">"************************"</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="keyword">new</span> RemoveDuplicatesFromSortedArrayII().removeDuplicates(nums);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 用index存不同数字的个数(可以含两次重复的数字)，遍历数组判断当前值是否和前一个值不一样。</span><br><span class="line">     如果不一样，就是一个新的值，更新数组并对index加1。</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[index++] = nums[i];    <span class="comment">//其实 index++; 即可</span></span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; <span class="number">2</span>)&#123;</span><br><span class="line">                    nums[index++] = nums[i];    <span class="comment">//其实 index++; 即可</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Remove_Duplicates_from_Sorted_Array_II_-_从有序数组中移除重复元素II">Remove Duplicates from Sorted Array II - 从有序数组中移除重复元素II</h3><p><strong>Desc]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Word Search - 单词二维搜索]]></title>
    <link href="http://eugeneyang.com/2015/12/31/Word%20Search%20-%20%E5%8D%95%E8%AF%8D%E4%BA%8C%E7%BB%B4%E6%90%9C%E7%B4%A2/"/>
    <id>http://eugeneyang.com/2015/12/31/Word Search - 单词二维搜索/</id>
    <published>2015-12-31T12:44:47.000Z</published>
    <updated>2015-12-31T05:26:42.652Z</updated>
    <content type="html"><![CDATA[<h3 id="Word_Search_-_单词二维搜索">Word Search - 单词二维搜索</h3><p><strong>Description</strong>: Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br> Given board =<br> [ [‘A’,’B’,’C’,’E’],<br> [‘S’,’F’,’C’,’S’],<br> [‘A’,’D’,’E’,’E’] ]<br> word = “ABCCED”, -&gt; returns true,<br> word = “SEE”, -&gt; returns true,<br> word = “ABCB”, -&gt; returns false.</p>
<p>思路：回溯法。将当前搜索字符标记为“#”表示已搜索过，搜索方向包括上下左右四种。</p>
<p>参考：<a href="http://www.programcreek.com/2014/06/leetcode-word-search-java/" target="_blank" rel="external">http://www.programcreek.com/2014/06/leetcode-word-search-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2014/06/leetcode-word-search-java/</span><br><span class="line">     * 回溯法</span><br><span class="line">     * <span class="doctag">@param</span> board</span><br><span class="line">     * <span class="doctag">@param</span> word</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=m || j&gt;=n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == word.charAt(k))&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">            board[i][j]=<span class="string">'#'</span>;    <span class="comment">//mark</span></span><br><span class="line">            <span class="keyword">if</span>(k==word.length()-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dfs(board, word, i-<span class="number">1</span>, j, k+<span class="number">1</span>)</span><br><span class="line">                    ||dfs(board, word, i+<span class="number">1</span>, j, k+<span class="number">1</span>)</span><br><span class="line">                    ||dfs(board, word, i, j-<span class="number">1</span>, k+<span class="number">1</span>)</span><br><span class="line">                    ||dfs(board, word, i, j+<span class="number">1</span>, k+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[i][j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Word_Search_-_单词二维搜索">Word Search - 单词二维搜索</h3><p><strong>Description</strong>: Given a 2D board and a word, find if the word exists]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Subsets - 求子集]]></title>
    <link href="http://eugeneyang.com/2015/12/30/Subsets%20-%20%E6%B1%82%E5%AD%90%E9%9B%86/"/>
    <id>http://eugeneyang.com/2015/12/30/Subsets - 求子集/</id>
    <published>2015-12-30T12:44:47.000Z</published>
    <updated>2015-12-31T05:22:46.970Z</updated>
    <content type="html"><![CDATA[<h3 id="Subsets_-_求子集">Subsets - 求子集</h3><p><strong>Description</strong>: Given a set of distinct integers, nums, return all possible subsets.</p>
<p> Note:<br> Elements in a subset must be in non-descending order.<br> The solution set must not contain duplicate subsets.</p>
<p> For example,<br> If nums = [1,2,3], a solution is:<br> [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]</p>
<p>思路：位操作，或者用回溯法。位操作中，判断数i第k位是否为1：i&amp;(1 &lt;&lt; k-1) != 0则为1。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subsets</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        Subsets instance = <span class="keyword">new</span> Subsets();</span><br><span class="line">        instance.subsets(nums);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; ints : instance.result)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : ints) System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; temp;</span><br><span class="line">    <span class="comment">//判断数i第k位是否为1：i&amp;(1 &lt;&lt; k-1) != 0则为1</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span> &lt;&lt; len;   <span class="comment">//2^len</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//查看第一层循环任意一种取值中哪一位是1；如果是1，对应的字符就存在</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=len; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span> ( (i&amp;(<span class="number">1</span> &lt;&lt; k-<span class="number">1</span>)) != <span class="number">0</span> ) temp.add(nums[k-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Subsets_-_求子集">Subsets - 求子集</h3><p><strong>Description</strong>: Given a set of distinct integers, nums, return all possible subset]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Combinations - 组合数]]></title>
    <link href="http://eugeneyang.com/2015/12/29/Combinations%20-%20%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <id>http://eugeneyang.com/2015/12/29/Combinations - 组合数/</id>
    <published>2015-12-29T12:44:47.000Z</published>
    <updated>2015-12-29T05:16:51.890Z</updated>
    <content type="html"><![CDATA[<h3 id="Combinations_-_组合数">Combinations - 组合数</h3><p><strong>Description</strong>: Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p> For example,<br> If n = 4 and k = 2, a solution is:<br> [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4] ]</p>
<p>思路：回溯法。</p>
<p>类似的问题有：Combination Sum(含重复或不重复元素)、Permutation等。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Combinations</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        Combinations instance = <span class="keyword">new</span> Combinations();</span><br><span class="line">        instance.combine(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; ints : instance.result)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : ints) System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        backTrack(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=x; i&lt;=n; i++)&#123;</span><br><span class="line">            temp.add(i);</span><br><span class="line">            backTrack(n, k - <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Combinations_-_组合数">Combinations - 组合数</h3><p><strong>Description</strong>: Given two integers n and k, return all possible combinat]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Minimum Window Substring - 最小子串窗口]]></title>
    <link href="http://eugeneyang.com/2015/12/28/Minimum%20Window%20Substring%20-%20%E6%9C%80%E5%B0%8F%E5%AD%90%E4%B8%B2%E7%AA%97%E5%8F%A3/"/>
    <id>http://eugeneyang.com/2015/12/28/Minimum Window Substring - 最小子串窗口/</id>
    <published>2015-12-28T12:44:47.000Z</published>
    <updated>2015-12-28T12:22:00.533Z</updated>
    <content type="html"><![CDATA[<h3 id="Minimum_Window_Substring_-_最小子串窗口">Minimum Window Substring - 最小子串窗口</h3><p><strong>Description</strong>: Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p> For example,<br> S = “ADOBECODEBANC”<br> T = “ABC”<br> Minimum window is “BANC”.</p>
<p> Note:<br> If there is no such window in S that covers all characters in T, return the empty string “”.<br> If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.</p>
<p>思路：双指针，动态维护一个区间。尾指针不断往后扫，当扫到有一个窗口包含了所有T的字符后，然后再收缩头指针，直到不能再收缩为止。最后记录所有可能的情况中窗口最小的。</p>
<p>参考：<a href="http://blog.csdn.net/linhuanmars/article/details/20343903" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/20343903</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumWindowSubstring</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://blog.csdn.net/linhuanmars/article/details/20343903</span><br><span class="line">     * 双指针，动态维护一个区间。尾指针不断往后扫，当扫到有一个窗口包含了所有T的字符后，</span><br><span class="line">     * 然后再收缩头指针，直到不能再收缩为止。最后记录所有可能的情况中窗口最小的。</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@param</span> t</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; bookT = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//建立T字典</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bookT.containsKey(t.charAt(i))) &#123;</span><br><span class="line">                bookT.put(t.charAt(i), bookT.get(t.charAt(i))+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                bookT.put(t.charAt(i), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = s.length()+<span class="number">1</span>;  <span class="comment">//+1用来判断无匹配的极端情况</span></span><br><span class="line">        <span class="keyword">int</span> minStart = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//尾指针不断往后扫</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=<span class="number">0</span>; right&lt;s.length(); right++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bookT.containsKey(s.charAt(right))) &#123;</span><br><span class="line">                bookT.put(s.charAt(right), bookT.get(s.charAt(right))-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(bookT.get(s.charAt(right))&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当扫到有一个窗口包含了所有T的字符后，然后再收缩头指针，直到不能再收缩为止</span></span><br><span class="line">                <span class="keyword">while</span>(count == t.length()) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(right-left+<span class="number">1</span> &lt; minLen) &#123; <span class="comment">//更新</span></span><br><span class="line">                        minLen = right-left+<span class="number">1</span>;</span><br><span class="line">                        minStart = left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(bookT.containsKey(s.charAt(left))) &#123;     <span class="comment">//left收缩</span></span><br><span class="line">                        bookT.put(s.charAt(left), bookT.get(s.charAt(left))+<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span>(bookT.get(s.charAt(left))&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                            count--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minLen&gt;s.length()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//最后记录所有可能的情况中窗口最小的</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(minStart, minStart+minLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Minimum_Window_Substring_-_最小子串窗口">Minimum Window Substring - 最小子串窗口</h3><p><strong>Description</strong>: Given a string S and a str]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sort Colors - 颜色排序]]></title>
    <link href="http://eugeneyang.com/2015/12/27/Sort%20Colors%20-%20%E9%A2%9C%E8%89%B2%E6%8E%92%E5%BA%8F/"/>
    <id>http://eugeneyang.com/2015/12/27/Sort Colors - 颜色排序/</id>
    <published>2015-12-27T12:44:47.000Z</published>
    <updated>2015-12-27T08:50:29.033Z</updated>
    <content type="html"><![CDATA[<h3 id="Sort_Colors_-_颜色排序">Sort Colors - 颜色排序</h3><p><strong>Description</strong>: Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p> Could you come up with an one-pass algorithm using only constant space?</p>
<p>思路：先计算每种颜色数，然后在原数组基础上填充值。</p>
<p>参考：<a href="http://www.programcreek.com/2014/06/leetcode-sort-colors-java/" target="_blank" rel="external">http://www.programcreek.com/2014/06/leetcode-sort-colors-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortColors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2014/06/leetcode-sort-colors-java/</span><br><span class="line">     * Since we already get the count of each element, we can directly project them to</span><br><span class="line">     * the original array, instead of creating a new one.</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) counts[nums[i]]++;</span><br><span class="line">        <span class="keyword">int</span> color = <span class="number">0</span>;  <span class="comment">//0:red 1:white 2:blue</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(color&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(counts[color]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[k++]=color;</span><br><span class="line">                counts[color] = counts[color]-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                color++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Sort_Colors_-_颜色排序">Sort Colors - 颜色排序</h3><p><strong>Description</strong>: Given an array with n objects colored red, white or blue]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Search 2D Matrix - 搜索2D矩阵]]></title>
    <link href="http://eugeneyang.com/2015/12/26/Search%202D%20Matrix%20-%20%E6%90%9C%E7%B4%A22D%E7%9F%A9%E9%98%B5/"/>
    <id>http://eugeneyang.com/2015/12/26/Search 2D Matrix - 搜索2D矩阵/</id>
    <published>2015-12-26T12:44:47.000Z</published>
    <updated>2015-12-26T05:21:55.955Z</updated>
    <content type="html"><![CDATA[<h3 id="Search_2D_Matrix_-_搜索2D矩阵">Search 2D Matrix - 搜索2D矩阵</h3><p><strong>Description</strong>: Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.<ul>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
</li>
</ul>
<p>思路：二分搜索（外层、内层）。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Search2DMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123;<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>&#125;</span><br><span class="line">                        &#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Search2DMatrix().searchMatrix(matrix, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两层均使用二分搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[row-<span class="number">1</span>][col-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = row-<span class="number">1</span>, m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; matrix[m][<span class="number">0</span>]) r = m-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[m][<span class="number">0</span>]) l = m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target == matrix[r][col-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[r][col-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> res = binarySearch(matrix[r], target);</span><br><span class="line">                <span class="keyword">return</span> res != -<span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[m]) r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt; target) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> m;  <span class="comment">//target == nums[m]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Search_2D_Matrix_-_搜索2D矩阵">Search 2D Matrix - 搜索2D矩阵</h3><p><strong>Description</strong>: Write an efficient algorithm that searches]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Set Matrix Zeroes - 矩阵置零]]></title>
    <link href="http://eugeneyang.com/2015/12/25/Set%20Matrix%20Zeroes%20-%20%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
    <id>http://eugeneyang.com/2015/12/25/Set Matrix Zeroes - 矩阵置零/</id>
    <published>2015-12-25T12:44:47.000Z</published>
    <updated>2015-12-25T12:53:25.258Z</updated>
    <content type="html"><![CDATA[<h3 id="Set_Matrix_Zeroes_-_矩阵置零">Set Matrix Zeroes - 矩阵置零</h3><p><strong>Description</strong>: Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p>
<p>Could you devise a constant space solution?</p>
<p>O(1)解法：用第0行和第0列来记录第1~m-1行和第1~n-1列是否需要置0。而用两个变量记录第0行和第0列是否需要置0。</p>
<p>注意：直接用0来标记需要置零，不要使用其他标记，这样第0行、第0列可以不用额外处理。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetMatrixZeroes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[][] matrix = &#123; &#123;0,0,0,5&#125;,</span></span><br><span class="line"><span class="comment">//                            &#123;4,3,1,4&#125;,</span></span><br><span class="line"><span class="comment">//                            &#123;0,1,1,4&#125;,</span></span><br><span class="line"><span class="comment">//                            &#123;1,2,1,3&#125;,</span></span><br><span class="line"><span class="comment">//                            &#123;0,0,1,1&#125;&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">new</span> SetMatrixZeroes().setZeroes(matrix);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : row) System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * O(1)解法：用第0行和第0列来记录第1~m-1行和第1~n-1列是否需要置0。</span><br><span class="line">     * 而用两个变量记录第0行和第0列是否需要置0。</span><br><span class="line">     * TODO 注意：直接用0来标记需要置零，不要使用其他标记，这样第0行、第0列可以不用额外处理。</span><br><span class="line">     * <span class="doctag">@param</span> matrix</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> zeroRow = <span class="number">1</span>, zeroCol = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="comment">//set first row and column zero or not</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroCol = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroRow = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//mark zeros on first row and column</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//set each elements by using marks in first row and column.</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++) matrix[i][k] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;m; k++) matrix[k][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//Set first column and row by using marks in first step.</span></span><br><span class="line">        <span class="keyword">if</span> (zeroRow == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (zeroCol == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;m; i++) matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Set_Matrix_Zeroes_-_矩阵置零">Set Matrix Zeroes - 矩阵置零</h3><p><strong>Description</strong>: Given a m x n matrix, if an element is 0, se]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Edit Distance - 最短编辑距离]]></title>
    <link href="http://eugeneyang.com/2015/12/24/Edit%20Distance%20-%20%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://eugeneyang.com/2015/12/24/Edit Distance - 最短编辑距离/</id>
    <published>2015-12-24T12:44:47.000Z</published>
    <updated>2015-12-24T08:00:39.169Z</updated>
    <content type="html"><![CDATA[<h3 id="Edit_Distance_-_最短编辑距离">Edit Distance - 最短编辑距离</h3><p><strong>Description</strong>: Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)<br> You have the following 3 operations permitted on a word:<br> a) Insert a character<br> b) Delete a character<br> c) Replace a character</p>
<p> 思路：使用动态规划。D[i,j]表示s1的前i个字符和 s2的前j个字符的最短编辑距离，<br>s1[i]!=s2[j]时，D[i,j]=min(D[i-1,j]+1,D[i,j-1]+1,D[i-1,j-1]+1);<br>s1[i]==s2[j]时，D[i,j]=D[i-1,j-1];</p>
<p> 参考：<a href="http://blog.unieagle.net/2012/09/19/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Aedit-distance%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" target="_blank" rel="external">http://blog.unieagle.net/2012/09/19/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Aedit-distance%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</a></p>
<p>注意此题中置换也是一种基本操作，置换操作明显比 “删除+增加” 操作更短；<br>如果置换不是基本操作，则是另一种算法（可以参考：<a href="http://blog.csdn.net/abcjennifer/article/details/7735272" target="_blank" rel="external">http://blog.csdn.net/abcjennifer/article/details/7735272</a> ）。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditDistance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> EditDistance().minDistance(<span class="string">"eat"</span>, <span class="string">"sea"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 参考：http://blog.unieagle.net/2012/09/19/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Aedit-distance%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</span><br><span class="line">     * D[i,j]: s1的前i个字符和 s2的前j个字符的最短编辑距离</span><br><span class="line">     * 注意置换也是一种基本操作，置换明显比 删除+增加 操作更短；</span><br><span class="line">     * 如果置换不是基本操作，则是另一种算法（参考：http://blog.csdn.net/abcjennifer/article/details/7735272）。</span><br><span class="line">     * s1[i]!=s2[j]时，D[i,j]=min(D[i-1,j]+1,D[i,j-1]+1,D[i-1,j-1]+1);</span><br><span class="line">     * s1[i]==s2[j]时，D[i,j]=D[i-1,j-1];</span><br><span class="line">     * <span class="doctag">@param</span> word1</span><br><span class="line">     * <span class="doctag">@param</span> word2</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1.equals(word2)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] D = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=m; i++)</span><br><span class="line">            D[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;=n; j++)</span><br><span class="line">            D[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                    D[i][j] = D[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> replace = D[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> insert = D[i][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> delete = D[i-<span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> temp = Math.min(replace, insert);</span><br><span class="line">                    D[i][j] = Math.min(temp, delete);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> D[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Edit_Distance_-_最短编辑距离">Edit Distance - 最短编辑距离</h3><p><strong>Description</strong>: Given two words word1 and word2, find the minimu]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

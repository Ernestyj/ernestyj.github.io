<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Eugene's Blog]]></title>
  <subtitle><![CDATA[成长之旅]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://eugeneyang.com/"/>
  <updated>2016-02-10T16:08:20.717Z</updated>
  <id>http://eugeneyang.com/</id>
  
  <author>
    <name><![CDATA[Jian Yang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock III - 买股票的最佳时机III]]></title>
    <link href="http://eugeneyang.com/2016/02/11/Best%20Time%20to%20Buy%20and%20Sell%20Stock%20III%20-%20%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/"/>
    <id>http://eugeneyang.com/2016/02/11/Best Time to Buy and Sell Stock III - 买股票的最佳时机III/</id>
    <published>2016-02-11T12:44:47.000Z</published>
    <updated>2016-02-10T16:08:20.717Z</updated>
    <content type="html"><![CDATA[<h3 id="Best_Time_to_Buy_and_Sell_Stock_III_-_买股票的最佳时机III">Best Time to Buy and Sell Stock III - 买股票的最佳时机III</h3><p><strong>Description</strong>: Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>思路：两次一维动态规划组合:以第i天为分界线，计算第i天之前进行一次交易的最大收益preProfit[i]，和第i天之后进行一次交易的最大收益postProfit[i]，遍历的同时，max{preProfit[i] + postProfit[i]}(0≤i≤n-1)就是最大收益。第i天之前和第i天之后进行一次的最大收益求法同Best Time to Buy and Sell Stock I。上述方法时间复杂度O(n^2),超时.</p>
<p>优化：用数组暂存结果提速,时间复杂度O(n).</p>
<p>参考：<a href="http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html" target="_blank" rel="external">http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimeToBuyAndSellStockIII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html</span><br><span class="line">     * 两次一维动态规划组合:以第i天为分界线，计算第i天之前进行一次交易的最大收益preProfit[i]，</span><br><span class="line">     和第i天之后进行一次交易的最大收益postProfit[i]，</span><br><span class="line">     遍历的同时，max&#123;preProfit[i] + postProfit[i]&#125;(0≤i≤n-1)就是最大收益。</span><br><span class="line">     第i天之前和第i天之后进行一次的最大收益求法同Best Time to Buy and Sell Stock I。</span><br><span class="line">     上述方法时间复杂度O(n^2),超时.</span><br><span class="line">     优化:用数组暂存结果提速,时间复杂度O(n).</span><br><span class="line">     * <span class="doctag">@param</span> prices</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] preProfit = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] postProfit = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">            preProfit[i] = Math.max(preProfit[i-<span class="number">1</span>], prices[i]-min); <span class="comment">//注意是i-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = prices[len-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=len-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            max = Math.max(max, prices[i]);</span><br><span class="line">            postProfit[i] = Math.max(postProfit[i+<span class="number">1</span>], max-prices[i]);   <span class="comment">//注意是i+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            profit = Math.max(profit, preProfit[i]+postProfit[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> preProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> postProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;len; k++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">                min = Math.min(min, prices[i]);</span><br><span class="line">                preProfit = Math.max(preProfit, prices[i]-min);</span><br><span class="line">            &#125;</span><br><span class="line">            min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=k; j&lt;len; j++)&#123;</span><br><span class="line">                min = Math.min(min, prices[j]);</span><br><span class="line">                postProfit = Math.max(postProfit, prices[j]-min);</span><br><span class="line">            &#125;</span><br><span class="line">            profit = Math.max(profit, preProfit+postProfit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Best_Time_to_Buy_and_Sell_Stock_III_-_买股票的最佳时机III">Best Time to Buy and Sell Stock III - 买股票的最佳时机III</h3><p><strong>Description</str]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock I & II - 买股票的最佳时机I&II]]></title>
    <link href="http://eugeneyang.com/2016/02/10/Best%20Time%20to%20Buy%20and%20Sell%20Stock%20I%20&%20II%20-%20%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAI&II/"/>
    <id>http://eugeneyang.com/2016/02/10/Best Time to Buy and Sell Stock I & II - 买股票的最佳时机I&II/</id>
    <published>2016-02-10T12:44:47.000Z</published>
    <updated>2016-02-10T16:08:20.715Z</updated>
    <content type="html"><![CDATA[<h3 id="Best_Time_to_Buy_and_Sell_Stock_I_&amp;_II_-_买股票的最佳时机I&amp;II">Best Time to Buy and Sell Stock I &amp; II - 买股票的最佳时机I&amp;II</h3><p>Best Time to Buy and Sell Stock I</p>
<p><strong>Description</strong>: Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>思路：最一般的方法是嵌套遍历找到最大买入卖出差,但超时.<br>用一维动态规划(双重):记录出现过的最低价作为买入价格,计算当天售出的收益.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimeToBuyAndSellStock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 最一般的方法是嵌套遍历找到最大买入卖出差,但超时.</span><br><span class="line">     一维动态规划(双重):记录出现过的最低价作为买入价格,计算当天售出的收益.</span><br><span class="line">     P(i)=Max(P(i-1), price[i]-B(i))</span><br><span class="line">     B(i)=Min(B(i-1), price[i])</span><br><span class="line">     * <span class="doctag">@param</span> prices</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">            profit = Math.max(profit, prices[i]-min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Best Time to Buy and Sell Stock II</p>
<p><strong>Description</strong>: Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). </p>
<p>However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>思路：贪心方法:递增序前后元素差之和.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimeToBuyAndSellStockII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 贪心方法:递增序前后元素差之和.</span><br><span class="line">     * <span class="doctag">@param</span> prices</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i]&gt;prices[i-<span class="number">1</span>])</span><br><span class="line">                profit += prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Best_Time_to_Buy_and_Sell_Stock_I_&amp;_II_-_买股票的最佳时机I&amp;II">Best Time to Buy and Sell Stock I &amp; II - 买股票的最佳时机I&amp;II</h3><p>]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Triangle - 三角形中最短路径和]]></title>
    <link href="http://eugeneyang.com/2016/02/08/Triangle%20-%20%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%AD%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://eugeneyang.com/2016/02/08/Triangle - 三角形中最短路径和/</id>
    <published>2016-02-08T12:44:47.000Z</published>
    <updated>2016-02-10T16:08:20.713Z</updated>
    <content type="html"><![CDATA[<h3 id="Triangle_-_三角形中最短路径和">Triangle - 三角形中最短路径和</h3><p><strong>Description</strong>: Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p> Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
<p>原题链接：<a href="https://leetcode.com/submissions/detail/52958615/" target="_blank" rel="external">https://leetcode.com/submissions/detail/52958615/</a></p>
<p>思路：二维动态规划(自顶向下):在某一个元素i，j的最小路径和就是它上层对应的相邻两个元素的最小路径和加上自己的值，递推式是sum[i][j]=min(sum[i-1][j-1],sum[i-1][j])+triangle[i][j],最后扫描一遍最后一层的路径和，取出最小的即可。</p>
<p>复杂度:每个元素需要维护一次，总共有1+2+…+n=n*(n+1)/2个元素，所以时间复杂度是O(n^2)；而空间上每次只需维护一层即可（因为当前层只用到上一层的元素），所以空间复杂度是O(n).</p>
<p>或者采用动态规划(自底向上):sum[i][j]=min(sum[i+1][j],sum[i+1][j+1])+triangle[i][j]，自底向上的方式省去了对每层首尾元素的特殊处理,更简洁.</p>
<p>参考：<a href="http://blog.csdn.net/linhuanmars/article/details/23230657" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/23230657</a></p>
<p>完整的java代码如下（自底向上）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PascalTriangleII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 与Pascal's Triangle类似,但是空间可以压缩为O(k).注意in-place更新值时要逆序(观察Pascal三角的特点)</span><br><span class="line">     * <span class="doctag">@param</span> rowIndex</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (rowIndex&lt;<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        result.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">1</span>; row&lt;rowIndex+<span class="number">1</span>; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=result.size()-<span class="number">1</span>; j&gt;<span class="number">0</span>; j--)&#123;    <span class="comment">//注意一定要倒序遍历,因为顺序会覆盖值</span></span><br><span class="line">                result.set(j, result.get(j-<span class="number">1</span>) + result.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Triangle_-_三角形中最短路径和">Triangle - 三角形中最短路径和</h3><p><strong>Description</strong>: Given a triangle, find the minimum path sum from top]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pascal's Triangle II]]></title>
    <link href="http://eugeneyang.com/2016/02/07/Pascal's%20Triangle%20II/"/>
    <id>http://eugeneyang.com/2016/02/07/Pascal's Triangle II/</id>
    <published>2016-02-07T12:44:47.000Z</published>
    <updated>2016-02-10T16:08:20.711Z</updated>
    <content type="html"><![CDATA[<h3 id="Pascal’s_Triangle_II">Pascal’s Triangle II</h3><p><strong>Description</strong>: Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3, Return [1,3,3,1].</p>
<p> Note: Could you optimize your algorithm to use only O(k) extra space?</p>
<p> 示例：k=5时Pascal三角如下<br> [<br>&nbsp;&nbsp;&nbsp;&nbsp;[1],<br>&nbsp;&nbsp;&nbsp;[1,1],<br>&nbsp;&nbsp;[1,2,1],<br>&nbsp;[1,3,3,1],<br> [1,4,6,4,1]<br> ]</p>
<p>思路：与Pascal’s Triangle类似,但是空间可以压缩为O(k).注意in-place更新值时要逆序(观察Pascal三角的特点)</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PascalTriangleII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 与Pascal's Triangle类似,但是空间可以压缩为O(k).注意in-place更新值时要逆序(观察Pascal三角的特点)</span><br><span class="line">     * <span class="doctag">@param</span> rowIndex</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (rowIndex&lt;<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        result.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">1</span>; row&lt;rowIndex+<span class="number">1</span>; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=result.size()-<span class="number">1</span>; j&gt;<span class="number">0</span>; j--)&#123;    <span class="comment">//注意一定要倒序遍历,因为顺序会覆盖值</span></span><br><span class="line">                result.set(j, result.get(j-<span class="number">1</span>) + result.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Pascal’s_Triangle_II">Pascal’s Triangle II</h3><p><strong>Description</strong>: Given an index k, return the kth row of the Pascal’s]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pascal's Triangle]]></title>
    <link href="http://eugeneyang.com/2016/02/06/Pascal's%20Triangle/"/>
    <id>http://eugeneyang.com/2016/02/06/Pascal's Triangle/</id>
    <published>2016-02-06T12:44:47.000Z</published>
    <updated>2016-02-10T16:08:20.709Z</updated>
    <content type="html"><![CDATA[<h3 id="Pascal’s_Triangle">Pascal’s Triangle</h3><p><strong>Description</strong>: Given numRows, generate the first numRows of Pascal’s triangle.</p>
<p> For example, given numRows = 5,<br> Return<br> [<br>&nbsp;&nbsp;&nbsp;&nbsp;[1],<br>&nbsp;&nbsp;&nbsp;[1,1],<br>&nbsp;&nbsp;[1,2,1],<br>&nbsp;[1,3,3,1],<br> [1,4,6,4,1]<br> ]</p>
<p> 思路：时间复杂度O(1+2+3+…+n)=O(n^2)，空间上只需要二维数组来存储结果;因为是求解每一行结果，所以空间上没有更优的办法.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PascalTriangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 时间复杂度O(1+2+3+...+n)=O(n^2)，空间上只需要二维数组来存储结果;</span><br><span class="line">     因为是求解每一行结果，所以空间上没有更优.</span><br><span class="line">     * <span class="doctag">@param</span> numRows</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (numRows==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        List&lt;Integer&gt; pre = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        pre.add(<span class="number">1</span>);</span><br><span class="line">        result.add(pre);</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; numRows)&#123;</span><br><span class="line">            cur.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pre.size()-<span class="number">1</span>; i++)&#123;</span><br><span class="line">                cur.add(pre.get(i) + pre.get(i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            cur.add(<span class="number">1</span>);</span><br><span class="line">            result.add(cur);</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Pascal’s_Triangle">Pascal’s Triangle</h3><p><strong>Description</strong>: Given numRows, generate the first numRows of Pascal’s tria]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Populating Next Right Pointers in Each Node II - 填充二叉树每个节点的右指针II]]></title>
    <link href="http://eugeneyang.com/2016/02/05/Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II%20-%20%E5%A1%AB%E5%85%85%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%8F%B3%E6%8C%87%E9%92%88II/"/>
    <id>http://eugeneyang.com/2016/02/05/Populating Next Right Pointers in Each Node II - 填充二叉树每个节点的右指针II/</id>
    <published>2016-02-05T12:44:47.000Z</published>
    <updated>2016-02-10T16:08:20.707Z</updated>
    <content type="html"><![CDATA[<h3 id="Populating_Next_Right_Pointers_in_Each_Node_II_-_填充二叉树每个节点的右指针II">Populating Next Right Pointers in Each Node II - 填充二叉树每个节点的右指针II</h3><p><strong>Description</strong>: Follow up for problem “Populating Next Right Pointers in Each Node”. What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>Note: You may only use constant extra space.</p>
<p> 思路：<br> 1 找到规律用递归求解,类似上一题Populating Next Right Pointers in Each Node, 唯一的不同是每次要先找到一个第一个有效的next链接节点，并且递归的时候要先处理右子树，再处理左子树.（(OJ 78%，思路较难想到）<br> 参考：<a href="http://fisherlei.blogspot.tw/2012/12/leetcode-populating-next-right-pointers_29.html" target="_blank" rel="external">http://fisherlei.blogspot.tw/2012/12/leetcode-populating-next-right-pointers_29.html</a><br>2 类似二叉树层次遍历,但不再使用队列,而是将树的每一层维护成一个链表,空间复杂度O(1); 每次维护两层,共计4个指针:lastHead, curHead, lastCur, curPre.<br>参考：<a href="http://www.programcreek.com/2014/06/leetcode-populating-next-right-pointers-in-each-node-ii-java/" target="_blank" rel="external">http://www.programcreek.com/2014/06/leetcode-populating-next-right-pointers-in-each-node-ii-java/</a><br>3 类似二叉树层次遍历,使用队列,空间复杂度O(n)</p>
<p>完整的java代码如下（含三种方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PopulatingNextRightPointersInEachNodeII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeLinkNode left, right, next;</span><br><span class="line">        TreeLinkNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**(OJ 78%)</span><br><span class="line">     * http://fisherlei.blogspot.tw/2012/12/leetcode-populating-next-right-pointers_29.html</span><br><span class="line">     * 找到规律用递归求解,类似上一题Populating Next Right Pointers in Each Node,</span><br><span class="line">     唯一的不同是每次要先找到一个第一个有效的next链接节点，并且递归的时候要先处理右子树，再处理左子树.</span><br><span class="line">     空间复杂度O(1)</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeLinkNode p = root.next;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                p = p.left; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                p = p.right; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) root.right.next = p;</span><br><span class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>) root.left.next = root.right!=<span class="keyword">null</span> ? root.right : p;</span><br><span class="line">        connect(root.right);</span><br><span class="line">        connect(root.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**(OJ 30%)</span><br><span class="line">     * http://www.programcreek.com/2014/06/leetcode-populating-next-right-pointers-in-each-node-ii-java/</span><br><span class="line">     * 类似二叉树层次遍历,但不再使用队列,而是将树的每一层维护成一个链表,空间复杂度O(1);</span><br><span class="line">     每次维护两层,共计4个指针:lastHead, curHead, lastCur, curPre.</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect1</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeLinkNode lastHead = root;</span><br><span class="line">        TreeLinkNode curHead = <span class="keyword">null</span>;</span><br><span class="line">        TreeLinkNode lastCur = <span class="keyword">null</span>;</span><br><span class="line">        TreeLinkNode curPre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(lastHead!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            lastCur = lastHead;</span><br><span class="line">            <span class="keyword">while</span>(lastCur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(lastCur.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(curHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        curHead = lastCur.left;</span><br><span class="line">                        curPre = lastCur.left;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        curPre.next = lastCur.left;</span><br><span class="line">                        curPre = curPre.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(lastCur.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(curHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        curHead = lastCur.right;</span><br><span class="line">                        curPre = lastCur.right;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        curPre.next = lastCur.right;</span><br><span class="line">                        curPre = curPre.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lastCur = lastCur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            lastHead = curHead; <span class="comment">//往下层移动</span></span><br><span class="line">            curHead = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**类似二叉树层次遍历,使用队列,空间复杂度O(n)</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect2</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeLinkNode&gt; curQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeLinkNode&gt; nextQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        curQueue.offer(root);</span><br><span class="line">        TreeLinkNode old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!curQueue.isEmpty())&#123;</span><br><span class="line">            TreeLinkNode node = curQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (old!=<span class="keyword">null</span>) old.next = node;</span><br><span class="line">            old = node;</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) nextQueue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) nextQueue.offer(node.right);</span><br><span class="line">            <span class="keyword">if</span> (curQueue.isEmpty())&#123;</span><br><span class="line">                old = <span class="keyword">null</span>;</span><br><span class="line">                curQueue = nextQueue;</span><br><span class="line">                nextQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Populating_Next_Right_Pointers_in_Each_Node_II_-_填充二叉树每个节点的右指针II">Populating Next Right Pointers in Each Node II - 填充二叉树每个节点的右指针II</]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Populating Next Right Pointers in Each Node - 填充二叉树每个节点的右指针]]></title>
    <link href="http://eugeneyang.com/2016/02/04/Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20-%20%E5%A1%AB%E5%85%85%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%8F%B3%E6%8C%87%E9%92%88/"/>
    <id>http://eugeneyang.com/2016/02/04/Populating Next Right Pointers in Each Node - 填充二叉树每个节点的右指针/</id>
    <published>2016-02-04T12:44:47.000Z</published>
    <updated>2016-02-10T16:08:20.705Z</updated>
    <content type="html"><![CDATA[<h3 id="Populating_Next_Right_Pointers_in_Each_Node_-_填充二叉树每个节点的右指针">Populating Next Right Pointers in Each Node - 填充二叉树每个节点的右指针</h3><p><strong>Description</strong>: Populate each next pointer to point to its next right node.<br> If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.</p>
<p> Note:<br> You may only use constant extra space.<br> You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</p>
<p> 思路：<br> 1 用Populating Next Right Pointers in Each Node II解法可行(类似二叉树层次遍历)；<br>2 由于题目中的二叉树是完全二叉树,找到规律可用递归求解(OJ排名82%);<br>（1）根节点的左子树，其next是该根节点的右子树;<br>（2）根节点的右子树，其next是该根节点next节点的左子树.<br>参考：<a href="https://gist.github.com/benjaminwu7/4700435" target="_blank" rel="external">https://gist.github.com/benjaminwu7/4700435</a></p>
<p>完整的java代码如下（第二种方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PopulatingNextRightPointersInEachNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeLinkNode left, right, next;</span><br><span class="line">        TreeLinkNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用Populating Next Right Pointers in Each Node II解法可行(类似二叉树层次遍历)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 由于题目中的二叉树是完全二叉树,找到规律可用递归求解(OJ排名82%);</span><br><span class="line">     1. 根节点的左子树，其next是该根节点的右子树;</span><br><span class="line">     2. 根节点的右子树，其next是该根节点next节点的左子树.</span><br><span class="line">     * https://gist.github.com/benjaminwu7/4700435</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeLinkNode leftN = root.left;</span><br><span class="line">        TreeLinkNode rightN = root.right;</span><br><span class="line">        <span class="keyword">while</span>(leftN != <span class="keyword">null</span>)&#123;   <span class="comment">//链接兄弟节点,及这对兄弟节点下所有相邻的堂兄弟节点对</span></span><br><span class="line">            leftN.next = rightN;</span><br><span class="line">            leftN = leftN.right;</span><br><span class="line">            rightN = rightN.left;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root.left);</span><br><span class="line">        connect(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Populating_Next_Right_Pointers_in_Each_Node_-_填充二叉树每个节点的右指针">Populating Next Right Pointers in Each Node - 填充二叉树每个节点的右指针</h3><p><str]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Distinct Subsequences - 求不同的子串序列数]]></title>
    <link href="http://eugeneyang.com/2016/02/03/Distinct%20Subsequences%20-%20%E6%B1%82%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E4%B8%B2%E5%BA%8F%E5%88%97%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/02/03/Distinct Subsequences - 求不同的子串序列数/</id>
    <published>2016-02-03T12:44:47.000Z</published>
    <updated>2016-02-10T16:08:20.703Z</updated>
    <content type="html"><![CDATA[<h3 id="Distinct_Subsequences_-_求不同的子串序列数">Distinct Subsequences - 求不同的子串序列数</h3><p><strong>Description</strong>: Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>Here is an example:S = “rabbbit”, T = “rabbit”, Return 3.</p>
<p>原题链接：<a href="https://leetcode.com/problems/distinct-subsequences/" target="_blank" rel="external">https://leetcode.com/problems/distinct-subsequences/</a> </p>
<p> 思路：二维动态规划(与Interleaving String思路一致)。<br> W(i,j)表示S(0,i)的子串与T(0,j)相同的个数,</p>
<p>递推式:W(i,j)=W(i-1,j-1)+W(i-1,j),当S(i)==T(j)时;<br>     W(i,j)=W(i-1,j),当S(i)!=T(j)时.</p>
<p>边界条件:S,T均为空串,W(0,0)=1;<br>     仅S为空串,W(0,j)=0;<br>     仅T为空串,W(i,0)=1;</p>
<p>参考：<a href="http://www.programcreek.com/2013/01/leetcode-distinct-subsequences-total-java/" target="_blank" rel="external">http://www.programcreek.com/2013/01/leetcode-distinct-subsequences-total-java/</a><br>图解：<a href="http://blog.csdn.net/abcbc/article/details/8978146" target="_blank" rel="external">http://blog.csdn.net/abcbc/article/details/8978146</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistinctSubsequences</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**http://www.programcreek.com/2013/01/leetcode-distinct-subsequences-total-java/</span><br><span class="line">     * 图解:http://blog.csdn.net/abcbc/article/details/8978146</span><br><span class="line">     * 二维动态规划(与Interleaving String思路一致):W(i,j)表示S(0,i)的子串与T(0,j)相同的个数,</span><br><span class="line">     递推式:W(i,j)=W(i-1,j-1)+W(i-1,j),当S(i)==T(j)时;</span><br><span class="line">     W(i,j)=W(i-1,j),当S(i)!=T(j)时.</span><br><span class="line">     边界条件:S,T均为空串,W(0,0)=1;</span><br><span class="line">     仅S为空串,W(0,j)=0;</span><br><span class="line">     仅T为空串,W(i,0)=1;</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@param</span> t</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenS = s.length(), lenT = t.length();</span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[lenS+<span class="number">1</span>][lenT+<span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//for (int j=1; j&lt;=lenT; j++) result[0][j] = 0; //冗余</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=lenS; i++) result[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=lenS; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=lenT; j++)&#123;</span><br><span class="line">                result[i][j] = result[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>) == t.charAt(j-<span class="number">1</span>)) result[i][j] += result[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> result[lenS][lenT];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Distinct_Subsequences_-_求不同的子串序列数">Distinct Subsequences - 求不同的子串序列数</h3><p><strong>Description</strong>: Given a string S and a str]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Flatten Binary Tree to Linked List - 将二叉树转化为链表]]></title>
    <link href="http://eugeneyang.com/2016/02/02/Flatten%20Binary%20Tree%20to%20Linked%20List%20-%20%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <id>http://eugeneyang.com/2016/02/02/Flatten Binary Tree to Linked List - 将二叉树转化为链表/</id>
    <published>2016-02-02T12:44:47.000Z</published>
    <updated>2016-02-02T11:48:39.237Z</updated>
    <content type="html"><![CDATA[<h3 id="Flatten_Binary_Tree_to_Linked_List_-_将二叉树转化为链表">Flatten Binary Tree to Linked List - 将二叉树转化为链表</h3><p><strong>Description</strong>: Given a binary tree, flatten it to a linked list in-place.</p>
<p> 思路：dfs,先序 </p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlattenBinaryTreeToLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * dfs,先序</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; preOrderList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        preOrderTraversal(preOrderList, root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;preOrderList.size()-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            TreeNode node = preOrderList.get(i);</span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">            node.right = preOrderList.get(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">(List&lt;TreeNode&gt; preOrderList, TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        preOrderList.add(root);</span><br><span class="line">        preOrderTraversal(preOrderList, root.left);</span><br><span class="line">        preOrderTraversal(preOrderList, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Flatten_Binary_Tree_to_Linked_List_-_将二叉树转化为链表">Flatten Binary Tree to Linked List - 将二叉树转化为链表</h3><p><strong>Description</strong>: ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Path Sum II - 路径和II]]></title>
    <link href="http://eugeneyang.com/2016/02/01/Path%20Sum%20II%20-%20%E8%B7%AF%E5%BE%84%E5%92%8CII/"/>
    <id>http://eugeneyang.com/2016/02/01/Path Sum II - 路径和II/</id>
    <published>2016-02-01T12:44:47.000Z</published>
    <updated>2016-02-02T11:48:39.236Z</updated>
    <content type="html"><![CDATA[<h3 id="Path_Sum_II_-_路径和II">Path Sum II - 路径和II</h3><p><strong>Description</strong>: Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p> 思路：dfs递归,与Path Sum递归思路一致,但引入一个数组存储结果<br>参考：<a href="http://www.programcreek.com/2014/05/leetcode-path-sum-ii-java/" target="_blank" rel="external">http://www.programcreek.com/2014/05/leetcode-path-sum-ii-java/</a></p>
<p>还有一种解法是层次遍历，与Path Sum层次遍历解法一致，但是会超时。 </p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSumII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dfs,递归,与Path Sum思路一致,但引入一个数组存储结果</span></span><br><span class="line">    <span class="comment">//http://www.programcreek.com/2014/05/leetcode-path-sum-ii-java/</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        pathSum(result, path, root, sum-root.val);  <span class="comment">//sum-root.val而非sum</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; path, TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="comment">//if (root == null) return; //冗余</span></span><br><span class="line">        <span class="keyword">if</span> (root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span> &amp;&amp; sum==<span class="number">0</span>)&#123; <span class="comment">//这里sum判0而不是sum==root.val</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>) &#123;  <span class="comment">//有点回溯的感觉</span></span><br><span class="line">            path.add(root.left.val);</span><br><span class="line">            pathSum(result, path, root.left, sum-root.left.val);    <span class="comment">//sum-root.left.val而非sum-root.val</span></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            path.add(root.right.val);</span><br><span class="line">            pathSum(result, path, root.right, sum-root.right.val);  <span class="comment">//sum-root.right.val而非sum-root.val</span></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//层次遍历,超时</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum1(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; sums = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        nodes.add(root);</span><br><span class="line">        sums.add(root.val);</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="keyword">while</span>(!nodes.isEmpty())&#123;</span><br><span class="line">            TreeNode node = nodes.poll();</span><br><span class="line">            <span class="keyword">int</span> sumValue = sums.poll();</span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span> &amp;&amp; sumValue==sum)&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                nodes.add(node.left);</span><br><span class="line">                sums.add(sumValue+node.left.val);</span><br><span class="line">                path.add(node.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                nodes.add(node.right);</span><br><span class="line">                sums.add(sumValue+node.right.val);</span><br><span class="line">                path.add(node.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Path_Sum_II_-_路径和II">Path Sum II - 路径和II</h3><p><strong>Description</strong>: Given a binary tree and a sum, find all root-to-leaf p]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Path Sum - 路径和]]></title>
    <link href="http://eugeneyang.com/2016/01/31/Path%20Sum%20-%20%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://eugeneyang.com/2016/01/31/Path Sum - 路径和/</id>
    <published>2016-01-31T12:44:47.000Z</published>
    <updated>2016-02-02T11:48:39.233Z</updated>
    <content type="html"><![CDATA[<h3 id="Path_Sum_-_路径和">Path Sum - 路径和</h3><p><strong>Description</strong>: Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p> 思路：1 dfs,递归。参考：<a href="http://www.programcreek.com/2013/01/leetcode-path-sum/" target="_blank" rel="external">http://www.programcreek.com/2013/01/leetcode-path-sum/</a><br>2 与Minimum Depth Of Binary Tree方法基本一致：类似层次遍历,使用队列,并额外使用一个队列存储深度。</p>
<p>完整的java代码如下（含两种方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 二叉树后序遍历迭代方式(待验证)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 递归</span><br><span class="line">     * http://www.programcreek.com/2013/01/leetcode-path-sum/</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     * <span class="doctag">@param</span> sum</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val == sum &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 与Minimum Depth Of Binary Tree方法基本一致:类似层次遍历,使用队列,并额外使用一个队列存储深度.</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     * <span class="doctag">@param</span> sum</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum1</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; values = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        nodes.add(root);</span><br><span class="line">        values.add(root.val);</span><br><span class="line">        <span class="keyword">while</span>(!nodes.isEmpty())&#123;</span><br><span class="line">            TreeNode node = nodes.poll();</span><br><span class="line">            <span class="keyword">int</span> sumValue = values.poll();</span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span> &amp;&amp; sumValue==sum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                nodes.add(node.left);</span><br><span class="line">                values.add(sumValue+node.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                nodes.add(node.right);</span><br><span class="line">                values.add(sumValue+node.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Path_Sum_-_路径和">Path Sum - 路径和</h3><p><strong>Description</strong>: Given a binary tree and a sum, determine if the tree has a root-]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Minimum Depth of Binary Tree - 二叉树最小深度]]></title>
    <link href="http://eugeneyang.com/2016/01/30/Minimum%20Depth%20of%20Binary%20Tree%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
    <id>http://eugeneyang.com/2016/01/30/Minimum Depth of Binary Tree - 二叉树最小深度/</id>
    <published>2016-01-30T12:44:47.000Z</published>
    <updated>2016-02-02T11:48:39.231Z</updated>
    <content type="html"><![CDATA[<h3 id="Minimum_Depth_of_Binary_Tree_-_二叉树最小深度">Minimum Depth of Binary Tree - 二叉树最小深度</h3><p><strong>Description</strong>: Given a binary tree, find its minimum depth.<br> The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p> 思路：1 递归。类似Maximum Depth Of Binary Tree,注意边界条件不同.<br>2 类似层次遍历,使用队列,并额外使用一个队列存储深度.</p>
<p>完整的java代码如下（含两种方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumDepthOfBinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 类似Maximum Depth Of Binary Tree,注意边界条件不同.</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> getMin(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> Integer.MAX_VALUE; <span class="comment">//不是返回0</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;  <span class="comment">//新增条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(getMin(root.left), getMin(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 类似层次遍历,使用队列,并额外使用一个队列存储深度.</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; counts = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        nodes.offer(root);</span><br><span class="line">        counts.offer(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!nodes.isEmpty())&#123;</span><br><span class="line">            TreeNode node = nodes.poll();</span><br><span class="line">            <span class="keyword">int</span> count = counts.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                nodes.offer(node.left);</span><br><span class="line">                counts.offer(count+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                nodes.offer(node.right);</span><br><span class="line">                counts.offer(count+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left==<span class="keyword">null</span> &amp;&amp; node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Minimum_Depth_of_Binary_Tree_-_二叉树最小深度">Minimum Depth of Binary Tree - 二叉树最小深度</h3><p><strong>Description</strong>: Given a binary t]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Balanced Binary Tree - 平衡二叉树]]></title>
    <link href="http://eugeneyang.com/2016/01/29/Balanced%20Binary%20Tree%20-%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://eugeneyang.com/2016/01/29/Balanced Binary Tree - 平衡二叉树/</id>
    <published>2016-01-29T12:44:47.000Z</published>
    <updated>2016-02-02T11:48:39.229Z</updated>
    <content type="html"><![CDATA[<h3 id="Balanced_Binary_Tree_-_平衡二叉树">Balanced Binary Tree - 平衡二叉树</h3><p><strong>Description</strong>: Given a binary tree, determine if it is height-balanced.<br> For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<p> 思路：递归。类似Maximum Depth of Binary Tree。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalancedBinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxBalancedDepth(root)==-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxBalancedDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lDepth = maxBalancedDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rDepth = maxBalancedDepth(root.right);</span><br><span class="line">        <span class="comment">//TODO 增加以下剪枝条件提速</span></span><br><span class="line">        <span class="keyword">if</span> (lDepth==-<span class="number">1</span> || rDepth==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(lDepth-rDepth)&gt;<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(lDepth, rDepth)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此法直观,但存在大量计算冗余</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> lDepth = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rDepth = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(lDepth-rDepth) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lDepth = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rDepth = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(lDepth, rDepth)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Balanced_Binary_Tree_-_平衡二叉树">Balanced Binary Tree - 平衡二叉树</h3><p><strong>Description</strong>: Given a binary tree, determine if it]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Convert Sorted List to Binary Search Tree - 将有序链表转化为平衡二叉树]]></title>
    <link href="http://eugeneyang.com/2016/01/28/Convert%20Sorted%20List%20to%20Binary%20Search%20Tree%20-%20%E5%B0%86%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://eugeneyang.com/2016/01/28/Convert Sorted List to Binary Search Tree - 将有序链表转化为平衡二叉树/</id>
    <published>2016-01-28T12:44:47.000Z</published>
    <updated>2016-02-02T11:48:39.227Z</updated>
    <content type="html"><![CDATA[<h3 id="Convert_Sorted_List_to_Binary_Search_Tree_-_将有序链表转化为平衡二叉树">Convert Sorted List to Binary Search Tree - 将有序链表转化为平衡二叉树</h3><p><strong>Description</strong>: Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p> 思路：1 获取链表长度后,自底向上(中序顺序)递归建树；<br> 2 先将链表转为数组,再自顶向下(先根再左右子树)递归建树。</p>
<p>完整的java代码如下（含两种方式）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertSortedListToBinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Definition for singly-linked list.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取链表长度后,自底向上(中序顺序)递归建树</span></span><br><span class="line">    <span class="keyword">private</span> ListNode node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">return</span> sortedListToBST(<span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l&gt;r) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">        TreeNode left = sortedListToBST(l, m-<span class="number">1</span>);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(node.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">        TreeNode right = sortedListToBST(m+<span class="number">1</span>, r);</span><br><span class="line">        root.left = left;</span><br><span class="line">        root.right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先将链表转为数组,再自顶向下(先根再左右子树)递归建树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(list, <span class="number">0</span>, list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(List&lt;Integer&gt; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l&gt;r) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums.get(m));</span><br><span class="line">        root.left = sortedArrayToBST(nums, l, m-<span class="number">1</span>);</span><br><span class="line">        root.right = sortedArrayToBST(nums, m+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Convert_Sorted_List_to_Binary_Search_Tree_-_将有序链表转化为平衡二叉树">Convert Sorted List to Binary Search Tree - 将有序链表转化为平衡二叉树</h3><p><strong>]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Convert Sorted Array to Binary Search Tree - 将有序数组转化为平衡二叉树]]></title>
    <link href="http://eugeneyang.com/2016/01/27/Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree%20-%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://eugeneyang.com/2016/01/27/Convert Sorted Array to Binary Search Tree - 将有序数组转化为平衡二叉树/</id>
    <published>2016-01-27T12:44:49.000Z</published>
    <updated>2016-02-02T11:48:39.193Z</updated>
    <content type="html"><![CDATA[<h3 id="Convert_Sorted_Array_to_Binary_Search_Tree_-_将有序数组转化为平衡二叉树">Convert Sorted Array to Binary Search Tree - 将有序数组转化为平衡二叉树</h3><p><strong>Description</strong>: Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p> 思路：递归，类似二分搜索。因为中序序列的中间数为根.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertSortedArrayToBinarySearchTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 递归:类似二分搜索.因为中序序列的中间数为根.</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l&gt;r) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[m]);</span><br><span class="line">        root.left = sortedArrayToBST(nums, l, m-<span class="number">1</span>);</span><br><span class="line">        root.right = sortedArrayToBST(nums, m+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Convert_Sorted_Array_to_Binary_Search_Tree_-_将有序数组转化为平衡二叉树">Convert Sorted Array to Binary Search Tree - 将有序数组转化为平衡二叉树</h3><p><stron]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binary Tree Level Order Traversal II - 二叉树层次遍历II]]></title>
    <link href="http://eugeneyang.com/2016/01/27/Binary%20Tree%20Level%20Order%20Traversal%20II%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86II/"/>
    <id>http://eugeneyang.com/2016/01/27/Binary Tree Level Order Traversal II - 二叉树层次遍历II/</id>
    <published>2016-01-27T12:44:47.000Z</published>
    <updated>2016-02-02T11:48:39.191Z</updated>
    <content type="html"><![CDATA[<h3 id="Binary_Tree_Level_Order_Traversal_II_-_二叉树层次遍历II">Binary Tree Level Order Traversal II - 二叉树层次遍历II</h3><p><strong>Description</strong>: Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p> For example:<br> Given binary tree {3,9,20,#,#,15,7},<br> return its level order traversal as: [ [15,7], [9,20], [3] ]</p>
<p> 思路：与Binary Tree Level Order Traversal思路一致。广度优先搜索，使用队列实现。<br>     a. 队列初始化，将根节点压入队列。<br>     b. 当队列不为空，进行如下操作：弹出一个节点，访问；若左子节点或右子节点不为空，将其压入队列。<br>     由于题目要求按层返回结果,需要利用两个队列.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLevelOrderTraversalII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**与Binary Tree Level Order Traversal思路一致</span><br><span class="line">     * 广度优先搜索，使用队列实现。</span><br><span class="line">     a. 队列初始化，将根节点压入队列。</span><br><span class="line">     b. 当队列不为空，进行如下操作：弹出一个节点，访问；若左子节点或右子节点不为空，将其压入队列。</span><br><span class="line">     由于题目要求按层返回结果,需要利用两个队列.</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Queue&lt;TreeNode&gt; curQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; nextQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        curQueue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!curQueue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = curQueue.poll();</span><br><span class="line">            temp.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) nextQueue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) nextQueue.offer(node.right);</span><br><span class="line">            <span class="keyword">if</span> (curQueue.isEmpty()) &#123;</span><br><span class="line">                result.add(temp);</span><br><span class="line">                temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                curQueue = nextQueue;</span><br><span class="line">                nextQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Binary_Tree_Level_Order_Traversal_II_-_二叉树层次遍历II">Binary Tree Level Order Traversal II - 二叉树层次遍历II</h3><p><strong>Description</stron]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Construct Binary Tree from Inorder and Postorder Traversal - 根据后序和中序序列重构二叉树]]></title>
    <link href="http://eugeneyang.com/2016/01/26/Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal%20-%20%E6%A0%B9%E6%8D%AE%E5%90%8E%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://eugeneyang.com/2016/01/26/Construct Binary Tree from Inorder and Postorder Traversal - 根据后序和中序序列重构二叉树/</id>
    <published>2016-01-26T12:44:47.000Z</published>
    <updated>2016-01-26T13:03:09.522Z</updated>
    <content type="html"><![CDATA[<h3 id="Construct_Binary_Tree_from_Inorder_and_Postorder_Traversal_-_根据后序和中序序列重构二叉树">Construct Binary Tree from Inorder and Postorder Traversal - 根据后序和中序序列重构二叉树</h3><p><strong>Description</strong>: Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p>Note: You may assume that duplicates do not exist in the tree.</p>
<p> 思路：递归，与Construct Binary Tree from Preorder and Inorder Traversal思路一致。后序序列最后一个为根.中序序列的根的左侧序列为左子树,右侧序列为右子树。根据左右序列长度可以在后序序列中找到左右子树.<br>示例:<br>     in-order:   4 2 5 (1) 6 7 3 8<br>     post-order: 4 5 2  6 7 8 3  (1)</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructBinaryTreeFromInorderAndPostorderTraversal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 递归:后序序列最后一个为根.中序序列的根的左侧序列为左子树,右侧序列为右子树.</span><br><span class="line">     根据左右序列长度可以在后序序列中找到左右子树.</span><br><span class="line">     * 示例:</span><br><span class="line">     in-order:   4 2 5 (1) 6 7 3 8</span><br><span class="line">     post-order: 4 5 2  6 7 8 3  (1)</span><br><span class="line">     * <span class="doctag">@param</span> inorder</span><br><span class="line">     * <span class="doctag">@param</span> postorder</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rebuild(postorder, inorder, <span class="number">0</span>, postorder.length-<span class="number">1</span>, <span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> postL, <span class="keyword">int</span> postR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postL&gt;postR || inL&gt;inR) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postR]);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i&lt;inorder.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == postorder[postR]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> postLeftLen = i - inL;</span><br><span class="line">        root.left = rebuild(postorder, inorder, postL, postL+postLeftLen-<span class="number">1</span>, inL, i-<span class="number">1</span>);</span><br><span class="line">        root.right = rebuild(postorder, inorder, postL+postLeftLen, postR-<span class="number">1</span>, i+<span class="number">1</span>, inR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Construct_Binary_Tree_from_Inorder_and_Postorder_Traversal_-_根据后序和中序序列重构二叉树">Construct Binary Tree from Inorder and Postorder Traver]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Construct Binary Tree from Preorder and Inorder Traversal - 根据先序和中序序列重构二叉树]]></title>
    <link href="http://eugeneyang.com/2016/01/25/Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal%20-%20%E6%A0%B9%E6%8D%AE%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E9%87%8D%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://eugeneyang.com/2016/01/25/Construct Binary Tree from Preorder and Inorder Traversal - 根据先序和中序序列重构二叉树/</id>
    <published>2016-01-25T12:44:47.000Z</published>
    <updated>2016-01-26T13:03:09.516Z</updated>
    <content type="html"><![CDATA[<h3 id="Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal_-_根据先序和中序序列重构二叉树">Construct Binary Tree from Preorder and Inorder Traversal - 根据先序和中序序列重构二叉树</h3><p><strong>Description</strong>: Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note: You may assume that duplicates do not exist in the tree.</p>
<p> 思路：递归。先序序列第一个为根.中序序列的根的左侧序列为左子树,右侧序列为右子树。根据左右序列长度可以在先序序列中找到左右子树.<br>示例:<br>     in-order:   4 2 5 (1) 6 7 3 8<br>     pre-order: (1) 2 4 5  3 7 6 8</p>
<p>参考：<a href="http://www.programcreek.com/2014/06/leetcode-construct-binary-tree-from-preorder-and-inorder-traversal-java/" target="_blank" rel="external">http://www.programcreek.com/2014/06/leetcode-construct-binary-tree-from-preorder-and-inorder-traversal-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructBinaryTreeFromPreorderAndInorderTraversal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**http://www.programcreek.com/2014/06/leetcode-construct-binary-tree-from-preorder-and-inorder-traversal-java/</span><br><span class="line">     * 递归:先序序列第一个为根.中序序列的根的左侧序列为左子树,右侧序列为右子树.</span><br><span class="line">     根据左右序列长度可以在先序序列中找到左右子树.</span><br><span class="line">     * 示例:</span><br><span class="line">     in-order:   4 2 5 (1) 6 7 3 8</span><br><span class="line">     pre-order: (1) 2 4 5  3 7 6 8</span><br><span class="line">     * <span class="doctag">@param</span> preorder</span><br><span class="line">     * <span class="doctag">@param</span> inorder</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rebuild(preorder, inorder, <span class="number">0</span>, preorder.length-<span class="number">1</span>, <span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preL&gt;preR || inL&gt;inR) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preL]);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i&lt;inorder.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == preorder[preL]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> preLeftLen = i - inL;</span><br><span class="line">        root.left = rebuild(preorder, inorder, preL+<span class="number">1</span>, preL+preLeftLen, inL, i-<span class="number">1</span>);</span><br><span class="line">        root.right = rebuild(preorder, inorder, preL+preLeftLen+<span class="number">1</span>, preR, i+<span class="number">1</span>, inR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal_-_根据先序和中序序列重构二叉树">Construct Binary Tree from Preorder and Inorder Traversa]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maximum Depth of Binary Tree -二叉树最大深度]]></title>
    <link href="http://eugeneyang.com/2016/01/24/Maximum%20Depth%20of%20Binary%20Tree%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>http://eugeneyang.com/2016/01/24/Maximum Depth of Binary Tree - 二叉树最大深度/</id>
    <published>2016-01-24T12:44:47.000Z</published>
    <updated>2016-01-26T13:03:09.496Z</updated>
    <content type="html"><![CDATA[<h3 id="Maximum_Depth_of_Binary_Tree_-二叉树最大深度">Maximum Depth of Binary Tree -二叉树最大深度</h3><p><strong>Description</strong>: Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node<br> down to the farthest leaf node.</p>
<p> 思路：DFS递归。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumDepthOfBinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxL = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> maxR = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxL, maxR) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Maximum_Depth_of_Binary_Tree_-二叉树最大深度">Maximum Depth of Binary Tree -二叉树最大深度</h3><p><strong>Description</strong>: Given a binary tre]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binary Tree Zigzag Level Order Traversal -二叉树Z形遍历]]></title>
    <link href="http://eugeneyang.com/2016/01/23/Binary%20Tree%20Zigzag%20Level%20Order%20Traversal%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91Z%E5%BD%A2%E9%81%8D%E5%8E%86/"/>
    <id>http://eugeneyang.com/2016/01/23/Binary Tree Zigzag Level Order Traversal - 二叉树Z形遍历/</id>
    <published>2016-01-23T12:44:47.000Z</published>
    <updated>2016-01-26T13:03:09.494Z</updated>
    <content type="html"><![CDATA[<h3 id="Binary_Tree_Zigzag_Level_Order_Traversal_-二叉树Z形遍历">Binary Tree Zigzag Level Order Traversal -二叉树Z形遍历</h3><p><strong>Description</strong>: Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example: Given binary tree {3,9,20,#,#,15,7},<br>return its zigzag level order traversal as: [ [3], [20,9], [15,7] ]</p>
<p> 思路：广度优先搜索，使用队列或栈实现。由于题目要求按层返回结果,需要利用两个队列或栈。思路类似Binary Tree Level Order Traversal，不同点在于入队列或栈时注意顺序逆转。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeZigzagLevelOrderTraversal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> needReverse = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; curStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; nextStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        curStack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!curStack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = curStack.pop();</span><br><span class="line">            temp.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (needReverse) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) nextStack.push(node.right);</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) nextStack.push(node.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) nextStack.push(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) nextStack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curStack.isEmpty()) &#123;</span><br><span class="line">                result.add(temp);</span><br><span class="line">                temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                needReverse = !needReverse;</span><br><span class="line">                curStack = nextStack;</span><br><span class="line">                nextStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Binary_Tree_Zigzag_Level_Order_Traversal_-二叉树Z形遍历">Binary Tree Zigzag Level Order Traversal -二叉树Z形遍历</h3><p><strong>Description</str]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

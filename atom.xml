<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Eugene's Blog]]></title>
  <subtitle><![CDATA[成长之旅]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://eugeneyang.com/"/>
  <updated>2016-03-04T10:59:44.692Z</updated>
  <id>http://eugeneyang.com/</id>
  
  <author>
    <name><![CDATA[Jian Yang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Binary Tree Postorder Traversal- 二叉树后序遍历(迭代)]]></title>
    <link href="http://eugeneyang.com/2016/03/04/Binary%20Tree%20Postorder%20Traversal-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86(%E8%BF%AD%E4%BB%A3)/"/>
    <id>http://eugeneyang.com/2016/03/04/Binary Tree Postorder Traversal- 二叉树后序遍历(迭代)/</id>
    <published>2016-03-04T12:44:47.000Z</published>
    <updated>2016-03-04T10:59:44.692Z</updated>
    <content type="html"><![CDATA[<h3 id="Binary_Tree_Postorder_Traversal-_二叉树后序遍历(迭代)">Binary Tree Postorder Traversal- 二叉树后序遍历(迭代)</h3><p><strong>Description</strong>: Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>思路：<br>一、遍历的同时将访问过的节点的相应左或右孩子指针置空，思路简单。<br>二、后序遍历的情况相对复杂,需要维护当前遍历的cur指针和前一个遍历的pre指针来追溯当前的情况（注意这里是遍历的指针，并不是真正按后序访问顺序的结点）。具体分为几种情况：<br>     （1）如果pre的左孩子或者右孩子是cur，那么说明遍历在往下走，按访问顺序继续，即如果有左孩子，则是左孩子进栈，否则如果有右孩子，则是右孩子进栈，<br>     如果左右孩子都没有，则说明该结点是叶子，可以直接访问并把结点出栈了。<br>     （2）如果反过来，cur的左孩子是pre，则说明已经在回溯往上走了，但是后序遍历要左右孩子走完才可以访问自己，所以这里如果有右孩子还需要把右孩子进栈，否则说明已经到自己了，可以访问并且出栈了。<br>     （3）如果cur的右孩子是pre，那么说明左右孩子都访问结束了，可以轮到自己了，访问并且出栈即可。<br>     与递归法一样,算法时间复杂度也是O(n)，空间复杂度是栈的大小O(logn)。</p>
<p>参考链接：<br><a href="http://www.programcreek.com/2012/12/leetcode-solution-of-iterative-binary-tree-postorder-traversal-in-java/" target="_blank" rel="external">http://www.programcreek.com/2012/12/leetcode-solution-of-iterative-binary-tree-postorder-traversal-in-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 后序遍历的情况相对复杂,需要维护当前遍历的cur指针和前一个遍历的pre指针来追溯当前的情况</span><br><span class="line">     （注意这里是遍历的指针，并不是真正按后序访问顺序的结点）。具体分为几种情况：</span><br><span class="line">     （1）如果pre的左孩子或者右孩子是cur，那么说明遍历在往下走，按访问顺序继续，</span><br><span class="line">     即如果有左孩子，则是左孩子进栈，否则如果有右孩子，则是右孩子进栈，</span><br><span class="line">     如果左右孩子都没有，则说明该结点是叶子，可以直接访问并把结点出栈了。</span><br><span class="line">     （2）如果反过来，cur的左孩子是pre，则说明已经在回溯往上走了，</span><br><span class="line">     但是后序遍历要左右孩子走完才可以访问自己，所以这里如果有右孩子还需要把右孩子进栈，</span><br><span class="line">     否则说明已经到自己了，可以访问并且出栈了。</span><br><span class="line">     （3）如果cur的右孩子是pre，那么说明左右孩子都访问结束了，可以轮到自己了，访问并且出栈即可。</span><br><span class="line">     与递归法一样,算法时间复杂度也是O(n)，空间复杂度是栈的大小O(logn)。</span><br><span class="line">     * http://www.programcreek.com/2012/12/leetcode-solution-of-iterative-binary-tree-postorder-traversal-in-java/</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode curr = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (prev==<span class="keyword">null</span> || prev.left==curr || prev.right==curr)&#123; <span class="comment">//往下走</span></span><br><span class="line">                <span class="keyword">if</span> (curr.left!=<span class="keyword">null</span>) stack.push(curr.left);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (curr.right!=<span class="keyword">null</span>) stack.push(curr.right);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    result.add(curr.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr.left==prev)&#123;    <span class="comment">//从左节点往上走</span></span><br><span class="line">                <span class="keyword">if</span> (curr.right!=<span class="keyword">null</span>) stack.push(curr.right);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    result.add(curr.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr.right==prev)&#123;   <span class="comment">//从右节点往上走</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                result.add(curr.val);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种方法简单,但是会改变原树结构</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (stack.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode top = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (top.left == <span class="keyword">null</span> &amp;&amp; top.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(top.val);</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(top.left);</span><br><span class="line">                top.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (top.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(top.right);</span><br><span class="line">                top.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Binary_Tree_Postorder_Traversal-_二叉树后序遍历(迭代)">Binary Tree Postorder Traversal- 二叉树后序遍历(迭代)</h3><p><strong>Description</strong>: Give]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binary Tree Preorder Traversal - 二叉树先序遍历(迭代)]]></title>
    <link href="http://eugeneyang.com/2016/03/03/Binary%20Tree%20Preorder%20Traversal%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86(%E8%BF%AD%E4%BB%A3)/"/>
    <id>http://eugeneyang.com/2016/03/03/Binary Tree Preorder Traversal - 二叉树先序遍历(迭代)/</id>
    <published>2016-03-03T12:44:47.000Z</published>
    <updated>2016-03-04T10:59:44.641Z</updated>
    <content type="html"><![CDATA[<h3 id="Binary_Tree_Preorder_Traversal_-_二叉树先序遍历(迭代)">Binary Tree Preorder Traversal - 二叉树先序遍历(迭代)</h3><p><strong>Description</strong>: Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>思路：迭代法使用栈.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePreorderTraversal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Binary_Tree_Preorder_Traversal_-_二叉树先序遍历(迭代)">Binary Tree Preorder Traversal - 二叉树先序遍历(迭代)</h3><p><strong>Description</strong>: Give]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Reorder List - 重排序链表]]></title>
    <link href="http://eugeneyang.com/2016/03/02/Reorder%20List%20-%20%E9%87%8D%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://eugeneyang.com/2016/03/02/Reorder List - 重排序链表/</id>
    <published>2016-03-02T12:44:47.000Z</published>
    <updated>2016-03-04T10:59:44.639Z</updated>
    <content type="html"><![CDATA[<h3 id="Reorder_List_-_重排序链表">Reorder List - 重排序链表</h3><p><strong>Description</strong>: Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br> reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p> You must do this in-place without altering the nodes’ values.</p>
<p> For example, Given {1,2,3,4}, reorder it to {1,4,2,3}.</p>
<p>思路：使用快慢指针先将链表分成两半,逆转后半段链表,再交叉合并.</p>
<p>参考链接：<br><a href="http://www.programcreek.com/2013/12/in-place-reorder-a-singly-linked-list-in-java/" target="_blank" rel="external">http://www.programcreek.com/2013/12/in-place-reorder-a-singly-linked-list-in-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 使用快慢指针先将链表分成两半,逆转后半段链表,再交叉合并.</span><br><span class="line"> * http://www.programcreek.com/2013/12/in-place-reorder-a-singly-linked-list-in-java/</span><br><span class="line"> * <span class="doctag">@param</span> head</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode l2 = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    l2 = reverse(l2);</span><br><span class="line">    crossMerge(head, l2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode pre = head;</span><br><span class="line">    ListNode curr = head.next;</span><br><span class="line">    <span class="keyword">while</span> (curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        curr.next = pre;</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表l1/l2长度一致,交叉合并</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">crossMerge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    ListNode p1 = l1;</span><br><span class="line">    ListNode p2 = l2;</span><br><span class="line">    <span class="keyword">while</span> (p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp1 = p1.next;</span><br><span class="line">        ListNode temp2 = p2.next;</span><br><span class="line">        p1.next = p2;</span><br><span class="line">        p2.next = temp1;</span><br><span class="line">        p1 = temp1;</span><br><span class="line">        p2 = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode first = head;</span><br><span class="line">    ListNode p = first;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="keyword">null</span> &amp;&amp; p.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.next.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nextFirst = first.next;</span><br><span class="line">            first.next = p.next;</span><br><span class="line">            p.next.next = nextFirst;</span><br><span class="line">            first = nextFirst;</span><br><span class="line">            p.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">int</span> count = (num-<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (count!=<span class="number">0</span>)&#123;</span><br><span class="line">        p = first;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span> &amp;&amp; p.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.next.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                ListNode nextFirst = first.next;</span><br><span class="line">                first.next = p.next;</span><br><span class="line">                p.next.next = nextFirst;</span><br><span class="line">                first = nextFirst;</span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Reorder_List_-_重排序链表">Reorder List - 重排序链表</h3><p><strong>Description</strong>: Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br> r]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linked List Cycle II - 判断链表回环II]]></title>
    <link href="http://eugeneyang.com/2016/03/01/Linked%20List%20Cycle%20II%20-%20%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E5%9B%9E%E7%8E%AFII/"/>
    <id>http://eugeneyang.com/2016/03/01/Linked List Cycle II - 判断链表回环II/</id>
    <published>2016-03-01T12:44:47.000Z</published>
    <updated>2016-03-04T10:59:44.637Z</updated>
    <content type="html"><![CDATA[<h3 id="Linked_List_Cycle_II_-_判断链表回环II">Linked List Cycle II - 判断链表回环II</h3><p><strong>Description</strong>: Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.<br>Follow up: Can you solve it without using extra space?</p>
<p>思路：假设链表有环，环长Y，环以外的长度是X。快慢两指针从起点出发,最后相遇在K处,设环起到到K处长度为K. 有Y-K=X,意思是两指针相遇后再走X就回到了环的起点.</p>
<p>参考链接：<a href="http://fisherlei.blogspot.co.id/2013/11/leetcode-linked-list-cycle-ii-solution.html" target="_blank" rel="external">http://fisherlei.blogspot.co.id/2013/11/leetcode-linked-list-cycle-ii-solution.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListCycleII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://fisherlei.blogspot.co.id/2013/11/leetcode-linked-list-cycle-ii-solution.html</span><br><span class="line">     * 假设链表有环，环长Y，环以外的长度是X。快慢两指针从起点出发,最后相遇在K处,设环起到到K处长度为K.</span><br><span class="line">     有Y-K=X,意思是两指针相遇后再走X就回到了环的起点.</span><br><span class="line">     * <span class="doctag">@param</span> head</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow!=fast)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast==<span class="keyword">null</span> || fast.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head!=slow.next)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Linked_List_Cycle_II_-_判断链表回环II">Linked List Cycle II - 判断链表回环II</h3><p><strong>Description</strong>: Given a linked list, return th]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linked List Cycle- 判断链表回环]]></title>
    <link href="http://eugeneyang.com/2016/02/29/Linked%20List%20Cycle-%20%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E5%9B%9E%E7%8E%AF/"/>
    <id>http://eugeneyang.com/2016/02/29/Linked List Cycle- 判断链表回环/</id>
    <published>2016-02-29T12:44:47.000Z</published>
    <updated>2016-03-04T10:59:44.635Z</updated>
    <content type="html"><![CDATA[<h3 id="Linked_List_Cycle-_判断链表回环">Linked List Cycle- 判断链表回环</h3><p><strong>Description</strong>: Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up: Can you solve it without using extra space?</p>
<p>思路：<br>一、将访问过的节点都指向一个预设的特殊节点,有回环则会访问到此特殊节点。<br>二、使用快慢双指针,有回环则快指针会追上慢指针。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用快慢双指针,有回环则快指针会追上慢指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow==fast) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将访问过的节点都指向一个预设的特殊节点,有回环则会访问到此特殊节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(Integer.MAX_VALUE);</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p==dummy) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            next = p.next;</span><br><span class="line">            p.next = dummy;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Linked_List_Cycle-_判断链表回环">Linked List Cycle- 判断链表回环</h3><p><strong>Description</strong>: Given a linked list, determine if it has a]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Word Break II - 单词划分 II]]></title>
    <link href="http://eugeneyang.com/2016/02/28/Word%20Break%20II%20-%20%E5%8D%95%E8%AF%8D%E5%88%92%E5%88%86%20II/"/>
    <id>http://eugeneyang.com/2016/02/28/Word Break II - 单词划分 II/</id>
    <published>2016-02-28T12:44:47.000Z</published>
    <updated>2016-02-28T07:07:58.879Z</updated>
    <content type="html"><![CDATA[<h3 id="Word_Break_II_-_单词划分_II">Word Break II - 单词划分 II</h3><p><strong>Description</strong>: Given a string s and a dictionary of words dict, add spaces in s<br> to construct a sentence where each word is a valid dictionary word.<br> Return all such possible sentences.</p>
<p> For example, given<br> s = “catsanddog”,<br> dict = [“cat”, “cats”, “and”, “sand”, “dog”].<br> A solution is [“cats and dog”, “cat sand dog”].</p>
<p>思路：<br>一、回溯,但无法过大数据集(可以尝试引入剪枝函数提速)。<br>二、DP+回溯,与Word Break I不同在于用数组记录断词处有哪些单词,而不是简单记录布尔数组.DP之后再回溯得到所有可能的断词方式.</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/03/leetcode-word-break-ii-java/" target="_blank" rel="external">http://www.programcreek.com/2014/03/leetcode-word-break-ii-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordBreakII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * DP+回溯,与Word Break I不同在于用数组记录断词处有哪些单词,而不是简单记录布尔数组.</span><br><span class="line">     DP之后再回溯得到所有可能的断词方式.</span><br><span class="line">     http://www.programcreek.com/2014/03/leetcode-word-break-ii-java/</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@param</span> wordDict</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; dp[] = <span class="keyword">new</span> ArrayList[s.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i]==<span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (String word : wordDict)&#123;</span><br><span class="line">                <span class="keyword">int</span> end = i+word.length();</span><br><span class="line">                <span class="keyword">if</span> (end&gt;s.length()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.substring(i, end).equals(word))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[end]==<span class="keyword">null</span>) dp[end] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    dp[end].add(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[s.length()]==<span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        dfs(dp, s.length(), result, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt;[] dp, <span class="keyword">int</span> end, List&lt;String&gt; result, List&lt;String&gt; tmp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            String path = tmp.get(tmp.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=tmp.size()-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) path += <span class="string">" "</span> + tmp.get(i);</span><br><span class="line">            result.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String str : dp[end])&#123;</span><br><span class="line">            tmp.add(str);</span><br><span class="line">            dfs(dp, end-str.length(), result, tmp);</span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回溯,但无法过大数据集(可以尝试引入剪枝函数提速)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak1</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        wordBreakHelper(s, wordDict, <span class="number">0</span>, result, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wordBreakHelper</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start,</span><br><span class="line">                                 List&lt;String&gt; result, StringBuilder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start==s.length())&#123;</span><br><span class="line">            result.add(builder.toString().trim());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start+<span class="number">1</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            String str = s.substring(start, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(str)) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = builder.length();</span><br><span class="line">                builder.append(<span class="string">" "</span>+str);</span><br><span class="line">                wordBreakHelper(s, wordDict, i+<span class="number">1</span>, result, builder);</span><br><span class="line">                builder.delete(len, len+str.length()+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Word_Break_II_-_单词划分_II">Word Break II - 单词划分 II</h3><p><strong>Description</strong>: Given a string s and a dictionary of words dic]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Word Break - 单词划分]]></title>
    <link href="http://eugeneyang.com/2016/02/27/Word%20Break%20-%20%E5%8D%95%E8%AF%8D%E5%88%92%E5%88%86/"/>
    <id>http://eugeneyang.com/2016/02/27/Word Break - 单词划分/</id>
    <published>2016-02-27T12:44:47.000Z</published>
    <updated>2016-02-28T07:07:58.877Z</updated>
    <content type="html"><![CDATA[<h3 id="Word_Break_-_单词划分">Word Break - 单词划分</h3><p><strong>Description</strong>: Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p> For example, given<br> s = “leetcode”,<br> dict = [“leet”, “code”].<br> Return true because “leetcode” can be segmented as “leet code”.</p>
<p>思路：<br>一、原始办法:回溯,超时。<br>二、看到这题第一反应是DFS枚举查找，直到“探”到string尾部则算成功。但题目并不要求给出是如何break的，而只要判断是否能break。对这类判断“是”与“否”的可以用DFS暴力解决的题，可以尝试用DP做book keeping中间判断状态，避免DFS的反复搜索。<br>定义t[i]为区间[0,i-1]能否被分割,注意初始状态t[0]=True.<br>t[i+1]=True时应满足:1.s[k,i]在字典中,0&lt;=k&lt;=i;2.t[k]==True.</p>
<p>注意：本题边界情况极易出错。</p>
<p>参考链接：<a href="http://www.programcreek.com/2012/12/leetcode-solution-word-break/" target="_blank" rel="external">http://www.programcreek.com/2012/12/leetcode-solution-word-break/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordBreak</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**http://www.programcreek.com/2012/12/leetcode-solution-word-break/</span><br><span class="line">     * 看到这题第一反应是DFS枚举查找，直到“探”到string尾部则算成功。但题目并不要求给出是如何break的，</span><br><span class="line">     而只要判断是否能break。对这类判断“是”与“否”的可以用DFS暴力解决的题，</span><br><span class="line">     可以尝试用DP做book keeping中间判断状态，避免DFS的反复搜索。</span><br><span class="line">     * 定义t[i]为区间[0,i-1]能否被分割,注意初始状态t[0]=True.</span><br><span class="line">     t[i+1]=True时应满足:1.s[k,i]在字典中,0&lt;=k&lt;=i;2.t[k]==True.</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@param</span> wordDict</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] t = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        t[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i; j++)&#123;   <span class="comment">//TODO 边界极易出错</span></span><br><span class="line">                <span class="keyword">if</span> (t[j] &amp;&amp; wordDict.contains(s.substring(j, i+<span class="number">1</span>)))&#123;</span><br><span class="line">                    t[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基于给定字典遍历的DP,注意代码中if (t[end]) continue;部分易错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak1</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] t = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        t[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!t[i]) <span class="keyword">continue</span>;    <span class="comment">//不能分割,跳过</span></span><br><span class="line">            <span class="keyword">for</span> (String word : wordDict)&#123;</span><br><span class="line">                <span class="keyword">int</span> end = i+word.length();</span><br><span class="line">                <span class="keyword">if</span> (end&gt;s.length()) <span class="keyword">continue</span>;   <span class="comment">//超过字符串s长度</span></span><br><span class="line">                <span class="comment">//注意用例"programcreek", ["programcree","program","creek"]</span></span><br><span class="line">                <span class="comment">//下面的语句保证不会停在programcree,而是读完所有programcreek</span></span><br><span class="line">                <span class="keyword">if</span> (t[end]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.substring(i, end).equals(word)) t[end] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原始办法:回溯,超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak2</span><span class="params">(String s, Set&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wordBreakHelper(s, wordDict, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基于给定字典遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">wordBreakHelper</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start==s.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = word.length();</span><br><span class="line">            <span class="keyword">int</span> end = start+len;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; s.length()) <span class="keyword">continue</span>; <span class="comment">//超过字符串s长度</span></span><br><span class="line">            <span class="keyword">if</span> (s.substring(start, end).equals(word))&#123;</span><br><span class="line">                <span class="keyword">if</span> (wordBreakHelper(s, wordDict, end)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基于给定字符串s遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">wordBreakHelper1</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start==s.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start+<span class="number">1</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            String str = s.substring(start, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!wordDict.contains(str)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (wordBreakHelper(s, wordDict, i+<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Word_Break_-_单词划分">Word Break - 单词划分</h3><p><strong>Description</strong>: Given a string s and a dictionary of words dict, determine]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Copy List with Random Pointer - 复制带随机指针的链表]]></title>
    <link href="http://eugeneyang.com/2016/02/26/Copy%20List%20with%20Random%20Pointer%20-%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://eugeneyang.com/2016/02/26/Copy List with Random Pointer - 复制带随机指针的链表/</id>
    <published>2016-02-26T12:44:47.000Z</published>
    <updated>2016-02-28T07:07:58.874Z</updated>
    <content type="html"><![CDATA[<h3 id="Copy_List_with_Random_Pointer_-_复制带随机指针的链表">Copy List with Random Pointer - 复制带随机指针的链表</h3><p><strong>Description</strong>: A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list.</p>
<p>思路：<br>一、与Clone Graph思路一致,使用队列和哈希表；<br>二、仅使用哈希表和双指针,速度更快。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyListWithRandomPointer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for singly-linked list with a random pointer.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> label;</span><br><span class="line">        RandomListNode next, random;</span><br><span class="line">        RandomListNode(<span class="keyword">int</span> x) &#123; <span class="keyword">this</span>.label = x; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//仅使用哈希表和双指针,速度更快</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        RandomListNode newHead = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">        RandomListNode p = head;</span><br><span class="line">        RandomListNode q = newHead;</span><br><span class="line">        map.put(head, newHead);</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode newNode = <span class="keyword">new</span> RandomListNode(p.label);</span><br><span class="line">            map.put(p, newNode);</span><br><span class="line">            q.next = newNode;</span><br><span class="line">            q = newNode;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        q = newHead;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.random!=<span class="keyword">null</span>) q.random = map.get(p.random);</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与Clone Graph思路一致,使用队列和哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList1</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;RandomListNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(head);</span><br><span class="line">        RandomListNode newHead = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">        map.put(head, newHead);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            RandomListNode curOld = queue.poll();</span><br><span class="line">            RandomListNode[] olds = &#123;curOld.next, curOld.random&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (olds[i]==<span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(olds[i]))&#123;</span><br><span class="line">                    RandomListNode newNode = <span class="keyword">new</span> RandomListNode(olds[i].label);</span><br><span class="line">                    map.put(olds[i], newNode);</span><br><span class="line">                    <span class="keyword">if</span> (i==<span class="number">0</span>) map.get(curOld).next = newNode;</span><br><span class="line">                    <span class="keyword">else</span> map.get(curOld).random = newNode;</span><br><span class="line">                    queue.offer(olds[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==<span class="number">0</span>) map.get(curOld).next = map.get(curOld.next);</span><br><span class="line">                    <span class="keyword">else</span> map.get(curOld).random = map.get(curOld.random);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Copy_List_with_Random_Pointer_-_复制带随机指针的链表">Copy List with Random Pointer - 复制带随机指针的链表</h3><p><strong>Description</strong>: A linked]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Single Number II - 寻找单一整数II]]></title>
    <link href="http://eugeneyang.com/2016/02/25/Single%20Number%20II%20-%20%E5%AF%BB%E6%89%BE%E5%8D%95%E4%B8%80%E6%95%B4%E6%95%B0II/"/>
    <id>http://eugeneyang.com/2016/02/25/Single Number II - 寻找单一整数II/</id>
    <published>2016-02-25T12:44:47.000Z</published>
    <updated>2016-02-28T07:07:58.872Z</updated>
    <content type="html"><![CDATA[<h3 id="Single_Number_II_-_寻找单一整数II">Single Number II - 寻找单一整数II</h3><p><strong>Description</strong>: Given an array of integers, every element appears three times except for one. Find that single one.</p>
<p>Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>思路：<br>一、由于x\^x\^x = x，无法直接利用Single Number I的异或方法来解。但可以应用类似的思路，即利用位运算来消除重复3次的数。以一个数组[14 14 14 9]为例，<br>     将每个数字以二进制表达：<br>     1110<br>     1110<br>     1110<br>     1001</p>
<pre><code>_____
<span class="number">4331</span>    对每一位进行求和
<span class="number">1001</span>    对每一位的和做%<span class="number">3</span>运算，来消去所有重复<span class="number">3</span>次的数
</code></pre><p>二、用哈希表，但速度慢，需消耗额外空间。</p>
<p>参考链接：<a href="http://bangbingsyb.blogspot.co.id/2014/11/leetcode-single-number-i-ii.html" target="_blank" rel="external">http://bangbingsyb.blogspot.co.id/2014/11/leetcode-single-number-i-ii.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleNumberII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://bangbingsyb.blogspot.co.id/2014/11/leetcode-single-number-i-ii.html</span><br><span class="line">     * 由于x^x^x = x，无法直接利用I的方法来解。</span><br><span class="line">     但可以应用类似的思路，即利用位运算来消除重复3次的数。以一个数组[14 14 14 9]为例，</span><br><span class="line">     将每个数字以二进制表达：</span><br><span class="line">     1110</span><br><span class="line">     1110</span><br><span class="line">     1110</span><br><span class="line">     1001</span><br><span class="line">     _____</span><br><span class="line">     4331    对每一位进行求和</span><br><span class="line">     1001    对每一位的和做%3运算，来消去所有重复3次的数</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">31</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> ((nums[j] &amp; mask) != <span class="number">0</span>) sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            result = (result&lt;&lt;<span class="number">1</span>) + sum%<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(nums[i]))&#123;</span><br><span class="line">                map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums[i], map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(i)!=<span class="number">3</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Single_Number_II_-_寻找单一整数II">Single Number II - 寻找单一整数II</h3><p><strong>Description</strong>: Given an array of integers, every elem]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Single Number - 寻找单一整数]]></title>
    <link href="http://eugeneyang.com/2016/02/24/Single%20Number%20-%20%E5%AF%BB%E6%89%BE%E5%8D%95%E4%B8%80%E6%95%B4%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/02/24/Single Number - 寻找单一整数/</id>
    <published>2016-02-24T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.351Z</updated>
    <content type="html"><![CDATA[<h3 id="Single_Number_-_寻找单一整数">Single Number - 寻找单一整数</h3><p><strong>Description</strong>: Given an array of integers, every element appears twice except for one. Find that single one.<br> Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>思路：<br>1 异或(此法不消耗额外空间),只有两不同位异或才会返回1,所有相同整数异或结果为整数0.<br>2 集合<br>3 哈希表</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异或(此法不消耗额外空间),只有两不同位异或才会返回1,所有相同整数异或结果为整数0.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) nums[<span class="number">0</span>] = nums[<span class="number">0</span>]^nums[i];</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(n)) set.remove(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)set.toArray()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(nums[i]))&#123;</span><br><span class="line">                map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums[i], map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(i)==<span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Single_Number_-_寻找单一整数">Single Number - 寻找单一整数</h3><p><strong>Description</strong>: Given an array of integers, every element appear]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Longest Valid Parentheses - 最长匹配括号序列]]></title>
    <link href="http://eugeneyang.com/2016/02/24/Longest%20Valid%20Parentheses%20-%20%E6%9C%80%E9%95%BF%E5%8C%B9%E9%85%8D%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"/>
    <id>http://eugeneyang.com/2016/02/24/Longest Valid Parentheses - 最长匹配括号序列/</id>
    <published>2016-02-24T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.348Z</updated>
    <content type="html"><![CDATA[<h3 id="Longest_Valid_Parentheses_-_最长匹配括号序列">Longest Valid Parentheses - 最长匹配括号序列</h3><p><strong>Description</strong>: Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p> For “(()”, the longest valid parentheses substring is “()”, which has length = 2.<br> Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p>
<p>思路：DP可解,但是大数据超时.<br>用栈来存左括号的index，遍历s，遇到’(‘就放入lefts栈。<br>如果遇到’)’，如果lefts是空，说明这是一个无法匹配的’)’，记录下last。<br>last里面存放的其实是最后一个无法匹配的’)’,主要是为了计算后面完整的表达式的长度。可以这样理解：所有无法匹配的’)’的index其实都是各个group的分界点。</p>
<p>参考链接：<br><a href="http://www.cnblogs.com/lichen782/p/leetcode_Longest_Valid_Parentheses.html" target="_blank" rel="external">http://www.cnblogs.com/lichen782/p/leetcode_Longest_Valid_Parentheses.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestValidParentheses</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">new</span> LongestValidParentheses()</span><br><span class="line">                .longestValidParentheses(<span class="string">")))))(((()("</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**TODO 重温理解及记忆,尤其是代码最后一个else部分</span><br><span class="line">     * http://www.cnblogs.com/lichen782/p/leetcode_Longest_Valid_Parentheses.html</span><br><span class="line">     * DP可解,但是大数据超时.</span><br><span class="line">     * 用栈来存左括号的index，遍历s，遇到'('就放入lefts栈。</span><br><span class="line">     如果遇到')'，如果lefts是空，说明这是一个无法匹配的')'，记录下last。</span><br><span class="line">     last里面存放的其实是最后一个无法匹配的')',主要是为了计算后面完整的表达式的长度。</span><br><span class="line">     可以这样理解：所有无法匹配的')'的index其实都是各个group的分界点。</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, last = -<span class="number">1</span>;</span><br><span class="line">        Stack&lt;Integer&gt; lefts = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==<span class="string">'('</span>) &#123;</span><br><span class="line">                lefts.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lefts.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// no matching left</span></span><br><span class="line">                    last = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// find a matching pair</span></span><br><span class="line">                    lefts.pop();</span><br><span class="line">                    <span class="keyword">if</span> (lefts.isEmpty()) &#123;<span class="comment">//有一个完整的valid的group。计算该group的长度</span></span><br><span class="line">                        maxLen = Math.max(maxLen, i - last);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//栈内还有‘(',一个最外层完整的group还没有匹配完成，</span></span><br><span class="line">                        <span class="comment">//但是通过查询下一个即将匹配还未匹配的"("的index来更新maxLen。</span></span><br><span class="line">                        <span class="keyword">int</span> k = lefts.peek();</span><br><span class="line">                        maxLen = Math.max(maxLen, i - k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Longest_Valid_Parentheses_-_最长匹配括号序列">Longest Valid Parentheses - 最长匹配括号序列</h3><p><strong>Description</strong>: Given a string conta]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Candy - 糖果游戏]]></title>
    <link href="http://eugeneyang.com/2016/02/23/Candy%20-%20%E7%B3%96%E6%9E%9C%E6%B8%B8%E6%88%8F/"/>
    <id>http://eugeneyang.com/2016/02/23/Candy - 糖果游戏/</id>
    <published>2016-02-23T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.345Z</updated>
    <content type="html"><![CDATA[<h3 id="Candy_-_糖果游戏">Candy - 糖果游戏</h3><p><strong>Description</strong>: There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements:<br> Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give?</p>
<p>思路：涉及相邻元素问题,类似Trapping Rain Water,总体思路也是从左从右双向遍历.<br>贪心:只要遇到更大的相邻值,则可以加一;但要总数最小,则需按升序来加一.<br>首先从左向右遍历,升序加一;再从右向左遍历,升序加一.</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/03/leetcode-candy-java/" target="_blank" rel="external">http://www.programcreek.com/2014/03/leetcode-candy-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 涉及相邻元素问题,类似Trapping Rain Water,总体思路也是从左从右双向遍历.</span><br><span class="line">     * 贪心:只要遇到更大的相邻值,则可以加一;但要总数最小,则需按升序来加一.</span><br><span class="line">     首先从左向右遍历,升序加一;再从右向左遍历,升序加一.</span><br><span class="line">     http://www.programcreek.com/2014/03/leetcode-candy-java/</span><br><span class="line">     * <span class="doctag">@param</span> ratings</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] candies = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">        candies[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> total = candies[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;ratings.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i-<span class="number">1</span>]&lt;ratings[i])&#123;</span><br><span class="line">                candies[i] = candies[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                candies[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            total += candies[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=ratings.length-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i]&gt;ratings[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span> (! (candies[i]&gt;candies[i+<span class="number">1</span>])) &#123;</span><br><span class="line">                    <span class="keyword">int</span> old = candies[i];   <span class="comment">//TODO 易错(用例[5,3,1]),并非新增值都是1,应存储原值,用以计算新增值</span></span><br><span class="line">                    candies[i] = candies[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    total += candies[i]-old;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Candy_-_糖果游戏">Candy - 糖果游戏</h3><p><strong>Description</strong>: There are N children standing in a line. Each child is assigned a ra]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gas Station - 加油站问题]]></title>
    <link href="http://eugeneyang.com/2016/02/22/Gas%20Station%20-%20%E5%8A%A0%E6%B2%B9%E7%AB%99%E9%97%AE%E9%A2%98/"/>
    <id>http://eugeneyang.com/2016/02/22/Gas Station - 加油站问题/</id>
    <published>2016-02-22T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.319Z</updated>
    <content type="html"><![CDATA[<h3 id="Gas_Station_-_加油站问题">Gas Station - 加油站问题</h3><p><strong>Description</strong>: There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p>
<p> Note: The solution is guaranteed to be unique.</p>
<p>思路：贪心:关键是要可以总结出来这道题目的属性，注意Note这个地方，其属性主要有两个：<br>     1 如果总的gas - cost小于零的话，那么没有解返回-1;<br>     2 如果前面所有的gas - cost加起来小于零，那么前面所有的点都不能作为出发点。</p>
<p>参考链接：<a href="http://blog.csdn.net/kenden23/article/details/14106137" target="_blank" rel="external">http://blog.csdn.net/kenden23/article/details/14106137</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GasStation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 贪心:关键是要可以总结出来这道题目的属性，注意Note这个地方，其属性主要有两个：</span><br><span class="line">     1 如果总的gas - cost小于零的话，那么没有解返回-1;</span><br><span class="line">     2 如果前面所有的gas - cost加起来小于零，那么前面所有的点都不能作为出发点。</span><br><span class="line">     http://blog.csdn.net/kenden23/article/details/14106137</span><br><span class="line">     * <span class="doctag">@param</span> gas</span><br><span class="line">     * <span class="doctag">@param</span> cost</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> remaining = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curRemaining = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> totalRemaining = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;gas.length; i++)&#123;</span><br><span class="line">            remaining = gas[i]-cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curRemaining&gt;=<span class="number">0</span>) curRemaining += remaining;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                curRemaining = remaining;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">            totalRemaining += remaining;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalRemaining &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Gas_Station_-_加油站问题">Gas Station - 加油站问题</h3><p><strong>Description</strong>: There are N gas stations along a circular route, where]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Clone Graph - 复制无向图]]></title>
    <link href="http://eugeneyang.com/2016/02/21/Clone%20Graph%20-%20%E5%A4%8D%E5%88%B6%E6%97%A0%E5%90%91%E5%9B%BE/"/>
    <id>http://eugeneyang.com/2016/02/21/Clone Graph - 复制无向图/</id>
    <published>2016-02-21T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.316Z</updated>
    <content type="html"><![CDATA[<h3 id="Clone_Graph_-_复制无向图">Clone Graph - 复制无向图</h3><p><strong>Description</strong>: Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>原题参见：<a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="external">https://leetcode.com/problems/clone-graph/</a></p>
<p>思路：无向图深拷贝,BFS，用到一个队列和旧节点到新节点的映射。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneGraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraphNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> label;</span><br><span class="line">        List&lt;UndirectedGraphNode&gt; neighbors;</span><br><span class="line">        UndirectedGraphNode(<span class="keyword">int</span> x) &#123; label = x; neighbors = <span class="keyword">new</span> ArrayList&lt;UndirectedGraphNode&gt;(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 无向图深拷贝,BFS</span><br><span class="line">     * <span class="doctag">@param</span> node</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        UndirectedGraphNode newHead = <span class="keyword">new</span> UndirectedGraphNode(node.label);</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        map.put(node, newHead);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            UndirectedGraphNode curr = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(UndirectedGraphNode aNeighbor: curr.neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(aNeighbor))&#123;</span><br><span class="line">                    UndirectedGraphNode copy = <span class="keyword">new</span> UndirectedGraphNode(aNeighbor.label);</span><br><span class="line">                    map.put(aNeighbor, copy);</span><br><span class="line">                    map.get(curr).neighbors.add(copy);</span><br><span class="line">                    queue.add(aNeighbor);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.get(curr).neighbors.add(map.get(aNeighbor));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无向图深拷贝,BFS,比上面的方法慢</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph1</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Queue&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;UndirectedGraphNode&gt; originQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        originQueue.offer(node);</span><br><span class="line">        map.put(node.label, <span class="keyword">new</span> UndirectedGraphNode(node.label));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            UndirectedGraphNode theNode = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraphNode n : theNode.neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(n.label))&#123;</span><br><span class="line">                    map.put(n.label, <span class="keyword">new</span> UndirectedGraphNode(n.label));</span><br><span class="line">                    queue.offer(n);</span><br><span class="line">                    originQueue.offer(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!originQueue.isEmpty()) &#123;</span><br><span class="line">            UndirectedGraphNode theNode = originQueue.poll();</span><br><span class="line">            UndirectedGraphNode newNode = map.get(theNode.label);</span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraphNode n : theNode.neighbors)&#123;</span><br><span class="line">                newNode.neighbors.add(map.get(n.label));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(node.label);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Clone_Graph_-_复制无向图">Clone Graph - 复制无向图</h3><p><strong>Description</strong>: Clone an undirected graph. Each node in the graph cont]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Palindrome Partitioning II - 回文划分II]]></title>
    <link href="http://eugeneyang.com/2016/02/20/Palindrome%20Partitioning%20II%20-%20%E5%9B%9E%E6%96%87%E5%88%92%E5%88%86II/"/>
    <id>http://eugeneyang.com/2016/02/20/Palindrome Partitioning II - 回文划分II/</id>
    <published>2016-02-20T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.313Z</updated>
    <content type="html"><![CDATA[<h3 id="Palindrome_Partitioning_II_-_回文划分II">Palindrome Partitioning II - 回文划分II</h3><p><strong>Description</strong>: Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br> Return 1 since the palindrome partitioning [“aa”,”b”] could be produced using 1 cut. </p>
<p>思路：DP(双重二维),也可以用回溯法(参考Palindrome Partitioning).</p>
<p>定义cutNum(i)为[0,i]间最小切割数,n为字符串长度,0&lt;i&lt;=n,<br>有cutNum(0,i)=min[curNum(0,j-1)+curNum(j,i)],<br>存在一个回文的情况下,简化为<br>cutNum(i)=min[cutNum(j-1)+1],0&lt;j=&lt;i;cutNum(i)=0,j=0.<br>     核心思想在于”j从0到i的过程中每找到一个回文,若要切割则在前次切割的基础上加1次”.</p>
<p>判断[j,i]间是否为回文也是DP问题,定义palindrome(j,i)为[j,i]间是否为回文,<br>     有palindrome(j,i)= str(j)==str(i) &amp;&amp; (i-j&lt;=1 || palindrome(j+1, i-1)).<br>     i-j&lt;=1因为一个字符一定也是回文(这个条件使得边界情况初始化可以省略).</p>
<p>参考：<a href="http://www.programcreek.com/2014/04/leetcode-palindrome-partitioning-ii-java/" target="_blank" rel="external">http://www.programcreek.com/2014/04/leetcode-palindrome-partitioning-ii-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromePartitioningII</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**http://www.programcreek.com/2014/04/leetcode-palindrome-partitioning-ii-java/</span><br><span class="line">     * DP(双重二维),也可以用回溯法(参考Palindrome Partitioning).</span><br><span class="line">     * 定义cutNum(i)为[0,i]间最小切割数,n为字符串长度,0&lt;i&lt;=n,</span><br><span class="line">     有cutNum(0,i)=min[curNum(0,j-1)+curNum(j,i)],</span><br><span class="line">     存在一个回文的情况下,简化为cutNum(i)=min[cutNum(j-1)+1],0&lt;j=&lt;i;cutNum(i)=0,j=0.</span><br><span class="line">     核心思想在于"j从0到i的过程中每找到一个回文,若要切割则在前次切割的基础上加1次".</span><br><span class="line">     * 判断[j,i]间是否为回文也是DP问题,定义palindrome(j,i)为[j,i]间是否为回文,</span><br><span class="line">     有palindrome(j,i)= str(j)==str(i) &amp;&amp; (i-j&lt;=1 || palindrome(j+1, i-1)).</span><br><span class="line">     i-j&lt;=1因为一个字符一定也是回文(这个条件使得边界情况初始化可以省略).</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] palindrome = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">int</span>[] cutNum = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            cutNum[i] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(j)==s.charAt(i) &amp;&amp; (i-j&lt;=<span class="number">1</span> || palindrome[j+<span class="number">1</span>][i-<span class="number">1</span>]))&#123;</span><br><span class="line">                    palindrome[j][i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j==<span class="number">0</span>) cutNum[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> cutNum[i] = Math.min(cutNum[i], cutNum[j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cutNum[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Palindrome_Partitioning_II_-_回文划分II">Palindrome Partitioning II - 回文划分II</h3><p><strong>Description</strong>: Given a string s, part]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Palindrome Partitioning - 回文划分]]></title>
    <link href="http://eugeneyang.com/2016/02/19/Palindrome%20Partitioning%20-%20%E5%9B%9E%E6%96%87%E5%88%92%E5%88%86/"/>
    <id>http://eugeneyang.com/2016/02/19/Palindrome Partitioning - 回文划分/</id>
    <published>2016-02-19T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.311Z</updated>
    <content type="html"><![CDATA[<h3 id="Palindrome_Partitioning_-_回文划分">Palindrome Partitioning - 回文划分</h3><p><strong>Description</strong>: Given a string s, partition s such that every substring of the partition is a palindrome.<br> Return all possible palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br> Return [ [“aa”,”b”], [“a”,”a”,”b”] ]</p>
<p>思路：回溯法(DFS),当然DP也可以(可参考Palindrome Partitioning II).</p>
<p>参考：<a href="http://www.programcreek.com/2013/03/leetcode-palindrome-partitioning-java/" target="_blank" rel="external">http://www.programcreek.com/2013/03/leetcode-palindrome-partitioning-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromePartitioning</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> PalindromePartitioning().partition(<span class="string">"amanaplanacanalpanama"</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; list : result)&#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : list)&#123;</span><br><span class="line">                System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2013/03/leetcode-palindrome-partitioning-java/</span><br><span class="line">     * 回溯法(DFS),当然DP也可以(可参考Palindrome Partitioning II).</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        List&lt;String&gt; partitionList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        partitionHepler(s, <span class="number">0</span>, partitionList, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">partitionHepler</span><span class="params">(String s, <span class="keyword">int</span> start, List&lt;String&gt; partitionList, List&lt;List&lt;String&gt;&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start==s.length())&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(partitionList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start+<span class="number">1</span>; i&lt;=s.length(); i++)&#123;</span><br><span class="line">            String str = s.substring(start, i);</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(str))&#123;</span><br><span class="line">                partitionList.add(str);</span><br><span class="line">                partitionHepler(s, i, partitionList, result);</span><br><span class="line">                partitionList.remove(partitionList.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=str.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(l++)!=str.charAt(r--)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Palindrome_Partitioning_-_回文划分">Palindrome Partitioning - 回文划分</h3><p><strong>Description</strong>: Given a string s, partition s su]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Surrounded Regions - 环绕区域]]></title>
    <link href="http://eugeneyang.com/2016/02/18/Surrounded%20Regions%20-%20%E7%8E%AF%E7%BB%95%E5%8C%BA%E5%9F%9F/"/>
    <id>http://eugeneyang.com/2016/02/18/Surrounded Regions - 环绕区域/</id>
    <published>2016-02-18T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.308Z</updated>
    <content type="html"><![CDATA[<h3 id="Surrounded_Regions_-_环绕区域">Surrounded Regions - 环绕区域</h3><p><strong>Description</strong>: Given a 2D board containing ‘X’ and ‘O’, capture all regions surrounded by ‘X’. A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<p>For example,<br> X X X X<br> X O O X<br> X X O X<br> X O X X<br> After running your function, the board should be:<br> X X X X<br> X X X X<br> X X X X<br> X O X X</p>
<p>思路：边界处的O不能被包围,可以先遍历一次将与边界相连的所有O找出并替换成#,再遍历一次将O换成X,#换回O. 注意如果采用DFS可能会产生栈溢出,因此用BFS.</p>
<p>参考：<a href="http://www.programcreek.com/2014/04/leetcode-surrounded-regions-java/" target="_blank" rel="external">http://www.programcreek.com/2014/04/leetcode-surrounded-regions-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SurroundedRegions</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2014/04/leetcode-surrounded-regions-java/</span><br><span class="line">     * 边界处的O不能被包围,可以先遍历一次将与边界相连的所有O找出并替换成#,再遍历一次将O换成X,#换回O.</span><br><span class="line">     如果采用DFS可能会产生栈溢出,因此用BFS.</span><br><span class="line">     * <span class="doctag">@param</span> board</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// merge O's on left &amp; right boarder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">'O'</span>) bfs(board, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">'O'</span>) bfs(board, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// merge O's on top &amp; bottom boarder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">'O'</span>) bfs(board, <span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">'O'</span>) bfs(board, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// process the board</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'#'</span>)  board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// fill current first and then its neighbors</span></span><br><span class="line">        fillCell(board, i, j);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = cur / n;</span><br><span class="line">            <span class="keyword">int</span> y = cur % n;</span><br><span class="line">            fillCell(board, x - <span class="number">1</span>, y);</span><br><span class="line">            fillCell(board, x + <span class="number">1</span>, y);</span><br><span class="line">            fillCell(board, x, y - <span class="number">1</span>);</span><br><span class="line">            fillCell(board, x, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillCell</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || board[i][j] != <span class="string">'O'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// add current cell is queue &amp; then process its neighbors in bfs</span></span><br><span class="line">        queue.offer(i * n + j);</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Surrounded_Regions_-_环绕区域">Surrounded Regions - 环绕区域</h3><p><strong>Description</strong>: Given a 2D board containing ‘X’ and ‘O’, c]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sum Root to Leaf Numbers - 二叉树所有路径之和]]></title>
    <link href="http://eugeneyang.com/2016/02/17/Sum%20Root%20to%20Leaf%20Numbers%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C/"/>
    <id>http://eugeneyang.com/2016/02/17/Sum Root to Leaf Numbers - 二叉树所有路径之和/</id>
    <published>2016-02-17T12:44:47.000Z</published>
    <updated>2016-02-17T16:08:21.457Z</updated>
    <content type="html"><![CDATA[<h3 id="Sum_Root_to_Leaf_Numbers_-_二叉树所有路径之和">Sum Root to Leaf Numbers - 二叉树所有路径之和</h3><p><strong>Description</strong>: Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. Find the total sum of all root-to-leaf numbers.</p>
<p> For example,<br>   1<br>  / \<br> 2   3<br> The root-to-leaf path 1-&gt;2 represents the number 12.<br> The root-to-leaf path 1-&gt;3 represents the number 13.<br> Return the sum = 12 + 13 = 25.</p>
<p>思路：典型的root-&gt;leaf路径问题，遍历所有path并更新sum。传递的变量是当前节点的路径和curSum,则下一层的节点对应的路径和为curSum*10 + node.val。注意当根到叶的路径很长时,curSum容易溢出.</p>
<p>参考：<a href="http://www.programcreek.com/2014/05/leetcode-sum-root-to-leaf-numbers-java/" target="_blank" rel="external">http://www.programcreek.com/2014/05/leetcode-sum-root-to-leaf-numbers-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumRootToLeafNumbers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2014/05/leetcode-sum-root-to-leaf-numbers-java/</span><br><span class="line">     * 典型的root-&gt;leaf路径问题，遍历所有path并更新sum。</span><br><span class="line">     传递的变量是当前节点的路径和curSum,则下一层的节点对应的路径和为curSum*10 + node.val。</span><br><span class="line">     注意当根到叶的路径很长时,curSum容易溢出.</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> getSum(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(TreeNode node, <span class="keyword">int</span> curSum, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) <span class="keyword">return</span> sum; <span class="comment">//TODO return 0;也可以,sum只有在叶子节点才触发计算</span></span><br><span class="line">        curSum = curSum*<span class="number">10</span> + node.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left==<span class="keyword">null</span> &amp;&amp; node.right==<span class="keyword">null</span>)&#123;   <span class="comment">//叶子节点</span></span><br><span class="line">            <span class="keyword">return</span> sum + curSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右子树</span></span><br><span class="line">        <span class="keyword">return</span> getSum(node.left, curSum, sum) + getSum(node.right, curSum, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http://blog.csdn.net/linhuanmars/article/details/22913699</span></span><br><span class="line">    <span class="comment">//另一种递归风格,但速度较慢</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> sum*<span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">return</span> helper(root.left,sum*<span class="number">10</span>+root.val) + helper(root.right,sum*<span class="number">10</span>+root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Sum_Root_to_Leaf_Numbers_-_二叉树所有路径之和">Sum Root to Leaf Numbers - 二叉树所有路径之和</h3><p><strong>Description</strong>: Given a binary tree ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Longest Consecutive Sequence - 最长的连续序列Word Ladder II - 词梯II]]></title>
    <link href="http://eugeneyang.com/2016/02/16/Longest%20Consecutive%20Sequence%20-%20%E6%9C%80%E9%95%BF%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <id>http://eugeneyang.com/2016/02/16/Longest Consecutive Sequence - 最长的连续序列/</id>
    <published>2016-02-16T12:44:47.000Z</published>
    <updated>2016-02-17T16:08:21.455Z</updated>
    <content type="html"><![CDATA[<h3 id="Longest_Consecutive_Sequence_-_最长的连续序列">Longest Consecutive Sequence - 最长的连续序列</h3><p><strong>Description</strong>: Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,<br> Given [100, 4, 200, 1, 3, 2],<br> The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<p>思路：因为排序至少要O(nlogn),先排序是不行的.这里使用哈希表.</p>
<p>参考：<a href="http://www.programcreek.com/2013/01/leetcode-longest-consecutive-sequence-java/" target="_blank" rel="external">http://www.programcreek.com/2013/01/leetcode-longest-consecutive-sequence-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestConsecutiveSequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2013/01/leetcode-longest-consecutive-sequence-java/</span><br><span class="line">     * 因为排序至少要O(nlogn),先排序是不行的.这里使用哈希表.</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : nums) set.add(e);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = e-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = e+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (set.contains(left))&#123;</span><br><span class="line">                count++;</span><br><span class="line">                set.remove(left);</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (set.contains(right))&#123;</span><br><span class="line">                count++;</span><br><span class="line">                set.remove(right);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            longest = Math.max(longest, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Longest_Consecutive_Sequence_-_最长的连续序列">Longest Consecutive Sequence - 最长的连续序列</h3><p><strong>Description</strong>: Given an unsorte]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Word Ladder II - 词梯II]]></title>
    <link href="http://eugeneyang.com/2016/02/15/Word%20Ladder%20II%20-%20%E8%AF%8D%E6%A2%AFII/"/>
    <id>http://eugeneyang.com/2016/02/15/Word Ladder II - 词梯II/</id>
    <published>2016-02-15T12:44:47.000Z</published>
    <updated>2016-02-17T16:08:21.451Z</updated>
    <content type="html"><![CDATA[<h3 id="Word_Ladder_II_-_词梯II">Word Ladder II - 词梯II</h3><p><strong>Description</strong>: Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:<br> 1 Only one letter can be changed at a time<br> 2 Each intermediate word must exist in the word list</p>
<p> For example,<br> Given: beginWord = “hit” endWord = “cog”<br> wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br> Return<br> [ [“hit”,”hot”,”dot”,”dog”,”cog”],<br> [“hit”,”hot”,”lot”,”log”,”cog”] ]</p>
<p> Note:<br> All words have the same length.<br> All words contain only lowercase alphabetic characters.</p>
<p>思路：分支限界法(BFS,最短路径),与Word Ladder思路类似,不同点在于<br>     1 不能直接从wordList中直接删除访问过的字符串,需要引入两个新的集合,只有转换步数发生变化,才从字典中移除(观察到不同转换序列不可能出现重复的词,除了首尾两个词);<br>     2 引入的数据结构WordNode多一个字段</p>
<p>参考：<a href="http://www.programcreek.com/2014/06/leetcode-word-ladder-ii-java/" target="_blank" rel="external">http://www.programcreek.com/2014/06/leetcode-word-ladder-ii-java/</a></p>
<p>注意：将chars字符数组转换成String千万别写成了chars.toString(); ，不小心犯了这个低级错误会很麻烦。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordLadderII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String beginWord = <span class="string">"a"</span>;</span><br><span class="line">        String endWord = <span class="string">"c"</span>;</span><br><span class="line">        Set&lt;String&gt; wordList = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        wordList.add(<span class="string">"a"</span>);</span><br><span class="line">        wordList.add(<span class="string">"b"</span>);</span><br><span class="line">        wordList.add(<span class="string">"c"</span>);</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> WordLadderII().findLadders(beginWord, endWord, wordList);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; list : result)&#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : list)&#123;</span><br><span class="line">                System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WordNode</span></span>&#123;</span><br><span class="line">        String word;</span><br><span class="line">        List&lt;String&gt; transformList; <span class="comment">//TODO 这里可以改成存储WordNode pre来优化性能</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WordNode</span><span class="params">(String word, List&lt;String&gt; oldTransformList)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.word = word;</span><br><span class="line">            transformList = <span class="keyword">new</span> ArrayList&lt;&gt;(oldTransformList);</span><br><span class="line">            transformList.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSteps</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> transformList.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 分支限界法(BFS,最短路径),与Word Ladder思路类似,不同点在于</span><br><span class="line">     1 不能直接从wordList中直接删除访问过的字符串,需要引入两个新的集合;</span><br><span class="line">     2 引入的数据结构WordNode多一个字段</span><br><span class="line">     * http://www.programcreek.com/2014/06/leetcode-word-ladder-ii-java/</span><br><span class="line">     * <span class="doctag">@param</span> beginWord</span><br><span class="line">     * <span class="doctag">@param</span> endWord</span><br><span class="line">     * <span class="doctag">@param</span> wordList</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, Set&lt;String&gt; wordList) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;WordNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> WordNode(beginWord, <span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">        wordList.add(endWord);</span><br><span class="line">        <span class="comment">//不能直接从wordList中直接删除访问过的字符串,引入两个新的集合</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; unVisited = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">int</span> minSteps = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> preSteps = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            WordNode top = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> curSteps = top.getSteps();</span><br><span class="line">            <span class="keyword">if</span> (top.word.equals(endWord)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curSteps &gt; minSteps) <span class="keyword">return</span> result;</span><br><span class="line">                minSteps = curSteps;</span><br><span class="line">                result.add(top.transformList);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//只有转换步数发生变化,才从字典中移除(观察到不同转换序列不可能出现重复的词,除了首尾两个词)</span></span><br><span class="line">            <span class="keyword">if</span> (curSteps &gt; preSteps) &#123;</span><br><span class="line">                unVisited.removeAll(visited);</span><br><span class="line">                preSteps = curSteps;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span>[] chars = top.word.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;chars.length; i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> origin = chars[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c=<span class="string">'a'</span>; c&lt;=<span class="string">'z'</span>; c++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (chars[i]!=c) chars[i] = c;</span><br><span class="line">                    String newString = <span class="keyword">new</span> String(chars);   <span class="comment">//TODO 千万别写成了chars.toString();</span></span><br><span class="line">                    <span class="keyword">if</span> (unVisited.contains(newString))&#123;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> WordNode(newString, top.transformList));</span><br><span class="line">                        visited.add(newString);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                chars[i] = origin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Word_Ladder_II_-_词梯II">Word Ladder II - 词梯II</h3><p><strong>Description</strong>: Given two words (beginWord and endWord), and a dic]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

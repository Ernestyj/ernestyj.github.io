<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Eugene's Blog]]></title>
  <subtitle><![CDATA[成长之旅]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://eugeneyang.com/"/>
  <updated>2016-01-08T07:05:21.834Z</updated>
  <id>http://eugeneyang.com/</id>
  
  <author>
    <name><![CDATA[Jian Yang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Scramble String - 字符串重组]]></title>
    <link href="http://eugeneyang.com/2016/01/08/Scramble%20String%20-%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8D%E7%BB%84/"/>
    <id>http://eugeneyang.com/2016/01/08/Scramble String - 字符串重组/</id>
    <published>2016-01-08T12:44:47.000Z</published>
    <updated>2016-01-08T07:05:21.834Z</updated>
    <content type="html"><![CDATA[<h3 id="Scramble_String_-_字符串重组">Scramble String - 字符串重组</h3><p><strong>Description</strong>: Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.</p>
<p>原题链接：<a href="https://leetcode.com/problems/scramble-string/" target="_blank" rel="external">https://leetcode.com/problems/scramble-string/</a></p>
<p>题解：<br>方法一：递归解法：时间复杂度最差为O(3^n)，要通过OJ需要加上剪枝条件：把两个字符串的字符排序后，然后比较是否相同。</p>
<p>方法二：三维动态规划解法：提出维护量res[i][j][n]，其中i是s1的起始字符，j是s2的起始字符，而n是当前的字符串长度，res[i][j][len]表示的是以i和j分别为s1和s2起点的长度为len的字符串是不是互为scramble。</p>
<p>递推式：首先是把当前s1[i…i+len-1]字符串劈一刀分成两部分，然后分两种情况：<br>第一种是左边和s2[j…j+len-1]左边部分是不是scramble，以及右边和s2[j…j+len-1]右边部分是不是scramble；<br>第二种情况是左边和s2[j…j+len-1]右边部分是不是scramble，以及右边和s2[j…j+len-1]左边部分是不是scramble。<br>如果以上两种情况有一种成立，说明s1[i…i+len-1]和s2[j…j+len-1]是scramble的。<br>上面说的是劈一刀的情况，对于s1[i…i+len-1]我们有len-1种劈法，在这些劈法中只要有一种成立，那么两个串就是scramble的。</p>
<p>总结：res[i][j][len] |= (res[i][j][k]&amp;&amp;res[i+k][j+k][len-k] || res[i][j+len-k][k]&amp;&amp;res[i+k][j][len-k]),1&lt;=k&lt;len，也就是对于所有len-1种劈法的结果求或运算。</p>
<p>复杂度：因为信息都是计算过的，对于每种劈法只需要常量操作，因此求解递推式需要线性时间（因为len-1种劈法）。如此总时间复杂度因为是三维动态规划需要三层循环，加上每一步需要线行时间求解递推式，所以是O(n\^4)。空间复杂度是O(n\^3)。</p>
<p>参考：<a href="http://blog.csdn.net/fightforyourdream/article/details/17707187" target="_blank" rel="external">http://blog.csdn.net/fightforyourdream/article/details/17707187</a></p>
<p>完整的java代码如下（不包括方法一）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScrambleString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://blog.csdn.net/fightforyourdream/article/details/17707187</span><br><span class="line">     * 递归解法：时间复杂度最差为O(3^n)，要通过OJ需要加上剪枝条件：把两个字符串的字符排序后，然后比较是否相同。</span><br><span class="line">     * 三维动态规划解法：提出维护量res[i][j][n]，其中i是s1的起始字符，j是s2的起始字符，而n是当前的字符串长度，</span><br><span class="line">      res[i][j][len]表示的是以i和j分别为s1和s2起点的长度为len的字符串是不是互为scramble。</span><br><span class="line">     * 递推式：首先是把当前s1[i...i+len-1]字符串劈一刀分成两部分，然后分两种情况：</span><br><span class="line">      第一种是左边和s2[j...j+len-1]左边部分是不是scramble，以及右边和s2[j...j+len-1]右边部分是不是scramble；</span><br><span class="line">      第二种情况是左边和s2[j...j+len-1]右边部分是不是scramble，以及右边和s2[j...j+len-1]左边部分是不是scramble。</span><br><span class="line">      如果以上两种情况有一种成立，说明s1[i...i+len-1]和s2[j...j+len-1]是scramble的。</span><br><span class="line">     上面说的是劈一刀的情况，对于s1[i...i+len-1]我们有len-1种劈法，在这些劈法中只要有一种成立，那么两个串就是scramble的。</span><br><span class="line">     总结：res[i][j][len] |= (res[i][j][k]&amp;&amp;res[i+k][j+k][len-k] || res[i][j+len-k][k]&amp;&amp;res[i+k][j][len-k]),1&lt;=k&lt;len，</span><br><span class="line">     也就是对于所有len-1种劈法的结果求或运算。</span><br><span class="line">     * 复杂度：因为信息都是计算过的，对于每种劈法只需要常量操作，因此求解递推式需要线性时间（因为len-1种劈法）。</span><br><span class="line">     如此总时间复杂度因为是三维动态规划需要三层循环，加上每一步需要线行时间求解递推式，所以是O(n^4)。空间复杂度是O(n^3)。</span><br><span class="line">     * <span class="doctag">@param</span> s1</span><br><span class="line">     * <span class="doctag">@param</span> s2</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s1.length();</span><br><span class="line">        <span class="keyword">if</span>(len != s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][][] canScramble = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len][len+<span class="number">1</span>];   <span class="comment">// i,j with sub length</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;  <span class="comment">// subLen=1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len; j++) &#123;</span><br><span class="line">                <span class="comment">// substring start from i with length 1, compared with substring start from j with length 1</span></span><br><span class="line">                canScramble[i][j][<span class="number">1</span>] = s1.charAt(i) == s2.charAt(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> subLen=<span class="number">2</span>; subLen&lt;=len; subLen++) &#123;</span><br><span class="line">            <span class="comment">// (end_pos=i+subLen-1) &lt;= len-1, so i &lt;= len-subLen</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=len-subLen; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=len-subLen; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>; p&lt;subLen; p++) &#123;   <span class="comment">// split position</span></span><br><span class="line">                        canScramble[i][j][subLen] |= (canScramble[i][j][p] &amp;&amp; canScramble[i+p][j+p][subLen-p]) ||</span><br><span class="line">                                (canScramble[i][j+subLen-p][p] &amp;&amp; canScramble[i+p][j][subLen-p]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> canScramble[<span class="number">0</span>][<span class="number">0</span>][len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Scramble_String_-_字符串重组">Scramble String - 字符串重组</h3><p><strong>Description</strong>: Given a string s1, we may represent it as a bi]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Partition List - 划分链表]]></title>
    <link href="http://eugeneyang.com/2016/01/07/Partition%20List%20-%20%E5%88%92%E5%88%86%E9%93%BE%E8%A1%A8/"/>
    <id>http://eugeneyang.com/2016/01/07/Partition List - 划分链表/</id>
    <published>2016-01-07T12:44:47.000Z</published>
    <updated>2016-01-07T03:48:11.949Z</updated>
    <content type="html"><![CDATA[<h3 id="Partition_List_-_划分链表">Partition List - 划分链表</h3><p><strong>Description</strong>: Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p> You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p> For example,<br> Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br> return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
<p>思路：</p>
<ol>
<li>从左往右扫描，找到第一个大于x的节点，然后再在该节点左边不断插入小于x的元素。</li>
<li>由于不要求sort，只要求partition。可以建立一个新的链表l2。遍历原链表l1的每个节点p。<br>  p-&gt;val &lt; x，保留。<br>  p-&gt;val &gt;= x，从l1中移出并插入l2。<br>可以参考：<a href="http://bangbingsyb.blogspot.com/2014/11/leetcode-partition-list.html" target="_blank" rel="external">http://bangbingsyb.blogspot.com/2014/11/leetcode-partition-list.html</a></li>
</ol>
<p>完整的java代码如下（不包括方法2）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Definition for singly-linked list.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从左往右扫描，找到第一个大于x的节点，然后再在该节点左边不断插入小于x的元素。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition1</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode p = dummy;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">boolean</span> foundBound = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span> &amp;&amp; p.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.next.val &gt;= x) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!foundBound) &#123;</span><br><span class="line">                    cur = p;</span><br><span class="line">                    foundBound = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.next.val &lt; x)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!foundBound)&#123;</span><br><span class="line">                    p = p.next; <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode moveNode = p.next;</span><br><span class="line">                p.next = moveNode.next;</span><br><span class="line"></span><br><span class="line">                moveNode.next = cur.next;</span><br><span class="line">                cur.next = moveNode;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Partition_List_-_划分链表">Partition List - 划分链表</h3><p><strong>Description</strong>: Given a linked list and a value x, partition it su]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maximal Rectangle - 矩阵中的最大矩形]]></title>
    <link href="http://eugeneyang.com/2016/01/06/Maximal%20Rectangle%20-%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <id>http://eugeneyang.com/2016/01/06/Maximal Rectangle - 矩阵中的最大矩形/</id>
    <published>2016-01-06T12:44:47.000Z</published>
    <updated>2016-01-06T08:17:40.079Z</updated>
    <content type="html"><![CDATA[<h3 id="Maximal_Rectangle_-_矩阵中的最大矩形">Maximal Rectangle - 矩阵中的最大矩形</h3><p><strong>Description</strong>: Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area.</p>
<p>思路：<a href="http://www.cnblogs.com/lichen782/p/leetcode_maximal_rectangle.html" target="_blank" rel="external">http://www.cnblogs.com/lichen782/p/leetcode_maximal_rectangle.html</a> 中给出了O(n^3)的普通方法（但会大数据超时）。高效的方法：转化为Largest Rectangle in Histogram的问题，时间复杂为O(n^2).</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximalRectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.cnblogs.com/lichen782/p/leetcode_maximal_rectangle.html 中给出了O(n^3)的普通方法（会大数据超时）。</span><br><span class="line">     * 高效的方法：转化为Largest Rectangle in Histogram的问题，时间复杂为O(n^2).</span><br><span class="line">     * <span class="doctag">@param</span> matrix</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//实际上height可以分配一维数组存储</span></span><br><span class="line">        <span class="keyword">int</span>[][] height = <span class="keyword">new</span> <span class="keyword">int</span>[m][n + <span class="number">1</span>]; <span class="comment">//末尾多加一个dummy元素0</span></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//矩阵按行转化为柱状图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                    height[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    height[i][j] = (i == <span class="number">0</span>) ? <span class="number">1</span> : height[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算每个柱状图的最大矩形面积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> area = maxAreaInHist(height[i]);</span><br><span class="line">            <span class="keyword">if</span> (area &gt; maxArea) &#123;</span><br><span class="line">                maxArea = area;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Largest Rectangle in Histogram算法，传入的height数组最后一个元素是多加的dummy元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxAreaInHist</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; height.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() || height[stack.peek()] &lt;= height[i]) &#123;</span><br><span class="line">                stack.push(i++);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> t = stack.pop();</span><br><span class="line">                maxArea = Math.max(maxArea, height[t] * (stack.isEmpty() ? i : i - stack.peek() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Maximal_Rectangle_-_矩阵中的最大矩形">Maximal Rectangle - 矩阵中的最大矩形</h3><p><strong>Description</strong>: Given a 2D binary matrix filled with]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Largest Rectangle In Histogram - 柱状图中的最大长方形]]></title>
    <link href="http://eugeneyang.com/2016/01/05/Largest%20Rectangle%20In%20Histogram%20-%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E6%96%B9%E5%BD%A2/"/>
    <id>http://eugeneyang.com/2016/01/05/Largest Rectangle In Histogram - 柱状图中的最大长方形/</id>
    <published>2016-01-05T12:44:47.000Z</published>
    <updated>2016-01-05T05:45:41.925Z</updated>
    <content type="html"><![CDATA[<h3 id="Largest_Rectangle_In_Histogram_-_柱状图中的最大长方形">Largest Rectangle In Histogram - 柱状图中的最大长方形</h3><p><strong>Description</strong>: Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p> For example,<br> Given height = [2,1,5,6,2,3],<br> return 10.</p>
<p>方法1：维护一个栈，栈内只存高度递增的条形索引。这个动态栈的特点是：栈内元素一定比当前i指向的元素小。另一个关键点是弹栈过程中面积的计算（高<em>宽）：h[t] </em> (stack.isEmpty() ? i : i - stack.peek() - 1)。时间复杂度：O(n)。</p>
<p>方法2：从左往右扫描，对合适的右边界（此条形大于其右边条形），再往左遍历面积。时间复杂度：O(n*n)。</p>
<p>参考：<a href="http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html" target="_blank" rel="external">http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargestRectangleInHistogram</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 参考：http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html</span><br><span class="line">     * 方法1：维护一个栈，栈内只存高度递增的条形索引。这个动态栈的特点是：栈内元素一定比当前i指向的元素小。</span><br><span class="line">     * 另一个关键点是弹栈过程中面积的计算（高*宽）：h[t] * (stack.isEmpty() ? i : i - stack.peek() - 1)。</span><br><span class="line">     * 时间复杂度：O(n)。</span><br><span class="line">     * 方法2：从左往右扫描，对合适的右边界（此条形大于其右边条形），再往左遍历面积。时间复杂度：O(n*n)。</span><br><span class="line">     * <span class="doctag">@param</span> height</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] h = Arrays.copyOf(height, height.length + <span class="number">1</span>); <span class="comment">//末尾添加dummy元素0</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; h.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty() || h[stack.peek()] &lt;= h[i])&#123; <span class="comment">//维护高度递增条形索引栈</span></span><br><span class="line">                stack.push(i++);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//当前元素小于栈顶元素</span></span><br><span class="line">                <span class="keyword">int</span> p = stack.pop();</span><br><span class="line">                <span class="comment">//高h[p]，宽stack.isEmpty() ? i : i - stack.peek() - 1</span></span><br><span class="line">                maxArea = Math.max(maxArea, h[p] * (stack.isEmpty() ? i : i - stack.peek() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Largest_Rectangle_In_Histogram_-_柱状图中的最大长方形">Largest Rectangle In Histogram - 柱状图中的最大长方形</h3><p><strong>Description</strong>: Given ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Remove Duplicates from Sorted List - 移除有序链表中的重复元素]]></title>
    <link href="http://eugeneyang.com/2016/01/04/Remove%20Duplicates%20from%20Sorted%20List%20-%20%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://eugeneyang.com/2016/01/04/Remove Duplicates from Sorted List - 移除有序链表中的重复元素/</id>
    <published>2016-01-04T12:44:47.000Z</published>
    <updated>2016-01-04T05:28:30.613Z</updated>
    <content type="html"><![CDATA[<h3 id="Remove_Duplicates_from_Sorted_List_-_移除有序链表中的重复元素">Remove Duplicates from Sorted List - 移除有序链表中的重复元素</h3><p><strong>Description</strong>: Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p> For example,<br> Given 1-&gt;1-&gt;2, return 1-&gt;2.<br> Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>
<p>思路：直接往后遍历，根据前后节点值是否相等做相应处理。或者用Remove Duplicates from Sorted List II 的思路，遍历中探测当前节点的下两个节点。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesFromSortedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Definition for singly-linked list.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val == p.next.val)&#123;</span><br><span class="line">                p.next = p.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p.next; <span class="comment">//TODO 只有值不同时才往下走</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用RemoveDuplicatesFromSortedListII思路</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="keyword">null</span> &amp;&amp; p.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next.val == p.next.next.val)&#123;</span><br><span class="line">                <span class="keyword">int</span> dup = p.next.val;</span><br><span class="line">                p = p.next; <span class="comment">//与RemoveDuplicatesFromSortedListII的唯一区别，多了此语句，来存储重复节点一次</span></span><br><span class="line">                <span class="keyword">while</span>(p.next!=<span class="keyword">null</span> &amp;&amp; p.next.val==dup)&#123;</span><br><span class="line">                    p.next = p.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Remove_Duplicates_from_Sorted_List_-_移除有序链表中的重复元素">Remove Duplicates from Sorted List - 移除有序链表中的重复元素</h3><p><strong>Description</str]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Remove Duplicates from Sorted List II - 移除有序链表中的重复元素II]]></title>
    <link href="http://eugeneyang.com/2016/01/03/Remove%20Duplicates%20from%20Sorted%20List%20II%20-%20%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <id>http://eugeneyang.com/2016/01/03/Remove Duplicates from Sorted List II - 移除有序链表中的重复元素II/</id>
    <published>2016-01-03T12:44:47.000Z</published>
    <updated>2016-01-04T05:23:45.155Z</updated>
    <content type="html"><![CDATA[<h3 id="Remove_Duplicates_from_Sorted_List_II_-_移除有序链表中的重复元素II">Remove Duplicates from Sorted List II - 移除有序链表中的重复元素II</h3><p><strong>Description</strong>: Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p> For example,<br> Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br> Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p>
<p>思路：遍历中探测当前节点的下两个节点。<br>心得：这道题刚做的时候，思路非常不清晰，导致写到后面节点间关系理不清，算法无法写下去。对于链表类型的题目，要格外注意节点间关系，引入头节点前的dummy节点是很常用的技巧。</p>
<p>参考：<a href="http://www.programcreek.com/2014/06/leetcode-remove-duplicates-from-sorted-list-ii-java/。" target="_blank" rel="external">http://www.programcreek.com/2014/06/leetcode-remove-duplicates-from-sorted-list-ii-java/。</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesFromSortedListII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Definition for singly-linked list.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 遍历中探测当前节点的下两个节点</span><br><span class="line">     * http://www.programcreek.com/2014/06/leetcode-remove-duplicates-from-sorted-list-ii-java/</span><br><span class="line">     * <span class="doctag">@param</span> head</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="keyword">null</span> &amp;&amp; p.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.next.val == p.next.next.val)&#123;</span><br><span class="line">                <span class="keyword">int</span> dup = p.next.val;</span><br><span class="line">                <span class="keyword">while</span>(p.next!=<span class="keyword">null</span> &amp;&amp; p.next.val==dup)&#123;</span><br><span class="line">                    p.next = p.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Remove_Duplicates_from_Sorted_List_II_-_移除有序链表中的重复元素II">Remove Duplicates from Sorted List II - 移除有序链表中的重复元素II</h3><p><strong>Descri]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Search In Rotated Sorted Array II]]></title>
    <link href="http://eugeneyang.com/2016/01/02/Search%20In%20Rotated%20Sorted%20Array%20II/"/>
    <id>http://eugeneyang.com/2016/01/02/Search In Rotated Sorted Array II/</id>
    <published>2016-01-02T12:44:47.000Z</published>
    <updated>2016-01-02T10:49:03.084Z</updated>
    <content type="html"><![CDATA[<h3 id="Search_In_Rotated_Sorted_Array_II">Search In Rotated Sorted Array II</h3><p><strong>Description</strong>: Follow up for “Search in Rotated Sorted Array”:<br> What if duplicates are allowed?<br> Would this affect the run-time complexity? How and why?<br> Write a function to determine if a given target is in the array.</p>
<p>思路：与Search In Rotated Sorted Array一致，只是当有重复数字，会存在A[m] = A[r]的情况。此时右半序列可能是sorted，也可能并没有sorted，如下例子。<br>     3 1 2 3 3 3 3<br>     3 3 3 3 1 2 3<br>     所以当A[m] = A[r] != target时，无法排除一半的序列，而只能排除掉A[r]，此时只能搜寻A[l : r-1]。<br>     正因为这个变化，在最坏情况下，算法的复杂度从O(logn)退化成了O(n)：例如序列 2 2 2 2 2 2 2 中寻找target = 1。</p>
<p>参考：<a href="http://bangbingsyb.blogspot.com/2014/11/leetcode-search-in-rotated-sorted-array.html。" target="_blank" rel="external">http://bangbingsyb.blogspot.com/2014/11/leetcode-search-in-rotated-sorted-array.html。</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchInRotatedSortedArrayII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> isFound = <span class="keyword">new</span> SearchInRotatedSortedArrayII().search(nums, <span class="number">0</span>);</span><br><span class="line">        System.out.println(isFound);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 当有重复数字，会存在A[m] = A[r]的情况。此时右半序列可能是sorted，也可能并没有sorted，如下例子。</span><br><span class="line">     3 1 2 3 3 3 3</span><br><span class="line">     3 3 3 3 1 2 3</span><br><span class="line">     所以当A[m] = A[r] != target时，无法排除一半的序列，而只能排除掉A[r]，此时只能搜寻A[l : r-1]</span><br><span class="line">     正因为这个变化，在最坏情况下，算法的复杂度从O(logn)退化成了O(n)：例如序列 2 2 2 2 2 2 2 中寻找target = 1。</span><br><span class="line">     参考：http://bangbingsyb.blogspot.com/2014/11/leetcode-search-in-rotated-sorted-array.html</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@param</span> target</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[m]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt; nums[r]) &#123;    <span class="comment">//m~r有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[m] &lt; target &amp;&amp; target &lt;= nums[r]) l = m + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; nums[r])&#123;  <span class="comment">//l~m有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[m]) r = m - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">//nums[m] == nums[r]时</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Search_In_Rotated_Sorted_Array_II">Search In Rotated Sorted Array II</h3><p><strong>Description</strong>: Follow up for “Search in R]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Remove Duplicates from Sorted Array II - 从有序数组中移除重复元素II]]></title>
    <link href="http://eugeneyang.com/2016/01/01/Remove%20Duplicates%20from%20Sorted%20Array%20II%20-%20%E4%BB%8E%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <id>http://eugeneyang.com/2016/01/01/Remove Duplicates from Sorted Array II - 从有序数组中移除重复元素II/</id>
    <published>2016-01-01T12:44:47.000Z</published>
    <updated>2016-01-01T11:18:04.047Z</updated>
    <content type="html"><![CDATA[<h3 id="Remove_Duplicates_from_Sorted_Array_II_-_从有序数组中移除重复元素II">Remove Duplicates from Sorted Array II - 从有序数组中移除重复元素II</h3><p><strong>Description</strong>: Follow up for “Remove Duplicates”: What if duplicates are allowed at most twice?</p>
<p> Note: Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p> For example,<br> Given sorted array nums = [1,1,1,2,2,3],<br> Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length.</p>
<p>今天是2016.1.1元旦节，新年快乐！<br><img src="/images/2016.png" alt="2016"></p>
<p>思路：与Remove Duplicates from Sorted Array一致，用index存不同数字的个数(可以含两次重复的数字)，遍历数组判断当前值是否和前一个值不一样。如果不一样，就是一个新的值，更新数组并对index加1。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesFromSortedArrayII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//        int[] nums = &#123;1&#125;;</span></span><br><span class="line">        System.out.println(<span class="string">"************************"</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="keyword">new</span> RemoveDuplicatesFromSortedArrayII().removeDuplicates(nums);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 用index存不同数字的个数(可以含两次重复的数字)，遍历数组判断当前值是否和前一个值不一样。</span><br><span class="line">     如果不一样，就是一个新的值，更新数组并对index加1。</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[index++] = nums[i];    <span class="comment">//其实 index++; 即可</span></span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; <span class="number">2</span>)&#123;</span><br><span class="line">                    nums[index++] = nums[i];    <span class="comment">//其实 index++; 即可</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Remove_Duplicates_from_Sorted_Array_II_-_从有序数组中移除重复元素II">Remove Duplicates from Sorted Array II - 从有序数组中移除重复元素II</h3><p><strong>Desc]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Word Search - 单词二维搜索]]></title>
    <link href="http://eugeneyang.com/2015/12/31/Word%20Search%20-%20%E5%8D%95%E8%AF%8D%E4%BA%8C%E7%BB%B4%E6%90%9C%E7%B4%A2/"/>
    <id>http://eugeneyang.com/2015/12/31/Word Search - 单词二维搜索/</id>
    <published>2015-12-31T12:44:47.000Z</published>
    <updated>2015-12-31T05:26:42.652Z</updated>
    <content type="html"><![CDATA[<h3 id="Word_Search_-_单词二维搜索">Word Search - 单词二维搜索</h3><p><strong>Description</strong>: Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br> Given board =<br> [ [‘A’,’B’,’C’,’E’],<br> [‘S’,’F’,’C’,’S’],<br> [‘A’,’D’,’E’,’E’] ]<br> word = “ABCCED”, -&gt; returns true,<br> word = “SEE”, -&gt; returns true,<br> word = “ABCB”, -&gt; returns false.</p>
<p>思路：回溯法。将当前搜索字符标记为“#”表示已搜索过，搜索方向包括上下左右四种。</p>
<p>参考：<a href="http://www.programcreek.com/2014/06/leetcode-word-search-java/" target="_blank" rel="external">http://www.programcreek.com/2014/06/leetcode-word-search-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2014/06/leetcode-word-search-java/</span><br><span class="line">     * 回溯法</span><br><span class="line">     * <span class="doctag">@param</span> board</span><br><span class="line">     * <span class="doctag">@param</span> word</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=m || j&gt;=n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] == word.charAt(k))&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">            board[i][j]=<span class="string">'#'</span>;    <span class="comment">//mark</span></span><br><span class="line">            <span class="keyword">if</span>(k==word.length()-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dfs(board, word, i-<span class="number">1</span>, j, k+<span class="number">1</span>)</span><br><span class="line">                    ||dfs(board, word, i+<span class="number">1</span>, j, k+<span class="number">1</span>)</span><br><span class="line">                    ||dfs(board, word, i, j-<span class="number">1</span>, k+<span class="number">1</span>)</span><br><span class="line">                    ||dfs(board, word, i, j+<span class="number">1</span>, k+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[i][j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Word_Search_-_单词二维搜索">Word Search - 单词二维搜索</h3><p><strong>Description</strong>: Given a 2D board and a word, find if the word exists]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Subsets - 求子集]]></title>
    <link href="http://eugeneyang.com/2015/12/30/Subsets%20-%20%E6%B1%82%E5%AD%90%E9%9B%86/"/>
    <id>http://eugeneyang.com/2015/12/30/Subsets - 求子集/</id>
    <published>2015-12-30T12:44:47.000Z</published>
    <updated>2015-12-31T05:22:46.970Z</updated>
    <content type="html"><![CDATA[<h3 id="Subsets_-_求子集">Subsets - 求子集</h3><p><strong>Description</strong>: Given a set of distinct integers, nums, return all possible subsets.</p>
<p> Note:<br> Elements in a subset must be in non-descending order.<br> The solution set must not contain duplicate subsets.</p>
<p> For example,<br> If nums = [1,2,3], a solution is:<br> [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]</p>
<p>思路：位操作，或者用回溯法。位操作中，判断数i第k位是否为1：i&amp;(1 &lt;&lt; k-1) != 0则为1。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subsets</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        Subsets instance = <span class="keyword">new</span> Subsets();</span><br><span class="line">        instance.subsets(nums);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; ints : instance.result)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : ints) System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; temp;</span><br><span class="line">    <span class="comment">//判断数i第k位是否为1：i&amp;(1 &lt;&lt; k-1) != 0则为1</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span> &lt;&lt; len;   <span class="comment">//2^len</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//查看第一层循环任意一种取值中哪一位是1；如果是1，对应的字符就存在</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=len; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span> ( (i&amp;(<span class="number">1</span> &lt;&lt; k-<span class="number">1</span>)) != <span class="number">0</span> ) temp.add(nums[k-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Subsets_-_求子集">Subsets - 求子集</h3><p><strong>Description</strong>: Given a set of distinct integers, nums, return all possible subset]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Combinations - 组合数]]></title>
    <link href="http://eugeneyang.com/2015/12/29/Combinations%20-%20%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <id>http://eugeneyang.com/2015/12/29/Combinations - 组合数/</id>
    <published>2015-12-29T12:44:47.000Z</published>
    <updated>2015-12-29T05:16:51.890Z</updated>
    <content type="html"><![CDATA[<h3 id="Combinations_-_组合数">Combinations - 组合数</h3><p><strong>Description</strong>: Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p> For example,<br> If n = 4 and k = 2, a solution is:<br> [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4] ]</p>
<p>思路：回溯法。</p>
<p>类似的问题有：Combination Sum(含重复或不重复元素)、Permutation等。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Combinations</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        Combinations instance = <span class="keyword">new</span> Combinations();</span><br><span class="line">        instance.combine(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; ints : instance.result)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : ints) System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        backTrack(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=x; i&lt;=n; i++)&#123;</span><br><span class="line">            temp.add(i);</span><br><span class="line">            backTrack(n, k - <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Combinations_-_组合数">Combinations - 组合数</h3><p><strong>Description</strong>: Given two integers n and k, return all possible combinat]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Minimum Window Substring - 最小子串窗口]]></title>
    <link href="http://eugeneyang.com/2015/12/28/Minimum%20Window%20Substring%20-%20%E6%9C%80%E5%B0%8F%E5%AD%90%E4%B8%B2%E7%AA%97%E5%8F%A3/"/>
    <id>http://eugeneyang.com/2015/12/28/Minimum Window Substring - 最小子串窗口/</id>
    <published>2015-12-28T12:44:47.000Z</published>
    <updated>2015-12-28T12:22:00.533Z</updated>
    <content type="html"><![CDATA[<h3 id="Minimum_Window_Substring_-_最小子串窗口">Minimum Window Substring - 最小子串窗口</h3><p><strong>Description</strong>: Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p> For example,<br> S = “ADOBECODEBANC”<br> T = “ABC”<br> Minimum window is “BANC”.</p>
<p> Note:<br> If there is no such window in S that covers all characters in T, return the empty string “”.<br> If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.</p>
<p>思路：双指针，动态维护一个区间。尾指针不断往后扫，当扫到有一个窗口包含了所有T的字符后，然后再收缩头指针，直到不能再收缩为止。最后记录所有可能的情况中窗口最小的。</p>
<p>参考：<a href="http://blog.csdn.net/linhuanmars/article/details/20343903" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/20343903</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumWindowSubstring</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://blog.csdn.net/linhuanmars/article/details/20343903</span><br><span class="line">     * 双指针，动态维护一个区间。尾指针不断往后扫，当扫到有一个窗口包含了所有T的字符后，</span><br><span class="line">     * 然后再收缩头指针，直到不能再收缩为止。最后记录所有可能的情况中窗口最小的。</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@param</span> t</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; bookT = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//建立T字典</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bookT.containsKey(t.charAt(i))) &#123;</span><br><span class="line">                bookT.put(t.charAt(i), bookT.get(t.charAt(i))+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                bookT.put(t.charAt(i), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = s.length()+<span class="number">1</span>;  <span class="comment">//+1用来判断无匹配的极端情况</span></span><br><span class="line">        <span class="keyword">int</span> minStart = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//尾指针不断往后扫</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=<span class="number">0</span>; right&lt;s.length(); right++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bookT.containsKey(s.charAt(right))) &#123;</span><br><span class="line">                bookT.put(s.charAt(right), bookT.get(s.charAt(right))-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(bookT.get(s.charAt(right))&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当扫到有一个窗口包含了所有T的字符后，然后再收缩头指针，直到不能再收缩为止</span></span><br><span class="line">                <span class="keyword">while</span>(count == t.length()) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(right-left+<span class="number">1</span> &lt; minLen) &#123; <span class="comment">//更新</span></span><br><span class="line">                        minLen = right-left+<span class="number">1</span>;</span><br><span class="line">                        minStart = left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(bookT.containsKey(s.charAt(left))) &#123;     <span class="comment">//left收缩</span></span><br><span class="line">                        bookT.put(s.charAt(left), bookT.get(s.charAt(left))+<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span>(bookT.get(s.charAt(left))&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                            count--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minLen&gt;s.length()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//最后记录所有可能的情况中窗口最小的</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(minStart, minStart+minLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Minimum_Window_Substring_-_最小子串窗口">Minimum Window Substring - 最小子串窗口</h3><p><strong>Description</strong>: Given a string S and a str]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sort Colors - 颜色排序]]></title>
    <link href="http://eugeneyang.com/2015/12/27/Sort%20Colors%20-%20%E9%A2%9C%E8%89%B2%E6%8E%92%E5%BA%8F/"/>
    <id>http://eugeneyang.com/2015/12/27/Sort Colors - 颜色排序/</id>
    <published>2015-12-27T12:44:47.000Z</published>
    <updated>2015-12-27T08:50:29.033Z</updated>
    <content type="html"><![CDATA[<h3 id="Sort_Colors_-_颜色排序">Sort Colors - 颜色排序</h3><p><strong>Description</strong>: Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p> Could you come up with an one-pass algorithm using only constant space?</p>
<p>思路：先计算每种颜色数，然后在原数组基础上填充值。</p>
<p>参考：<a href="http://www.programcreek.com/2014/06/leetcode-sort-colors-java/" target="_blank" rel="external">http://www.programcreek.com/2014/06/leetcode-sort-colors-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortColors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2014/06/leetcode-sort-colors-java/</span><br><span class="line">     * Since we already get the count of each element, we can directly project them to</span><br><span class="line">     * the original array, instead of creating a new one.</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++) counts[nums[i]]++;</span><br><span class="line">        <span class="keyword">int</span> color = <span class="number">0</span>;  <span class="comment">//0:red 1:white 2:blue</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(color&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(counts[color]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[k++]=color;</span><br><span class="line">                counts[color] = counts[color]-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                color++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Sort_Colors_-_颜色排序">Sort Colors - 颜色排序</h3><p><strong>Description</strong>: Given an array with n objects colored red, white or blue]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Search 2D Matrix - 搜索2D矩阵]]></title>
    <link href="http://eugeneyang.com/2015/12/26/Search%202D%20Matrix%20-%20%E6%90%9C%E7%B4%A22D%E7%9F%A9%E9%98%B5/"/>
    <id>http://eugeneyang.com/2015/12/26/Search 2D Matrix - 搜索2D矩阵/</id>
    <published>2015-12-26T12:44:47.000Z</published>
    <updated>2015-12-26T05:21:55.955Z</updated>
    <content type="html"><![CDATA[<h3 id="Search_2D_Matrix_-_搜索2D矩阵">Search 2D Matrix - 搜索2D矩阵</h3><p><strong>Description</strong>: Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.<ul>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
</li>
</ul>
<p>思路：二分搜索（外层、内层）。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Search2DMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123;<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>&#125;</span><br><span class="line">                        &#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Search2DMatrix().searchMatrix(matrix, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两层均使用二分搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[row-<span class="number">1</span>][col-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = row-<span class="number">1</span>, m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; matrix[m][<span class="number">0</span>]) r = m-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[m][<span class="number">0</span>]) l = m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target == matrix[r][col-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[r][col-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> res = binarySearch(matrix[r], target);</span><br><span class="line">                <span class="keyword">return</span> res != -<span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[m]) r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt; target) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> m;  <span class="comment">//target == nums[m]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Search_2D_Matrix_-_搜索2D矩阵">Search 2D Matrix - 搜索2D矩阵</h3><p><strong>Description</strong>: Write an efficient algorithm that searches]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Set Matrix Zeroes - 矩阵置零]]></title>
    <link href="http://eugeneyang.com/2015/12/25/Set%20Matrix%20Zeroes%20-%20%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
    <id>http://eugeneyang.com/2015/12/25/Set Matrix Zeroes - 矩阵置零/</id>
    <published>2015-12-25T12:44:47.000Z</published>
    <updated>2015-12-25T12:53:25.258Z</updated>
    <content type="html"><![CDATA[<h3 id="Set_Matrix_Zeroes_-_矩阵置零">Set Matrix Zeroes - 矩阵置零</h3><p><strong>Description</strong>: Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p>
<p>Could you devise a constant space solution?</p>
<p>O(1)解法：用第0行和第0列来记录第1~m-1行和第1~n-1列是否需要置0。而用两个变量记录第0行和第0列是否需要置0。</p>
<p>注意：直接用0来标记需要置零，不要使用其他标记，这样第0行、第0列可以不用额外处理。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetMatrixZeroes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[][] matrix = &#123; &#123;0,0,0,5&#125;,</span></span><br><span class="line"><span class="comment">//                            &#123;4,3,1,4&#125;,</span></span><br><span class="line"><span class="comment">//                            &#123;0,1,1,4&#125;,</span></span><br><span class="line"><span class="comment">//                            &#123;1,2,1,3&#125;,</span></span><br><span class="line"><span class="comment">//                            &#123;0,0,1,1&#125;&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        <span class="keyword">new</span> SetMatrixZeroes().setZeroes(matrix);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : row) System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * O(1)解法：用第0行和第0列来记录第1~m-1行和第1~n-1列是否需要置0。</span><br><span class="line">     * 而用两个变量记录第0行和第0列是否需要置0。</span><br><span class="line">     * TODO 注意：直接用0来标记需要置零，不要使用其他标记，这样第0行、第0列可以不用额外处理。</span><br><span class="line">     * <span class="doctag">@param</span> matrix</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> zeroRow = <span class="number">1</span>, zeroCol = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="comment">//set first row and column zero or not</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroCol = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroRow = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//mark zeros on first row and column</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//set each elements by using marks in first row and column.</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++) matrix[i][k] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;m; k++) matrix[k][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//Set first column and row by using marks in first step.</span></span><br><span class="line">        <span class="keyword">if</span> (zeroRow == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (zeroCol == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;m; i++) matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Set_Matrix_Zeroes_-_矩阵置零">Set Matrix Zeroes - 矩阵置零</h3><p><strong>Description</strong>: Given a m x n matrix, if an element is 0, se]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Edit Distance - 最短编辑距离]]></title>
    <link href="http://eugeneyang.com/2015/12/24/Edit%20Distance%20-%20%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://eugeneyang.com/2015/12/24/Edit Distance - 最短编辑距离/</id>
    <published>2015-12-24T12:44:47.000Z</published>
    <updated>2015-12-24T08:00:39.169Z</updated>
    <content type="html"><![CDATA[<h3 id="Edit_Distance_-_最短编辑距离">Edit Distance - 最短编辑距离</h3><p><strong>Description</strong>: Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)<br> You have the following 3 operations permitted on a word:<br> a) Insert a character<br> b) Delete a character<br> c) Replace a character</p>
<p> 思路：使用动态规划。D[i,j]表示s1的前i个字符和 s2的前j个字符的最短编辑距离，<br>s1[i]!=s2[j]时，D[i,j]=min(D[i-1,j]+1,D[i,j-1]+1,D[i-1,j-1]+1);<br>s1[i]==s2[j]时，D[i,j]=D[i-1,j-1];</p>
<p> 参考：<a href="http://blog.unieagle.net/2012/09/19/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Aedit-distance%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" target="_blank" rel="external">http://blog.unieagle.net/2012/09/19/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Aedit-distance%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</a></p>
<p>注意此题中置换也是一种基本操作，置换操作明显比 “删除+增加” 操作更短；<br>如果置换不是基本操作，则是另一种算法（可以参考：<a href="http://blog.csdn.net/abcjennifer/article/details/7735272" target="_blank" rel="external">http://blog.csdn.net/abcjennifer/article/details/7735272</a> ）。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditDistance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> EditDistance().minDistance(<span class="string">"eat"</span>, <span class="string">"sea"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 参考：http://blog.unieagle.net/2012/09/19/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Aedit-distance%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</span><br><span class="line">     * D[i,j]: s1的前i个字符和 s2的前j个字符的最短编辑距离</span><br><span class="line">     * 注意置换也是一种基本操作，置换明显比 删除+增加 操作更短；</span><br><span class="line">     * 如果置换不是基本操作，则是另一种算法（参考：http://blog.csdn.net/abcjennifer/article/details/7735272）。</span><br><span class="line">     * s1[i]!=s2[j]时，D[i,j]=min(D[i-1,j]+1,D[i,j-1]+1,D[i-1,j-1]+1);</span><br><span class="line">     * s1[i]==s2[j]时，D[i,j]=D[i-1,j-1];</span><br><span class="line">     * <span class="doctag">@param</span> word1</span><br><span class="line">     * <span class="doctag">@param</span> word2</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1.equals(word2)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] D = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=m; i++)</span><br><span class="line">            D[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;=n; j++)</span><br><span class="line">            D[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                    D[i][j] = D[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> replace = D[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> insert = D[i][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> delete = D[i-<span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> temp = Math.min(replace, insert);</span><br><span class="line">                    D[i][j] = Math.min(temp, delete);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> D[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Edit_Distance_-_最短编辑距离">Edit Distance - 最短编辑距离</h3><p><strong>Description</strong>: Given two words word1 and word2, find the minimu]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Simplify Path - 路径简化]]></title>
    <link href="http://eugeneyang.com/2015/12/23/Simplify%20Path%20-%20%E8%B7%AF%E5%BE%84%E7%AE%80%E5%8C%96/"/>
    <id>http://eugeneyang.com/2015/12/23/Simplify Path - 路径简化/</id>
    <published>2015-12-23T12:44:47.000Z</published>
    <updated>2015-12-23T12:37:10.741Z</updated>
    <content type="html"><![CDATA[<h3 id="Simplify_Path_-_路径简化">Simplify Path - 路径简化</h3><p><strong>Description</strong>: Given an absolute path for a file (Unix-style), simplify it.</p>
<p> For example,<br> path = “/home/“, =&gt; “/home”<br> path = “/a/./b/../../c/“, =&gt; “/c”</p>
<p> 思路：先将输入用/分隔开得到字符数组，然后再分情况判断。算法过程使用到栈数据结构。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplifyPath</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        String path = "/a/./b/../../c/";</span></span><br><span class="line"><span class="comment">//        String path = "/home/";</span></span><br><span class="line">        String path = <span class="string">"/home//foo/"</span>;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> SimplifyPath().simplifyPath(path));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        String[] strings = path.split(<span class="string">"/"</span>);</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;strings.length; i++)&#123;</span><br><span class="line">            String s = strings[i];</span><br><span class="line">            <span class="keyword">if</span> (s.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s.equals(<span class="string">"."</span>))&#123;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">".."</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!stack.isEmpty()) stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.push(strings[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            Object[] array = stack.toArray();</span><br><span class="line">            <span class="keyword">for</span> (Object o : array) builder.append(<span class="string">"/"</span> + o);</span><br><span class="line">            <span class="keyword">return</span> builder.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Simplify_Path_-_路径简化">Simplify Path - 路径简化</h3><p><strong>Description</strong>: Given an absolute path for a file (Unix-style), simp]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sqrt(x) - 求平方根]]></title>
    <link href="http://eugeneyang.com/2015/12/21/Sqrt(x)%20-%20%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <id>http://eugeneyang.com/2015/12/21/Sqrt(x) - 求平方根/</id>
    <published>2015-12-21T12:44:47.000Z</published>
    <updated>2015-12-21T04:53:20.713Z</updated>
    <content type="html"><![CDATA[<h3 id="Sqrt(x)_-_求平方根">Sqrt(x) - 求平方根</h3><p><strong>Description</strong>: Implement int sqrt(int x).<br> Compute and return the square root of x.</p>
<p>二分搜索：对于一个非负数n，它的平方根不会大于（n/2+1）。<br>在[0, n/2+1]这个范围内可以进行二分搜索，求出n的平方根。</p>
<p>参考：<a href="http://www.cnblogs.com/AnnieKim/archive/2013/04/18/3028607.html" target="_blank" rel="external">http://www.cnblogs.com/AnnieKim/archive/2013/04/18/3028607.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sqrtx</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Sqrtx().mySqrt(<span class="number">64</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 二分搜索：对于一个非负数n，它的平方根不会大于（n/2+1）。</span><br><span class="line">     * 在[0, n/2+1]这个范围内可以进行二分搜索，求出n的平方根。</span><br><span class="line">     * http://www.cnblogs.com/AnnieKim/archive/2013/04/18/3028607.html</span><br><span class="line">     * <span class="doctag">@param</span> x</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> r = x/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> square = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            square = mid*mid;</span><br><span class="line">            <span class="keyword">if</span> (square == x) <span class="keyword">return</span> (<span class="keyword">int</span>) mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (square &lt; x) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Sqrt(x)_-_求平方根">Sqrt(x) - 求平方根</h3><p><strong>Description</strong>: Implement int sqrt(int x).<br> Compute and return the square roo]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Text Justification - 文本对齐]]></title>
    <link href="http://eugeneyang.com/2015/12/20/Text%20Justification%20-%20%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90/"/>
    <id>http://eugeneyang.com/2015/12/20/Text Justification - 文本对齐/</id>
    <published>2015-12-20T12:44:47.000Z</published>
    <updated>2015-12-20T11:39:20.124Z</updated>
    <content type="html"><![CDATA[<h3 id="Text_Justification_-_文本对齐">Text Justification - 文本对齐</h3><p><strong>Description</strong>: Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.</p>
<p> You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters.</p>
<p> Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
<p> For the last line of text, it should be left justified and no extra space is inserted<br> between words.</p>
<p> 注意两个点：<br> a、当该行只放一个单词时，空格全部在右边<br> b、最后一行中单词间只有一个空格，其余空格全部在右边。然后只要贪心选择，在一行中尽量放多的单词。</p>
<p>一些坑：每行中，有下一个单词，才需要补一个空格。算法中，跳到新一行首个单词，才将上一行写入结果（而不是在上一行末单词判断写入）。</p>
<p>此题非常容易出错，正确率很低。<br>参考：<a href="http://blog.csdn.net/linhuanmars/article/details/24063271" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/24063271</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextJustification</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] words = &#123;<span class="string">"This"</span>, <span class="string">"is"</span>, <span class="string">"an"</span>, <span class="string">"example"</span>, <span class="string">"of"</span>, <span class="string">"text"</span>, <span class="string">"justification."</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxWidth = <span class="number">16</span>;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> TextJustification().fullJustify(words, maxWidth));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**TODO 边界极易出错 HARD</span><br><span class="line">     * 每行中，有下一个单词，才需要补一个空格。</span><br><span class="line">     * 算法中，跳到新一行首个单词，才将上一行写入结果（而不是在上一行末单词判断写入）。</span><br><span class="line">     * http://blog.csdn.net/linhuanmars/article/details/24063271</span><br><span class="line">     * <span class="doctag">@param</span> words</span><br><span class="line">     * <span class="doctag">@param</span> maxWidth</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fullJustify</span><span class="params">(String[] words, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(words==<span class="keyword">null</span> || words.length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lastHead = <span class="number">0</span>;   <span class="comment">//上一行第一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> wordCount = i-lastHead; <span class="comment">//wordCount不含当前第i个</span></span><br><span class="line">            <span class="keyword">if</span>(count + words[i].length() + wordCount &gt; maxWidth) &#123;  <span class="comment">//此时i是新一行的首个单词</span></span><br><span class="line">                <span class="keyword">int</span> avgSpaceNum = <span class="number">0</span>;   <span class="comment">//上一行平均空格数</span></span><br><span class="line">                <span class="keyword">int</span> extraSpaceNum = <span class="number">0</span>;   <span class="comment">//上一行额外空格数</span></span><br><span class="line">                <span class="keyword">if</span>(wordCount-<span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    avgSpaceNum = (maxWidth-count)/(wordCount-<span class="number">1</span>);</span><br><span class="line">                    extraSpaceNum = (maxWidth-count)%(wordCount-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=lastHead; j&lt;i; j++) &#123;</span><br><span class="line">                    str.append(words[j]);</span><br><span class="line">                    <span class="keyword">if</span>(j &lt; i-<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;avgSpaceNum; k++) str.append(<span class="string">" "</span>);   <span class="comment">//补平均空格</span></span><br><span class="line">                        <span class="keyword">if</span>(extraSpaceNum&gt;<span class="number">0</span>) str.append(<span class="string">" "</span>);    <span class="comment">//补额外空格</span></span><br><span class="line">                        extraSpaceNum--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=str.length(); j&lt;maxWidth; j++) str.append(<span class="string">" "</span>);   <span class="comment">//一个单词时，补末尾</span></span><br><span class="line">                res.add(str.toString());</span><br><span class="line">                count=<span class="number">0</span>;    <span class="comment">//新一行</span></span><br><span class="line">                lastHead=i; <span class="comment">//新一行</span></span><br><span class="line">            &#125;</span><br><span class="line">            count += words[i].length();</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lastHead; i&lt;words.length; i++) &#123;  <span class="comment">//最后一行</span></span><br><span class="line">            str.append(words[i]);</span><br><span class="line">            <span class="keyword">if</span>(str.length() &lt; maxWidth) str.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=str.length(); i&lt;maxWidth; i++) str.append(<span class="string">" "</span>);</span><br><span class="line">        res.add(str.toString());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Text_Justification_-_文本对齐">Text Justification - 文本对齐</h3><p><strong>Description</strong>: Given an array of words and a length L, fo]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Add Binary - 二进制数加法]]></title>
    <link href="http://eugeneyang.com/2015/12/19/Add%20Binary%20-%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%8A%A0%E6%B3%95/"/>
    <id>http://eugeneyang.com/2015/12/19/Add Binary - 二进制数加法/</id>
    <published>2015-12-19T12:44:47.000Z</published>
    <updated>2015-12-19T09:47:59.567Z</updated>
    <content type="html"><![CDATA[<h3 id="Add_Binary_-_二进制数加法">Add Binary - 二进制数加法</h3><p><strong>Description</strong>: Given two binary strings, return their sum (also a binary string).</p>
<p> For example,<br> a = “11”<br> b = “1”<br> Return “100”.</p>
<p>注意：java中涉及字符串与字符操作比较慢，且字符与整型数转换麻烦容易出错（字符本身也可以作为整数）。</p>
<p>完整的java代码如下（写得比较繁琐，但是速度超过94.27%提交结果）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddBinary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> AddBinary().addBinary(<span class="string">"11"</span>, <span class="string">"1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO int与char转换过程易出错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aLen = a.length(), bLen = b.length();</span><br><span class="line">        <span class="keyword">int</span> len = aLen &gt; bLen ? aLen : bLen;</span><br><span class="line">        <span class="keyword">char</span>[] aChars, bChars;</span><br><span class="line">        <span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (len == aLen)&#123;</span><br><span class="line">            aChars = a.toCharArray();</span><br><span class="line">            bChars = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">            <span class="keyword">int</span> diff = len-bLen;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i&lt;diff) bChars[i] = <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">else</span> bChars[i] = b.charAt(i-diff);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            aChars = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">            <span class="keyword">int</span> diff = len-aLen;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i&lt;diff) aChars[i] = <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">else</span> aChars[i] = a.charAt(i-diff);</span><br><span class="line">            &#125;</span><br><span class="line">            bChars = b.toCharArray();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>, extra = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            temp = getInt(aChars[i]) + getInt(bChars[i]) + extra;</span><br><span class="line">            res[i+<span class="number">1</span>] = getChar(temp%<span class="number">2</span>); <span class="comment">//TODO i+1易出错</span></span><br><span class="line">            extra = temp/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp&gt;<span class="number">1</span> &amp;&amp; i-<span class="number">1</span> == -<span class="number">1</span>) &#123; <span class="comment">//超出长度</span></span><br><span class="line">                res[<span class="number">0</span>] = <span class="string">'1'</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(Arrays.copyOfRange(res, <span class="number">1</span>, len+<span class="number">1</span>));   <span class="comment">//TODO i+1易出错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Add_Binary_-_二进制数加法">Add Binary - 二进制数加法</h3><p><strong>Description</strong>: Given two binary strings, return their sum (also a bin]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

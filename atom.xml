<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Eugene's Blog]]></title>
  <subtitle><![CDATA[成长之旅]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://eugeneyang.com/"/>
  <updated>2016-02-25T03:58:13.348Z</updated>
  <id>http://eugeneyang.com/</id>
  
  <author>
    <name><![CDATA[Jian Yang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Longest Valid Parentheses - 最长匹配括号序列]]></title>
    <link href="http://eugeneyang.com/2016/02/24/Longest%20Valid%20Parentheses%20-%20%E6%9C%80%E9%95%BF%E5%8C%B9%E9%85%8D%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"/>
    <id>http://eugeneyang.com/2016/02/24/Longest Valid Parentheses - 最长匹配括号序列/</id>
    <published>2016-02-24T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.348Z</updated>
    <content type="html"><![CDATA[<h3 id="Longest_Valid_Parentheses_-_最长匹配括号序列">Longest Valid Parentheses - 最长匹配括号序列</h3><p><strong>Description</strong>: Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p> For “(()”, the longest valid parentheses substring is “()”, which has length = 2.<br> Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p>
<p>思路：DP可解,但是大数据超时.<br>用栈来存左括号的index，遍历s，遇到’(‘就放入lefts栈。<br>如果遇到’)’，如果lefts是空，说明这是一个无法匹配的’)’，记录下last。<br>last里面存放的其实是最后一个无法匹配的’)’,主要是为了计算后面完整的表达式的长度。可以这样理解：所有无法匹配的’)’的index其实都是各个group的分界点。</p>
<p>参考链接：<br><a href="http://www.cnblogs.com/lichen782/p/leetcode_Longest_Valid_Parentheses.html" target="_blank" rel="external">http://www.cnblogs.com/lichen782/p/leetcode_Longest_Valid_Parentheses.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestValidParentheses</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">new</span> LongestValidParentheses()</span><br><span class="line">                .longestValidParentheses(<span class="string">")))))(((()("</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*****RESULT*****"</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**TODO 重温理解及记忆,尤其是代码最后一个else部分</span><br><span class="line">     * http://www.cnblogs.com/lichen782/p/leetcode_Longest_Valid_Parentheses.html</span><br><span class="line">     * DP可解,但是大数据超时.</span><br><span class="line">     * 用栈来存左括号的index，遍历s，遇到'('就放入lefts栈。</span><br><span class="line">     如果遇到')'，如果lefts是空，说明这是一个无法匹配的')'，记录下last。</span><br><span class="line">     last里面存放的其实是最后一个无法匹配的')',主要是为了计算后面完整的表达式的长度。</span><br><span class="line">     可以这样理解：所有无法匹配的')'的index其实都是各个group的分界点。</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, last = -<span class="number">1</span>;</span><br><span class="line">        Stack&lt;Integer&gt; lefts = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==<span class="string">'('</span>) &#123;</span><br><span class="line">                lefts.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lefts.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// no matching left</span></span><br><span class="line">                    last = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// find a matching pair</span></span><br><span class="line">                    lefts.pop();</span><br><span class="line">                    <span class="keyword">if</span> (lefts.isEmpty()) &#123;<span class="comment">//有一个完整的valid的group。计算该group的长度</span></span><br><span class="line">                        maxLen = Math.max(maxLen, i - last);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//栈内还有‘(',一个最外层完整的group还没有匹配完成，</span></span><br><span class="line">                        <span class="comment">//但是通过查询下一个即将匹配还未匹配的"("的index来更新maxLen。</span></span><br><span class="line">                        <span class="keyword">int</span> k = lefts.peek();</span><br><span class="line">                        maxLen = Math.max(maxLen, i - k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Longest_Valid_Parentheses_-_最长匹配括号序列">Longest Valid Parentheses - 最长匹配括号序列</h3><p><strong>Description</strong>: Given a string conta]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Single Number - 寻找单一整数]]></title>
    <link href="http://eugeneyang.com/2016/02/24/Single%20Number%20-%20%E5%AF%BB%E6%89%BE%E5%8D%95%E4%B8%80%E6%95%B4%E6%95%B0/"/>
    <id>http://eugeneyang.com/2016/02/24/Single Number - 寻找单一整数/</id>
    <published>2016-02-24T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.351Z</updated>
    <content type="html"><![CDATA[<h3 id="Single_Number_-_寻找单一整数">Single Number - 寻找单一整数</h3><p><strong>Description</strong>: Given an array of integers, every element appears twice except for one. Find that single one.<br> Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>思路：<br>1 异或(此法不消耗额外空间),只有两不同位异或才会返回1,所有相同整数异或结果为整数0.<br>2 集合<br>3 哈希表</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异或(此法不消耗额外空间),只有两不同位异或才会返回1,所有相同整数异或结果为整数0.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++) nums[<span class="number">0</span>] = nums[<span class="number">0</span>]^nums[i];</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(n)) set.remove(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)set.toArray()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(nums[i]))&#123;</span><br><span class="line">                map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums[i], map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(i)==<span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Single_Number_-_寻找单一整数">Single Number - 寻找单一整数</h3><p><strong>Description</strong>: Given an array of integers, every element appear]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Candy - 糖果游戏]]></title>
    <link href="http://eugeneyang.com/2016/02/23/Candy%20-%20%E7%B3%96%E6%9E%9C%E6%B8%B8%E6%88%8F/"/>
    <id>http://eugeneyang.com/2016/02/23/Candy - 糖果游戏/</id>
    <published>2016-02-23T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.345Z</updated>
    <content type="html"><![CDATA[<h3 id="Candy_-_糖果游戏">Candy - 糖果游戏</h3><p><strong>Description</strong>: There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements:<br> Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give?</p>
<p>思路：涉及相邻元素问题,类似Trapping Rain Water,总体思路也是从左从右双向遍历.<br>贪心:只要遇到更大的相邻值,则可以加一;但要总数最小,则需按升序来加一.<br>首先从左向右遍历,升序加一;再从右向左遍历,升序加一.</p>
<p>参考链接：<a href="http://www.programcreek.com/2014/03/leetcode-candy-java/" target="_blank" rel="external">http://www.programcreek.com/2014/03/leetcode-candy-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 涉及相邻元素问题,类似Trapping Rain Water,总体思路也是从左从右双向遍历.</span><br><span class="line">     * 贪心:只要遇到更大的相邻值,则可以加一;但要总数最小,则需按升序来加一.</span><br><span class="line">     首先从左向右遍历,升序加一;再从右向左遍历,升序加一.</span><br><span class="line">     http://www.programcreek.com/2014/03/leetcode-candy-java/</span><br><span class="line">     * <span class="doctag">@param</span> ratings</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] candies = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">        candies[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> total = candies[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;ratings.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i-<span class="number">1</span>]&lt;ratings[i])&#123;</span><br><span class="line">                candies[i] = candies[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                candies[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            total += candies[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=ratings.length-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i]&gt;ratings[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span> (! (candies[i]&gt;candies[i+<span class="number">1</span>])) &#123;</span><br><span class="line">                    <span class="keyword">int</span> old = candies[i];   <span class="comment">//TODO 易错(用例[5,3,1]),并非新增值都是1,应存储原值,用以计算新增值</span></span><br><span class="line">                    candies[i] = candies[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    total += candies[i]-old;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Candy_-_糖果游戏">Candy - 糖果游戏</h3><p><strong>Description</strong>: There are N children standing in a line. Each child is assigned a ra]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gas Station - 加油站问题]]></title>
    <link href="http://eugeneyang.com/2016/02/22/Gas%20Station%20-%20%E5%8A%A0%E6%B2%B9%E7%AB%99%E9%97%AE%E9%A2%98/"/>
    <id>http://eugeneyang.com/2016/02/22/Gas Station - 加油站问题/</id>
    <published>2016-02-22T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.319Z</updated>
    <content type="html"><![CDATA[<h3 id="Gas_Station_-_加油站问题">Gas Station - 加油站问题</h3><p><strong>Description</strong>: There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p>
<p> Note: The solution is guaranteed to be unique.</p>
<p>思路：贪心:关键是要可以总结出来这道题目的属性，注意Note这个地方，其属性主要有两个：<br>     1 如果总的gas - cost小于零的话，那么没有解返回-1;<br>     2 如果前面所有的gas - cost加起来小于零，那么前面所有的点都不能作为出发点。</p>
<p>参考链接：<a href="http://blog.csdn.net/kenden23/article/details/14106137" target="_blank" rel="external">http://blog.csdn.net/kenden23/article/details/14106137</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GasStation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 贪心:关键是要可以总结出来这道题目的属性，注意Note这个地方，其属性主要有两个：</span><br><span class="line">     1 如果总的gas - cost小于零的话，那么没有解返回-1;</span><br><span class="line">     2 如果前面所有的gas - cost加起来小于零，那么前面所有的点都不能作为出发点。</span><br><span class="line">     http://blog.csdn.net/kenden23/article/details/14106137</span><br><span class="line">     * <span class="doctag">@param</span> gas</span><br><span class="line">     * <span class="doctag">@param</span> cost</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> remaining = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curRemaining = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> totalRemaining = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;gas.length; i++)&#123;</span><br><span class="line">            remaining = gas[i]-cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curRemaining&gt;=<span class="number">0</span>) curRemaining += remaining;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                curRemaining = remaining;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">            totalRemaining += remaining;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalRemaining &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Gas_Station_-_加油站问题">Gas Station - 加油站问题</h3><p><strong>Description</strong>: There are N gas stations along a circular route, where]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Clone Graph - 复制无向图]]></title>
    <link href="http://eugeneyang.com/2016/02/21/Clone%20Graph%20-%20%E5%A4%8D%E5%88%B6%E6%97%A0%E5%90%91%E5%9B%BE/"/>
    <id>http://eugeneyang.com/2016/02/21/Clone Graph - 复制无向图/</id>
    <published>2016-02-21T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.316Z</updated>
    <content type="html"><![CDATA[<h3 id="Clone_Graph_-_复制无向图">Clone Graph - 复制无向图</h3><p><strong>Description</strong>: Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>原题参见：<a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="external">https://leetcode.com/problems/clone-graph/</a></p>
<p>思路：无向图深拷贝,BFS，用到一个队列和旧节点到新节点的映射。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneGraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraphNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> label;</span><br><span class="line">        List&lt;UndirectedGraphNode&gt; neighbors;</span><br><span class="line">        UndirectedGraphNode(<span class="keyword">int</span> x) &#123; label = x; neighbors = <span class="keyword">new</span> ArrayList&lt;UndirectedGraphNode&gt;(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 无向图深拷贝,BFS</span><br><span class="line">     * <span class="doctag">@param</span> node</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        UndirectedGraphNode newHead = <span class="keyword">new</span> UndirectedGraphNode(node.label);</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        map.put(node, newHead);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            UndirectedGraphNode curr = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(UndirectedGraphNode aNeighbor: curr.neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(aNeighbor))&#123;</span><br><span class="line">                    UndirectedGraphNode copy = <span class="keyword">new</span> UndirectedGraphNode(aNeighbor.label);</span><br><span class="line">                    map.put(aNeighbor, copy);</span><br><span class="line">                    map.get(curr).neighbors.add(copy);</span><br><span class="line">                    queue.add(aNeighbor);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.get(curr).neighbors.add(map.get(aNeighbor));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无向图深拷贝,BFS,比上面的方法慢</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph1</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Queue&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;UndirectedGraphNode&gt; originQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        originQueue.offer(node);</span><br><span class="line">        map.put(node.label, <span class="keyword">new</span> UndirectedGraphNode(node.label));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            UndirectedGraphNode theNode = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraphNode n : theNode.neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(n.label))&#123;</span><br><span class="line">                    map.put(n.label, <span class="keyword">new</span> UndirectedGraphNode(n.label));</span><br><span class="line">                    queue.offer(n);</span><br><span class="line">                    originQueue.offer(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!originQueue.isEmpty()) &#123;</span><br><span class="line">            UndirectedGraphNode theNode = originQueue.poll();</span><br><span class="line">            UndirectedGraphNode newNode = map.get(theNode.label);</span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraphNode n : theNode.neighbors)&#123;</span><br><span class="line">                newNode.neighbors.add(map.get(n.label));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(node.label);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Clone_Graph_-_复制无向图">Clone Graph - 复制无向图</h3><p><strong>Description</strong>: Clone an undirected graph. Each node in the graph cont]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Palindrome Partitioning II - 回文划分II]]></title>
    <link href="http://eugeneyang.com/2016/02/20/Palindrome%20Partitioning%20II%20-%20%E5%9B%9E%E6%96%87%E5%88%92%E5%88%86II/"/>
    <id>http://eugeneyang.com/2016/02/20/Palindrome Partitioning II - 回文划分II/</id>
    <published>2016-02-20T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.313Z</updated>
    <content type="html"><![CDATA[<h3 id="Palindrome_Partitioning_II_-_回文划分II">Palindrome Partitioning II - 回文划分II</h3><p><strong>Description</strong>: Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br> Return 1 since the palindrome partitioning [“aa”,”b”] could be produced using 1 cut. </p>
<p>思路：DP(双重二维),也可以用回溯法(参考Palindrome Partitioning).</p>
<p>定义cutNum(i)为[0,i]间最小切割数,n为字符串长度,0&lt;i&lt;=n,<br>有cutNum(0,i)=min[curNum(0,j-1)+curNum(j,i)],<br>存在一个回文的情况下,简化为<br>cutNum(i)=min[cutNum(j-1)+1],0&lt;j=&lt;i;cutNum(i)=0,j=0.<br>     核心思想在于”j从0到i的过程中每找到一个回文,若要切割则在前次切割的基础上加1次”.</p>
<p>判断[j,i]间是否为回文也是DP问题,定义palindrome(j,i)为[j,i]间是否为回文,<br>     有palindrome(j,i)= str(j)==str(i) &amp;&amp; (i-j&lt;=1 || palindrome(j+1, i-1)).<br>     i-j&lt;=1因为一个字符一定也是回文(这个条件使得边界情况初始化可以省略).</p>
<p>参考：<a href="http://www.programcreek.com/2014/04/leetcode-palindrome-partitioning-ii-java/" target="_blank" rel="external">http://www.programcreek.com/2014/04/leetcode-palindrome-partitioning-ii-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromePartitioningII</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**http://www.programcreek.com/2014/04/leetcode-palindrome-partitioning-ii-java/</span><br><span class="line">     * DP(双重二维),也可以用回溯法(参考Palindrome Partitioning).</span><br><span class="line">     * 定义cutNum(i)为[0,i]间最小切割数,n为字符串长度,0&lt;i&lt;=n,</span><br><span class="line">     有cutNum(0,i)=min[curNum(0,j-1)+curNum(j,i)],</span><br><span class="line">     存在一个回文的情况下,简化为cutNum(i)=min[cutNum(j-1)+1],0&lt;j=&lt;i;cutNum(i)=0,j=0.</span><br><span class="line">     核心思想在于"j从0到i的过程中每找到一个回文,若要切割则在前次切割的基础上加1次".</span><br><span class="line">     * 判断[j,i]间是否为回文也是DP问题,定义palindrome(j,i)为[j,i]间是否为回文,</span><br><span class="line">     有palindrome(j,i)= str(j)==str(i) &amp;&amp; (i-j&lt;=1 || palindrome(j+1, i-1)).</span><br><span class="line">     i-j&lt;=1因为一个字符一定也是回文(这个条件使得边界情况初始化可以省略).</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] palindrome = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">int</span>[] cutNum = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            cutNum[i] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(j)==s.charAt(i) &amp;&amp; (i-j&lt;=<span class="number">1</span> || palindrome[j+<span class="number">1</span>][i-<span class="number">1</span>]))&#123;</span><br><span class="line">                    palindrome[j][i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j==<span class="number">0</span>) cutNum[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> cutNum[i] = Math.min(cutNum[i], cutNum[j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cutNum[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Palindrome_Partitioning_II_-_回文划分II">Palindrome Partitioning II - 回文划分II</h3><p><strong>Description</strong>: Given a string s, part]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Palindrome Partitioning - 回文划分]]></title>
    <link href="http://eugeneyang.com/2016/02/19/Palindrome%20Partitioning%20-%20%E5%9B%9E%E6%96%87%E5%88%92%E5%88%86/"/>
    <id>http://eugeneyang.com/2016/02/19/Palindrome Partitioning - 回文划分/</id>
    <published>2016-02-19T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.311Z</updated>
    <content type="html"><![CDATA[<h3 id="Palindrome_Partitioning_-_回文划分">Palindrome Partitioning - 回文划分</h3><p><strong>Description</strong>: Given a string s, partition s such that every substring of the partition is a palindrome.<br> Return all possible palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br> Return [ [“aa”,”b”], [“a”,”a”,”b”] ]</p>
<p>思路：回溯法(DFS),当然DP也可以(可参考Palindrome Partitioning II).</p>
<p>参考：<a href="http://www.programcreek.com/2013/03/leetcode-palindrome-partitioning-java/" target="_blank" rel="external">http://www.programcreek.com/2013/03/leetcode-palindrome-partitioning-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromePartitioning</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> PalindromePartitioning().partition(<span class="string">"amanaplanacanalpanama"</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; list : result)&#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : list)&#123;</span><br><span class="line">                System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2013/03/leetcode-palindrome-partitioning-java/</span><br><span class="line">     * 回溯法(DFS),当然DP也可以(可参考Palindrome Partitioning II).</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        List&lt;String&gt; partitionList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        partitionHepler(s, <span class="number">0</span>, partitionList, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">partitionHepler</span><span class="params">(String s, <span class="keyword">int</span> start, List&lt;String&gt; partitionList, List&lt;List&lt;String&gt;&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start==s.length())&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(partitionList));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=start+<span class="number">1</span>; i&lt;=s.length(); i++)&#123;</span><br><span class="line">            String str = s.substring(start, i);</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(str))&#123;</span><br><span class="line">                partitionList.add(str);</span><br><span class="line">                partitionHepler(s, i, partitionList, result);</span><br><span class="line">                partitionList.remove(partitionList.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=str.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(l++)!=str.charAt(r--)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Palindrome_Partitioning_-_回文划分">Palindrome Partitioning - 回文划分</h3><p><strong>Description</strong>: Given a string s, partition s su]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Surrounded Regions - 环绕区域]]></title>
    <link href="http://eugeneyang.com/2016/02/18/Surrounded%20Regions%20-%20%E7%8E%AF%E7%BB%95%E5%8C%BA%E5%9F%9F/"/>
    <id>http://eugeneyang.com/2016/02/18/Surrounded Regions - 环绕区域/</id>
    <published>2016-02-18T12:44:47.000Z</published>
    <updated>2016-02-25T03:58:13.308Z</updated>
    <content type="html"><![CDATA[<h3 id="Surrounded_Regions_-_环绕区域">Surrounded Regions - 环绕区域</h3><p><strong>Description</strong>: Given a 2D board containing ‘X’ and ‘O’, capture all regions surrounded by ‘X’. A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<p>For example,<br> X X X X<br> X O O X<br> X X O X<br> X O X X<br> After running your function, the board should be:<br> X X X X<br> X X X X<br> X X X X<br> X O X X</p>
<p>思路：边界处的O不能被包围,可以先遍历一次将与边界相连的所有O找出并替换成#,再遍历一次将O换成X,#换回O. 注意如果采用DFS可能会产生栈溢出,因此用BFS.</p>
<p>参考：<a href="http://www.programcreek.com/2014/04/leetcode-surrounded-regions-java/" target="_blank" rel="external">http://www.programcreek.com/2014/04/leetcode-surrounded-regions-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SurroundedRegions</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2014/04/leetcode-surrounded-regions-java/</span><br><span class="line">     * 边界处的O不能被包围,可以先遍历一次将与边界相连的所有O找出并替换成#,再遍历一次将O换成X,#换回O.</span><br><span class="line">     如果采用DFS可能会产生栈溢出,因此用BFS.</span><br><span class="line">     * <span class="doctag">@param</span> board</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// merge O's on left &amp; right boarder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">'O'</span>) bfs(board, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">'O'</span>) bfs(board, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// merge O's on top &amp; bottom boarder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">'O'</span>) bfs(board, <span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">'O'</span>) bfs(board, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// process the board</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'#'</span>)  board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// fill current first and then its neighbors</span></span><br><span class="line">        fillCell(board, i, j);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = cur / n;</span><br><span class="line">            <span class="keyword">int</span> y = cur % n;</span><br><span class="line">            fillCell(board, x - <span class="number">1</span>, y);</span><br><span class="line">            fillCell(board, x + <span class="number">1</span>, y);</span><br><span class="line">            fillCell(board, x, y - <span class="number">1</span>);</span><br><span class="line">            fillCell(board, x, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillCell</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || board[i][j] != <span class="string">'O'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// add current cell is queue &amp; then process its neighbors in bfs</span></span><br><span class="line">        queue.offer(i * n + j);</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Surrounded_Regions_-_环绕区域">Surrounded Regions - 环绕区域</h3><p><strong>Description</strong>: Given a 2D board containing ‘X’ and ‘O’, c]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sum Root to Leaf Numbers - 二叉树所有路径之和]]></title>
    <link href="http://eugeneyang.com/2016/02/17/Sum%20Root%20to%20Leaf%20Numbers%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C/"/>
    <id>http://eugeneyang.com/2016/02/17/Sum Root to Leaf Numbers - 二叉树所有路径之和/</id>
    <published>2016-02-17T12:44:47.000Z</published>
    <updated>2016-02-17T16:08:21.457Z</updated>
    <content type="html"><![CDATA[<h3 id="Sum_Root_to_Leaf_Numbers_-_二叉树所有路径之和">Sum Root to Leaf Numbers - 二叉树所有路径之和</h3><p><strong>Description</strong>: Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. Find the total sum of all root-to-leaf numbers.</p>
<p> For example,<br>   1<br>  / \<br> 2   3<br> The root-to-leaf path 1-&gt;2 represents the number 12.<br> The root-to-leaf path 1-&gt;3 represents the number 13.<br> Return the sum = 12 + 13 = 25.</p>
<p>思路：典型的root-&gt;leaf路径问题，遍历所有path并更新sum。传递的变量是当前节点的路径和curSum,则下一层的节点对应的路径和为curSum*10 + node.val。注意当根到叶的路径很长时,curSum容易溢出.</p>
<p>参考：<a href="http://www.programcreek.com/2014/05/leetcode-sum-root-to-leaf-numbers-java/" target="_blank" rel="external">http://www.programcreek.com/2014/05/leetcode-sum-root-to-leaf-numbers-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumRootToLeafNumbers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2014/05/leetcode-sum-root-to-leaf-numbers-java/</span><br><span class="line">     * 典型的root-&gt;leaf路径问题，遍历所有path并更新sum。</span><br><span class="line">     传递的变量是当前节点的路径和curSum,则下一层的节点对应的路径和为curSum*10 + node.val。</span><br><span class="line">     注意当根到叶的路径很长时,curSum容易溢出.</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> getSum(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(TreeNode node, <span class="keyword">int</span> curSum, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>) <span class="keyword">return</span> sum; <span class="comment">//TODO return 0;也可以,sum只有在叶子节点才触发计算</span></span><br><span class="line">        curSum = curSum*<span class="number">10</span> + node.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left==<span class="keyword">null</span> &amp;&amp; node.right==<span class="keyword">null</span>)&#123;   <span class="comment">//叶子节点</span></span><br><span class="line">            <span class="keyword">return</span> sum + curSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右子树</span></span><br><span class="line">        <span class="keyword">return</span> getSum(node.left, curSum, sum) + getSum(node.right, curSum, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http://blog.csdn.net/linhuanmars/article/details/22913699</span></span><br><span class="line">    <span class="comment">//另一种递归风格,但速度较慢</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> sum*<span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">return</span> helper(root.left,sum*<span class="number">10</span>+root.val) + helper(root.right,sum*<span class="number">10</span>+root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Sum_Root_to_Leaf_Numbers_-_二叉树所有路径之和">Sum Root to Leaf Numbers - 二叉树所有路径之和</h3><p><strong>Description</strong>: Given a binary tree ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Longest Consecutive Sequence - 最长的连续序列Word Ladder II - 词梯II]]></title>
    <link href="http://eugeneyang.com/2016/02/16/Longest%20Consecutive%20Sequence%20-%20%E6%9C%80%E9%95%BF%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <id>http://eugeneyang.com/2016/02/16/Longest Consecutive Sequence - 最长的连续序列/</id>
    <published>2016-02-16T12:44:47.000Z</published>
    <updated>2016-02-17T16:08:21.455Z</updated>
    <content type="html"><![CDATA[<h3 id="Longest_Consecutive_Sequence_-_最长的连续序列">Longest Consecutive Sequence - 最长的连续序列</h3><p><strong>Description</strong>: Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,<br> Given [100, 4, 200, 1, 3, 2],<br> The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<p>思路：因为排序至少要O(nlogn),先排序是不行的.这里使用哈希表.</p>
<p>参考：<a href="http://www.programcreek.com/2013/01/leetcode-longest-consecutive-sequence-java/" target="_blank" rel="external">http://www.programcreek.com/2013/01/leetcode-longest-consecutive-sequence-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestConsecutiveSequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2013/01/leetcode-longest-consecutive-sequence-java/</span><br><span class="line">     * 因为排序至少要O(nlogn),先排序是不行的.这里使用哈希表.</span><br><span class="line">     * <span class="doctag">@param</span> nums</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : nums) set.add(e);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = e-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = e+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (set.contains(left))&#123;</span><br><span class="line">                count++;</span><br><span class="line">                set.remove(left);</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (set.contains(right))&#123;</span><br><span class="line">                count++;</span><br><span class="line">                set.remove(right);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            longest = Math.max(longest, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Longest_Consecutive_Sequence_-_最长的连续序列">Longest Consecutive Sequence - 最长的连续序列</h3><p><strong>Description</strong>: Given an unsorte]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Word Ladder II - 词梯II]]></title>
    <link href="http://eugeneyang.com/2016/02/15/Word%20Ladder%20II%20-%20%E8%AF%8D%E6%A2%AFII/"/>
    <id>http://eugeneyang.com/2016/02/15/Word Ladder II - 词梯II/</id>
    <published>2016-02-15T12:44:47.000Z</published>
    <updated>2016-02-17T16:08:21.451Z</updated>
    <content type="html"><![CDATA[<h3 id="Word_Ladder_II_-_词梯II">Word Ladder II - 词梯II</h3><p><strong>Description</strong>: Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:<br> 1 Only one letter can be changed at a time<br> 2 Each intermediate word must exist in the word list</p>
<p> For example,<br> Given: beginWord = “hit” endWord = “cog”<br> wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br> Return<br> [ [“hit”,”hot”,”dot”,”dog”,”cog”],<br> [“hit”,”hot”,”lot”,”log”,”cog”] ]</p>
<p> Note:<br> All words have the same length.<br> All words contain only lowercase alphabetic characters.</p>
<p>思路：分支限界法(BFS,最短路径),与Word Ladder思路类似,不同点在于<br>     1 不能直接从wordList中直接删除访问过的字符串,需要引入两个新的集合,只有转换步数发生变化,才从字典中移除(观察到不同转换序列不可能出现重复的词,除了首尾两个词);<br>     2 引入的数据结构WordNode多一个字段</p>
<p>参考：<a href="http://www.programcreek.com/2014/06/leetcode-word-ladder-ii-java/" target="_blank" rel="external">http://www.programcreek.com/2014/06/leetcode-word-ladder-ii-java/</a></p>
<p>注意：将chars字符数组转换成String千万别写成了chars.toString(); ，不小心犯了这个低级错误会很麻烦。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordLadderII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String beginWord = <span class="string">"a"</span>;</span><br><span class="line">        String endWord = <span class="string">"c"</span>;</span><br><span class="line">        Set&lt;String&gt; wordList = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        wordList.add(<span class="string">"a"</span>);</span><br><span class="line">        wordList.add(<span class="string">"b"</span>);</span><br><span class="line">        wordList.add(<span class="string">"c"</span>);</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> WordLadderII().findLadders(beginWord, endWord, wordList);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; list : result)&#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : list)&#123;</span><br><span class="line">                System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WordNode</span></span>&#123;</span><br><span class="line">        String word;</span><br><span class="line">        List&lt;String&gt; transformList; <span class="comment">//TODO 这里可以改成存储WordNode pre来优化性能</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WordNode</span><span class="params">(String word, List&lt;String&gt; oldTransformList)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.word = word;</span><br><span class="line">            transformList = <span class="keyword">new</span> ArrayList&lt;&gt;(oldTransformList);</span><br><span class="line">            transformList.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSteps</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> transformList.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 分支限界法(BFS,最短路径),与Word Ladder思路类似,不同点在于</span><br><span class="line">     1 不能直接从wordList中直接删除访问过的字符串,需要引入两个新的集合;</span><br><span class="line">     2 引入的数据结构WordNode多一个字段</span><br><span class="line">     * http://www.programcreek.com/2014/06/leetcode-word-ladder-ii-java/</span><br><span class="line">     * <span class="doctag">@param</span> beginWord</span><br><span class="line">     * <span class="doctag">@param</span> endWord</span><br><span class="line">     * <span class="doctag">@param</span> wordList</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, Set&lt;String&gt; wordList) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;WordNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> WordNode(beginWord, <span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">        wordList.add(endWord);</span><br><span class="line">        <span class="comment">//不能直接从wordList中直接删除访问过的字符串,引入两个新的集合</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; unVisited = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">int</span> minSteps = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> preSteps = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            WordNode top = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> curSteps = top.getSteps();</span><br><span class="line">            <span class="keyword">if</span> (top.word.equals(endWord)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curSteps &gt; minSteps) <span class="keyword">return</span> result;</span><br><span class="line">                minSteps = curSteps;</span><br><span class="line">                result.add(top.transformList);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//只有转换步数发生变化,才从字典中移除(观察到不同转换序列不可能出现重复的词,除了首尾两个词)</span></span><br><span class="line">            <span class="keyword">if</span> (curSteps &gt; preSteps) &#123;</span><br><span class="line">                unVisited.removeAll(visited);</span><br><span class="line">                preSteps = curSteps;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span>[] chars = top.word.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;chars.length; i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> origin = chars[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c=<span class="string">'a'</span>; c&lt;=<span class="string">'z'</span>; c++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (chars[i]!=c) chars[i] = c;</span><br><span class="line">                    String newString = <span class="keyword">new</span> String(chars);   <span class="comment">//TODO 千万别写成了chars.toString();</span></span><br><span class="line">                    <span class="keyword">if</span> (unVisited.contains(newString))&#123;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> WordNode(newString, top.transformList));</span><br><span class="line">                        visited.add(newString);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                chars[i] = origin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Word_Ladder_II_-_词梯II">Word Ladder II - 词梯II</h3><p><strong>Description</strong>: Given two words (beginWord and endWord), and a dic]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Word Ladder - 词梯]]></title>
    <link href="http://eugeneyang.com/2016/02/14/Word%20Ladder%20-%20%E8%AF%8D%E6%A2%AF/"/>
    <id>http://eugeneyang.com/2016/02/14/Word Ladder - 词梯/</id>
    <published>2016-02-14T12:44:47.000Z</published>
    <updated>2016-02-17T16:08:21.448Z</updated>
    <content type="html"><![CDATA[<h3 id="Word_Ladder_-_词梯">Word Ladder - 词梯</h3><p><strong>Description</strong>: Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:<br> 1 Only one letter can be changed at a time<br> 2 Each intermediate word must exist in the word list</p>
<p>For example,<br> Given:<br> beginWord = “hit” endWord = “cog”<br> wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br> As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br> return its length 5.</p>
<p>Note:<br> Return 0 if there is no such transformation sequence.<br> All words have the same length.<br> All words contain only lowercase alphabetic characters.</p>
<p>思路：分支限界法(BFS,最短路径)</p>
<p>参考：<a href="http://www.programcreek.com/2012/12/leetcode-word-ladder/" target="_blank" rel="external">http://www.programcreek.com/2012/12/leetcode-word-ladder/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordLadder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WordNode</span></span>&#123;</span><br><span class="line">        String word;</span><br><span class="line">        <span class="keyword">int</span> numSteps;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WordNode</span><span class="params">(String word, <span class="keyword">int</span> numSteps)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.word = word;</span><br><span class="line">            <span class="keyword">this</span>.numSteps = numSteps;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2012/12/leetcode-word-ladder/</span><br><span class="line">     * 分支限界法(BFS,最短路径)</span><br><span class="line">     * <span class="doctag">@param</span> beginWord</span><br><span class="line">     * <span class="doctag">@param</span> endWord</span><br><span class="line">     * <span class="doctag">@param</span> wordList</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, Set&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        Queue&lt;WordNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> WordNode(beginWord, <span class="number">1</span>));</span><br><span class="line">        wordList.add(endWord);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            WordNode top = queue.remove();</span><br><span class="line">            String word = top.word;</span><br><span class="line">            <span class="keyword">if</span>(word.equals(endWord)) <span class="keyword">return</span> top.numSteps;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;chars.length; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c=<span class="string">'a'</span>; c&lt;=<span class="string">'z'</span>; c++)&#123;</span><br><span class="line">                    <span class="keyword">char</span> temp = chars[i];</span><br><span class="line">                    <span class="keyword">if</span>(chars[i]!=c) chars[i] = c;</span><br><span class="line">                    String newWord = <span class="keyword">new</span> String(chars);</span><br><span class="line">                    <span class="keyword">if</span>(wordList.contains(newWord))&#123;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> WordNode(newWord, top.numSteps+<span class="number">1</span>));</span><br><span class="line">                        wordList.remove(newWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                    chars[i] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Word_Ladder_-_词梯">Word Ladder - 词梯</h3><p><strong>Description</strong>: Given two words (beginWord and endWord), and a dictionary’s ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Valid Palindrome - 回文判断]]></title>
    <link href="http://eugeneyang.com/2016/02/13/Valid%20Palindrome%20-%20%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/"/>
    <id>http://eugeneyang.com/2016/02/13/Valid Palindrome - 回文判断/</id>
    <published>2016-02-13T12:44:47.000Z</published>
    <updated>2016-02-17T16:08:21.445Z</updated>
    <content type="html"><![CDATA[<h3 id="Valid_Palindrome_-_回文判断">Valid Palindrome - 回文判断</h3><p><strong>Description</strong>: Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>For example, “A man, a plan, a canal: Panama” is a palindrome.(amanaplanacanalpanama)<br> “race a car” is not a palindrome.(raceacar)</p>
<p>Note: Have you consider that the string might be empty? For the purpose of this problem, we define empty string as valid palindrome.</p>
<p>思路：正则表达式与双指针。</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidPalindrome</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 正则表达式与双指针。</span><br><span class="line">     * <span class="doctag">@param</span> s</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        s = s.replaceAll(<span class="string">"[^a-zA-Z0-9]"</span>, <span class="string">""</span>).toLowerCase();</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r=s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(l++)!=s.charAt(r--)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Valid_Palindrome_-_回文判断">Valid Palindrome - 回文判断</h3><p><strong>Description</strong>: Given a string, determine if it is a palindrom]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binary Tree Maximum Path Sum - 二叉树最大路径和]]></title>
    <link href="http://eugeneyang.com/2016/02/12/Binary%20Tree%20Maximum%20Path%20Sum%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://eugeneyang.com/2016/02/12/Binary Tree Maximum Path Sum - 二叉树最大路径和/</id>
    <published>2016-02-12T12:44:47.000Z</published>
    <updated>2016-02-17T16:08:21.442Z</updated>
    <content type="html"><![CDATA[<h3 id="Binary_Tree_Maximum_Path_Sum_-_二叉树最大路径和">Binary Tree Maximum Path Sum - 二叉树最大路径和</h3><p><strong>Description</strong>: Given a binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root.</p>
<p>For example: Given the below binary tree,<br>    1<br>  / \<br> 2   3<br> Return 6.</p>
<p>思路：递归:递归计算左,右子树最大路径和,从左,右子树最大路径和与根节点中选出单侧最大值, 再从单侧最大值,当前全路径和,全局最大路径和中选出最大值.</p>
<p>注意：节点值可能出现负值,比较时不能漏掉单节点情况.</p>
<p>参考：<a href="http://www.programcreek.com/2013/02/leetcode-binary-tree-maximum-path-sum-java/" target="_blank" rel="external">http://www.programcreek.com/2013/02/leetcode-binary-tree-maximum-path-sum-java/</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeMaximumPathSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * http://www.programcreek.com/2013/02/leetcode-binary-tree-maximum-path-sum-java/</span><br><span class="line">     * 递归:递归计算左,右子树最大路径和,从左,右子树最大路径和与根节点中选出单侧最大值,</span><br><span class="line">     再从单侧最大值,当前全路径和,全局最大路径和中选出最大值.</span><br><span class="line">     * 注意节点值可能出现负值,比较时不能漏掉单节点情况.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxPath(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxPath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLeft = maxPath(root.left);</span><br><span class="line">        <span class="keyword">int</span> maxRight = maxPath(root.right);</span><br><span class="line">        <span class="comment">//比较root.val, root.val+maxLeft, root.val+maxRight</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = Math.max(root.val, Math.max(root.val+maxLeft, root.val+maxRight));</span><br><span class="line">        <span class="comment">//比较maxSum, maxCurrent, maxLeft+root.val+maxRight</span></span><br><span class="line">        maxSum = Math.max(maxSum, Math.max(maxSide, maxLeft+root.val+maxRight));</span><br><span class="line">        <span class="keyword">return</span> maxSide;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Binary_Tree_Maximum_Path_Sum_-_二叉树最大路径和">Binary Tree Maximum Path Sum - 二叉树最大路径和</h3><p><strong>Description</strong>: Given a binary]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock III - 买股票的最佳时机III]]></title>
    <link href="http://eugeneyang.com/2016/02/11/Best%20Time%20to%20Buy%20and%20Sell%20Stock%20III%20-%20%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII/"/>
    <id>http://eugeneyang.com/2016/02/11/Best Time to Buy and Sell Stock III - 买股票的最佳时机III/</id>
    <published>2016-02-11T12:44:47.000Z</published>
    <updated>2016-02-10T16:08:20.717Z</updated>
    <content type="html"><![CDATA[<h3 id="Best_Time_to_Buy_and_Sell_Stock_III_-_买股票的最佳时机III">Best Time to Buy and Sell Stock III - 买股票的最佳时机III</h3><p><strong>Description</strong>: Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>思路：两次一维动态规划组合:以第i天为分界线，计算第i天之前进行一次交易的最大收益preProfit[i]，和第i天之后进行一次交易的最大收益postProfit[i]，遍历的同时，max{preProfit[i] + postProfit[i]}(0≤i≤n-1)就是最大收益。第i天之前和第i天之后进行一次的最大收益求法同Best Time to Buy and Sell Stock I。上述方法时间复杂度O(n^2),超时.</p>
<p>优化：用数组暂存结果提速,时间复杂度O(n).</p>
<p>参考：<a href="http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html" target="_blank" rel="external">http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html</a></p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimeToBuyAndSellStockIII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html</span><br><span class="line">     * 两次一维动态规划组合:以第i天为分界线，计算第i天之前进行一次交易的最大收益preProfit[i]，</span><br><span class="line">     和第i天之后进行一次交易的最大收益postProfit[i]，</span><br><span class="line">     遍历的同时，max&#123;preProfit[i] + postProfit[i]&#125;(0≤i≤n-1)就是最大收益。</span><br><span class="line">     第i天之前和第i天之后进行一次的最大收益求法同Best Time to Buy and Sell Stock I。</span><br><span class="line">     上述方法时间复杂度O(n^2),超时.</span><br><span class="line">     优化:用数组暂存结果提速,时间复杂度O(n).</span><br><span class="line">     * <span class="doctag">@param</span> prices</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] preProfit = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] postProfit = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">            preProfit[i] = Math.max(preProfit[i-<span class="number">1</span>], prices[i]-min); <span class="comment">//注意是i-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = prices[len-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=len-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            max = Math.max(max, prices[i]);</span><br><span class="line">            postProfit[i] = Math.max(postProfit[i+<span class="number">1</span>], max-prices[i]);   <span class="comment">//注意是i+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            profit = Math.max(profit, preProfit[i]+postProfit[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> preProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> postProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;len; k++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">                min = Math.min(min, prices[i]);</span><br><span class="line">                preProfit = Math.max(preProfit, prices[i]-min);</span><br><span class="line">            &#125;</span><br><span class="line">            min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=k; j&lt;len; j++)&#123;</span><br><span class="line">                min = Math.min(min, prices[j]);</span><br><span class="line">                postProfit = Math.max(postProfit, prices[j]-min);</span><br><span class="line">            &#125;</span><br><span class="line">            profit = Math.max(profit, preProfit+postProfit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Best_Time_to_Buy_and_Sell_Stock_III_-_买股票的最佳时机III">Best Time to Buy and Sell Stock III - 买股票的最佳时机III</h3><p><strong>Description</str]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock I & II - 买股票的最佳时机I&II]]></title>
    <link href="http://eugeneyang.com/2016/02/10/Best%20Time%20to%20Buy%20and%20Sell%20Stock%20I%20&%20II%20-%20%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAI&II/"/>
    <id>http://eugeneyang.com/2016/02/10/Best Time to Buy and Sell Stock I & II - 买股票的最佳时机I&II/</id>
    <published>2016-02-10T12:44:47.000Z</published>
    <updated>2016-02-10T16:08:20.715Z</updated>
    <content type="html"><![CDATA[<h3 id="Best_Time_to_Buy_and_Sell_Stock_I_&amp;_II_-_买股票的最佳时机I&amp;II">Best Time to Buy and Sell Stock I &amp; II - 买股票的最佳时机I&amp;II</h3><p>Best Time to Buy and Sell Stock I</p>
<p><strong>Description</strong>: Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>思路：最一般的方法是嵌套遍历找到最大买入卖出差,但超时.<br>用一维动态规划(双重):记录出现过的最低价作为买入价格,计算当天售出的收益.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimeToBuyAndSellStock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 最一般的方法是嵌套遍历找到最大买入卖出差,但超时.</span><br><span class="line">     一维动态规划(双重):记录出现过的最低价作为买入价格,计算当天售出的收益.</span><br><span class="line">     P(i)=Max(P(i-1), price[i]-B(i))</span><br><span class="line">     B(i)=Min(B(i-1), price[i])</span><br><span class="line">     * <span class="doctag">@param</span> prices</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">            profit = Math.max(profit, prices[i]-min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Best Time to Buy and Sell Stock II</p>
<p><strong>Description</strong>: Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). </p>
<p>However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>思路：贪心方法:递增序前后元素差之和.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimeToBuyAndSellStockII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 贪心方法:递增序前后元素差之和.</span><br><span class="line">     * <span class="doctag">@param</span> prices</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i]&gt;prices[i-<span class="number">1</span>])</span><br><span class="line">                profit += prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Best_Time_to_Buy_and_Sell_Stock_I_&amp;_II_-_买股票的最佳时机I&amp;II">Best Time to Buy and Sell Stock I &amp; II - 买股票的最佳时机I&amp;II</h3><p>]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Triangle - 三角形中最短路径和]]></title>
    <link href="http://eugeneyang.com/2016/02/08/Triangle%20-%20%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%AD%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://eugeneyang.com/2016/02/08/Triangle - 三角形中最短路径和/</id>
    <published>2016-02-08T12:44:47.000Z</published>
    <updated>2016-02-10T16:08:20.713Z</updated>
    <content type="html"><![CDATA[<h3 id="Triangle_-_三角形中最短路径和">Triangle - 三角形中最短路径和</h3><p><strong>Description</strong>: Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p> Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
<p>原题链接：<a href="https://leetcode.com/submissions/detail/52958615/" target="_blank" rel="external">https://leetcode.com/submissions/detail/52958615/</a></p>
<p>思路：二维动态规划(自顶向下):在某一个元素i，j的最小路径和就是它上层对应的相邻两个元素的最小路径和加上自己的值，递推式是sum[i][j]=min(sum[i-1][j-1],sum[i-1][j])+triangle[i][j],最后扫描一遍最后一层的路径和，取出最小的即可。</p>
<p>复杂度:每个元素需要维护一次，总共有1+2+…+n=n*(n+1)/2个元素，所以时间复杂度是O(n^2)；而空间上每次只需维护一层即可（因为当前层只用到上一层的元素），所以空间复杂度是O(n).</p>
<p>或者采用动态规划(自底向上):sum[i][j]=min(sum[i+1][j],sum[i+1][j+1])+triangle[i][j]，自底向上的方式省去了对每层首尾元素的特殊处理,更简洁.</p>
<p>参考：<a href="http://blog.csdn.net/linhuanmars/article/details/23230657" target="_blank" rel="external">http://blog.csdn.net/linhuanmars/article/details/23230657</a></p>
<p>完整的java代码如下（自底向上）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PascalTriangleII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 与Pascal's Triangle类似,但是空间可以压缩为O(k).注意in-place更新值时要逆序(观察Pascal三角的特点)</span><br><span class="line">     * <span class="doctag">@param</span> rowIndex</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (rowIndex&lt;<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        result.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">1</span>; row&lt;rowIndex+<span class="number">1</span>; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=result.size()-<span class="number">1</span>; j&gt;<span class="number">0</span>; j--)&#123;    <span class="comment">//注意一定要倒序遍历,因为顺序会覆盖值</span></span><br><span class="line">                result.set(j, result.get(j-<span class="number">1</span>) + result.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Triangle_-_三角形中最短路径和">Triangle - 三角形中最短路径和</h3><p><strong>Description</strong>: Given a triangle, find the minimum path sum from top]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pascal's Triangle II]]></title>
    <link href="http://eugeneyang.com/2016/02/07/Pascal's%20Triangle%20II/"/>
    <id>http://eugeneyang.com/2016/02/07/Pascal's Triangle II/</id>
    <published>2016-02-07T12:44:47.000Z</published>
    <updated>2016-02-10T16:08:20.711Z</updated>
    <content type="html"><![CDATA[<h3 id="Pascal’s_Triangle_II">Pascal’s Triangle II</h3><p><strong>Description</strong>: Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3, Return [1,3,3,1].</p>
<p> Note: Could you optimize your algorithm to use only O(k) extra space?</p>
<p> 示例：k=5时Pascal三角如下<br> [<br>&nbsp;&nbsp;&nbsp;&nbsp;[1],<br>&nbsp;&nbsp;&nbsp;[1,1],<br>&nbsp;&nbsp;[1,2,1],<br>&nbsp;[1,3,3,1],<br> [1,4,6,4,1]<br> ]</p>
<p>思路：与Pascal’s Triangle类似,但是空间可以压缩为O(k).注意in-place更新值时要逆序(观察Pascal三角的特点)</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PascalTriangleII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 与Pascal's Triangle类似,但是空间可以压缩为O(k).注意in-place更新值时要逆序(观察Pascal三角的特点)</span><br><span class="line">     * <span class="doctag">@param</span> rowIndex</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (rowIndex&lt;<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        result.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">1</span>; row&lt;rowIndex+<span class="number">1</span>; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=result.size()-<span class="number">1</span>; j&gt;<span class="number">0</span>; j--)&#123;    <span class="comment">//注意一定要倒序遍历,因为顺序会覆盖值</span></span><br><span class="line">                result.set(j, result.get(j-<span class="number">1</span>) + result.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Pascal’s_Triangle_II">Pascal’s Triangle II</h3><p><strong>Description</strong>: Given an index k, return the kth row of the Pascal’s]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pascal's Triangle]]></title>
    <link href="http://eugeneyang.com/2016/02/06/Pascal's%20Triangle/"/>
    <id>http://eugeneyang.com/2016/02/06/Pascal's Triangle/</id>
    <published>2016-02-06T12:44:47.000Z</published>
    <updated>2016-02-10T16:08:20.709Z</updated>
    <content type="html"><![CDATA[<h3 id="Pascal’s_Triangle">Pascal’s Triangle</h3><p><strong>Description</strong>: Given numRows, generate the first numRows of Pascal’s triangle.</p>
<p> For example, given numRows = 5,<br> Return<br> [<br>&nbsp;&nbsp;&nbsp;&nbsp;[1],<br>&nbsp;&nbsp;&nbsp;[1,1],<br>&nbsp;&nbsp;[1,2,1],<br>&nbsp;[1,3,3,1],<br> [1,4,6,4,1]<br> ]</p>
<p> 思路：时间复杂度O(1+2+3+…+n)=O(n^2)，空间上只需要二维数组来存储结果;因为是求解每一行结果，所以空间上没有更优的办法.</p>
<p>完整的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PascalTriangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 时间复杂度O(1+2+3+...+n)=O(n^2)，空间上只需要二维数组来存储结果;</span><br><span class="line">     因为是求解每一行结果，所以空间上没有更优.</span><br><span class="line">     * <span class="doctag">@param</span> numRows</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (numRows==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        List&lt;Integer&gt; pre = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        pre.add(<span class="number">1</span>);</span><br><span class="line">        result.add(pre);</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; numRows)&#123;</span><br><span class="line">            cur.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pre.size()-<span class="number">1</span>; i++)&#123;</span><br><span class="line">                cur.add(pre.get(i) + pre.get(i+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            cur.add(<span class="number">1</span>);</span><br><span class="line">            result.add(cur);</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Pascal’s_Triangle">Pascal’s Triangle</h3><p><strong>Description</strong>: Given numRows, generate the first numRows of Pascal’s tria]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Populating Next Right Pointers in Each Node II - 填充二叉树每个节点的右指针II]]></title>
    <link href="http://eugeneyang.com/2016/02/05/Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II%20-%20%E5%A1%AB%E5%85%85%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%8F%B3%E6%8C%87%E9%92%88II/"/>
    <id>http://eugeneyang.com/2016/02/05/Populating Next Right Pointers in Each Node II - 填充二叉树每个节点的右指针II/</id>
    <published>2016-02-05T12:44:47.000Z</published>
    <updated>2016-02-10T16:08:20.707Z</updated>
    <content type="html"><![CDATA[<h3 id="Populating_Next_Right_Pointers_in_Each_Node_II_-_填充二叉树每个节点的右指针II">Populating Next Right Pointers in Each Node II - 填充二叉树每个节点的右指针II</h3><p><strong>Description</strong>: Follow up for problem “Populating Next Right Pointers in Each Node”. What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>Note: You may only use constant extra space.</p>
<p> 思路：<br> 1 找到规律用递归求解,类似上一题Populating Next Right Pointers in Each Node, 唯一的不同是每次要先找到一个第一个有效的next链接节点，并且递归的时候要先处理右子树，再处理左子树.（(OJ 78%，思路较难想到）<br> 参考：<a href="http://fisherlei.blogspot.tw/2012/12/leetcode-populating-next-right-pointers_29.html" target="_blank" rel="external">http://fisherlei.blogspot.tw/2012/12/leetcode-populating-next-right-pointers_29.html</a><br>2 类似二叉树层次遍历,但不再使用队列,而是将树的每一层维护成一个链表,空间复杂度O(1); 每次维护两层,共计4个指针:lastHead, curHead, lastCur, curPre.<br>参考：<a href="http://www.programcreek.com/2014/06/leetcode-populating-next-right-pointers-in-each-node-ii-java/" target="_blank" rel="external">http://www.programcreek.com/2014/06/leetcode-populating-next-right-pointers-in-each-node-ii-java/</a><br>3 类似二叉树层次遍历,使用队列,空间复杂度O(n)</p>
<p>完整的java代码如下（含三种方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PopulatingNextRightPointersInEachNodeII</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeLinkNode left, right, next;</span><br><span class="line">        TreeLinkNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**(OJ 78%)</span><br><span class="line">     * http://fisherlei.blogspot.tw/2012/12/leetcode-populating-next-right-pointers_29.html</span><br><span class="line">     * 找到规律用递归求解,类似上一题Populating Next Right Pointers in Each Node,</span><br><span class="line">     唯一的不同是每次要先找到一个第一个有效的next链接节点，并且递归的时候要先处理右子树，再处理左子树.</span><br><span class="line">     空间复杂度O(1)</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeLinkNode p = root.next;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                p = p.left; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                p = p.right; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) root.right.next = p;</span><br><span class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>) root.left.next = root.right!=<span class="keyword">null</span> ? root.right : p;</span><br><span class="line">        connect(root.right);</span><br><span class="line">        connect(root.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**(OJ 30%)</span><br><span class="line">     * http://www.programcreek.com/2014/06/leetcode-populating-next-right-pointers-in-each-node-ii-java/</span><br><span class="line">     * 类似二叉树层次遍历,但不再使用队列,而是将树的每一层维护成一个链表,空间复杂度O(1);</span><br><span class="line">     每次维护两层,共计4个指针:lastHead, curHead, lastCur, curPre.</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect1</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeLinkNode lastHead = root;</span><br><span class="line">        TreeLinkNode curHead = <span class="keyword">null</span>;</span><br><span class="line">        TreeLinkNode lastCur = <span class="keyword">null</span>;</span><br><span class="line">        TreeLinkNode curPre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(lastHead!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            lastCur = lastHead;</span><br><span class="line">            <span class="keyword">while</span>(lastCur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(lastCur.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(curHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        curHead = lastCur.left;</span><br><span class="line">                        curPre = lastCur.left;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        curPre.next = lastCur.left;</span><br><span class="line">                        curPre = curPre.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(lastCur.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(curHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        curHead = lastCur.right;</span><br><span class="line">                        curPre = lastCur.right;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        curPre.next = lastCur.right;</span><br><span class="line">                        curPre = curPre.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lastCur = lastCur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            lastHead = curHead; <span class="comment">//往下层移动</span></span><br><span class="line">            curHead = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**类似二叉树层次遍历,使用队列,空间复杂度O(n)</span><br><span class="line">     * <span class="doctag">@param</span> root</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect2</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeLinkNode&gt; curQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeLinkNode&gt; nextQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        curQueue.offer(root);</span><br><span class="line">        TreeLinkNode old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!curQueue.isEmpty())&#123;</span><br><span class="line">            TreeLinkNode node = curQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (old!=<span class="keyword">null</span>) old.next = node;</span><br><span class="line">            old = node;</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>) nextQueue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>) nextQueue.offer(node.right);</span><br><span class="line">            <span class="keyword">if</span> (curQueue.isEmpty())&#123;</span><br><span class="line">                old = <span class="keyword">null</span>;</span><br><span class="line">                curQueue = nextQueue;</span><br><span class="line">                nextQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Populating_Next_Right_Pointers_in_Each_Node_II_-_填充二叉树每个节点的右指针II">Populating Next Right Pointers in Each Node II - 填充二叉树每个节点的右指针II</]]>
    </summary>
    
      <category term="LeetCode" scheme="http://eugeneyang.com/tags/LeetCode/"/>
    
      <category term="java" scheme="http://eugeneyang.com/tags/java/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://eugeneyang.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
